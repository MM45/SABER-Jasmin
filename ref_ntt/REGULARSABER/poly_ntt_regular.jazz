/*** poly_ntt_regular.jazz: File containing the Jasmin wrappers of the functions in the poly_ntt_regular*.jahh files, only used for unit testing ***/

#include "SABER_params.jahh"
#include "poly_ntt_regular_poly_crt.jahh"
#include "poly_ntt_regular_poly_ntt.jahh"
#include "poly_ntt_regular_poly_invntt_tomont.jahh"

export fn poly_crt_jazz(reg u64 rp, reg u64 ap, reg u64 bp)
{
	inline int i;

	reg u16 t16;

	stack u16[SABER_N] a;
	stack u16[SABER_N] b;
	stack u16[SABER_N] r;

	// TODO: technically not necessary to copy, as r is only used as output
	for i = 0 to SABER_N {
		t16 = (u16) [rp + 2 * i];
		r[i] = t16;
	}

	for i = 0 to SABER_N {
		t16 = (u16) [ap + 2 * i];
		a[i] = t16;
	}

	for i = 0 to SABER_N {
		t16 = (u16) [bp + 2 * i];
		b[i] = t16;
	}

	r = poly_crt(r, a, b);

	for i = 0 to SABER_N {
		t16 = r[i];
		(u16) [rp + 2 * i] = t16;
	}
}


// pdata == PDATA0
export fn poly_ntt_0_jazz(reg u64 rp, reg u64 ap)
{
	inline int i;

	reg u16 t16;

	stack u16[SABER_N] a;
	stack u16[SABER_N] r;

	// TODO: technically not necessary to copy, as r is only used as output
	for i = 0 to SABER_N {
		t16 = (u16) [rp + 2 * i];
		r[i] = t16;
	}

	for i = 0 to SABER_N {
		t16 = (u16) [ap + 2 * i];
		a[i] = t16;
	}

	r = poly_ntt_0(r, a);

	for i = 0 to SABER_N {
		t16 = r[i];
		(u16) [rp + 2 * i] = t16;
	}
}

// pdata == PDATA1
export fn poly_ntt_1_jazz(reg u64 rp, reg u64 ap)
{
	inline int i;

	reg u16 t16;

	stack u16[SABER_N] a;
	stack u16[SABER_N] r;

	// TODO: technically not necessary to copy, as r is only used as output
	for i = 0 to SABER_N {
		t16 = (u16) [rp + 2 * i];
		r[i] = t16;
	}

	for i = 0 to SABER_N {
		t16 = (u16) [ap + 2 * i];
		a[i] = t16;
	}

	r = poly_ntt_1(r, a);

	for i = 0 to SABER_N {
		t16 = r[i];
		(u16) [rp + 2 * i] = t16;
	}
}


// pdata == PDATA0
export fn poly_invntt_tomont_0_jazz(reg u64 rp, reg u64 ap)
{
	inline int i;

	reg u16 t16;

	stack u16[SABER_N] a;
	stack u16[SABER_N] r;

	// TODO: technically not necessary to copy, as r is only used as output
	for i = 0 to SABER_N {
		t16 = (u16) [rp + 2 * i];
		r[i] = t16;
	}

	for i = 0 to SABER_N {
		t16 = (u16) [ap + 2 * i];
		a[i] = t16;
	}

	r = poly_invntt_tomont_0(r, a);

	for i = 0 to SABER_N {
		t16 = r[i];
		(u16) [rp + 2 * i] = t16;
	}
}

// pdata == PDATA1
export fn poly_invntt_tomont_1_jazz(reg u64 rp, reg u64 ap)
{
	inline int i;

	reg u16 t16;

	stack u16[SABER_N] a;
	stack u16[SABER_N] r;

	// TODO: technically not necessary to copy, as r is only used as output
	for i = 0 to SABER_N {
		t16 = (u16) [rp + 2 * i];
		r[i] = t16;
	}

	for i = 0 to SABER_N {
		t16 = (u16) [ap + 2 * i];
		a[i] = t16;
	}

	r = poly_invntt_tomont_1(r, a);

	for i = 0 to SABER_N {
		t16 = r[i];
		(u16) [rp + 2 * i] = t16;
	}
}
