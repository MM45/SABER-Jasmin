/*** polyvec_ntt_regular.jazz: File containing the Jasmin wrappers of the functions in the polyvec_ntt_regular_*.jahh files, only used for unit testing ***/

#include "SABER_params.jahh"
#include "polyvec_ntt_regular_polyvec_crt.jahh"
#include "polyvec_ntt_regular_polyvec_ntt.jahh"
#include "polyvec_ntt_regular_polyvec_invntt_tomont.jahh"
#include "polyvec_ntt_regular_polyvec_basemul_acc_montgomery.jahh"
#include "polyvec_ntt_regular_polyvec_matrix_vector_mul.jahh"
#include "polyvec_ntt_regular_polyvec_iprod.jahh"

export fn polyvec_crt_jazz(reg u64 rp, reg u64 ap, reg u64 bp)
{
	inline int i;

	reg u16 t16;

	stack u16[SABER_KN] a;
	stack u16[SABER_KN] b;
	stack u16[SABER_KN] r;

	// TODO: technically not necessary to copy, as r is only used as output
	for i = 0 to SABER_KN {
		t16 = (u16) [rp + 2 * i];
		r[i] = t16;
	}

	for i = 0 to SABER_KN {
		t16 = (u16) [ap + 2 * i];
		a[i] = t16;
	}

	for i = 0 to SABER_KN {
		t16 = (u16) [bp + 2 * i];
		b[i] = t16;
	}

	r = polyvec_crt(r, a, b);

	for i = 0 to SABER_KN {
		t16 = r[i];
		(u16) [rp + 2 * i] = t16;
	}
}

export fn polyvec_ntt_0_jazz(reg u64 rp, reg u64 ap)
{
	inline int i;

	reg u16 t16;

	stack u16[SABER_KN] a;
	stack u16[SABER_KN] r;

	// TODO: technically not necessary to copy, as r is only used as output
	for i = 0 to SABER_KN {
		t16 = (u16) [rp + 2 * i];
		r[i] = t16;
	}

	for i = 0 to SABER_KN {
		t16 = (u16) [ap + 2 * i];
		a[i] = t16;
	}

	r = polyvec_ntt_0(r, a);

	for i = 0 to SABER_KN {
		t16 = r[i];
		(u16) [rp + 2 * i] = t16;
	}
}

export fn polyvec_ntt_1_jazz(reg u64 rp, reg u64 ap)
{
	inline int i;

	reg u16 t16;

	stack u16[SABER_KN] a;
	stack u16[SABER_KN] r;

	// TODO: technically not necessary to copy, as r is only used as output
	for i = 0 to SABER_KN {
		t16 = (u16) [rp + 2 * i];
		r[i] = t16;
	}

	for i = 0 to SABER_KN {
		t16 = (u16) [ap + 2 * i];
		a[i] = t16;
	}

	r = polyvec_ntt_1(r, a);

	for i = 0 to SABER_KN {
		t16 = r[i];
		(u16) [rp + 2 * i] = t16;
	}
}

export fn polyvec_invntt_tomont_0_jazz(reg u64 rp, reg u64 ap)
{
	inline int i;

	reg u16 t16;

	stack u16[SABER_KN] a;
	stack u16[SABER_KN] r;

	// TODO: technically not necessary to copy, as r is only used as output
	for i = 0 to SABER_KN {
		t16 = (u16) [rp + 2 * i];
		r[i] = t16;
	}

	for i = 0 to SABER_KN {
		t16 = (u16) [ap + 2 * i];
		a[i] = t16;
	}

	r = polyvec_invntt_tomont_0(r, a);

	for i = 0 to SABER_KN {
		t16 = r[i];
		(u16) [rp + 2 * i] = t16;
	}
}

export fn polyvec_invntt_tomont_1_jazz(reg u64 rp, reg u64 ap)
{
	inline int i;

	reg u16 t16;

	stack u16[SABER_KN] a;
	stack u16[SABER_KN] r;

	// TODO: technically not necessary to copy, as r is only used as output
	for i = 0 to SABER_KN {
		t16 = (u16) [rp + 2 * i];
		r[i] = t16;
	}

	for i = 0 to SABER_KN {
		t16 = (u16) [ap + 2 * i];
		a[i] = t16;
	}

	r = polyvec_invntt_tomont_1(r, a);

	for i = 0 to SABER_KN {
		t16 = r[i];
		(u16) [rp + 2 * i] = t16;
	}
}


export fn polyvec_basemul_acc_montgomery_0_jazz(reg u64 rp, reg u64 ap, reg u64 bp)
{
	inline int i;

	reg u16 t16;

	stack u16[SABER_KN] a;
	stack u16[SABER_KN] b;
	stack u16[SABER_N] r;

	// TODO: technically not necessary to copy, as r is only used as output
	for i = 0 to SABER_N {
		t16 = (u16) [rp + 2 * i];
		r[i] = t16;
	}

	for i = 0 to SABER_KN {
		t16 = (u16) [ap + 2 * i];
		a[i] = t16;
	}

	for i = 0 to SABER_KN {
		t16 = (u16) [bp + 2 * i];
		b[i] = t16;
	}

	r = polyvec_basemul_acc_montgomery_0(r, a, b);

	for i = 0 to SABER_N {
		t16 = r[i];
		(u16) [rp + 2 * i] = t16;
	}
}

export fn polyvec_basemul_acc_montgomery_1_jazz(reg u64 rp, reg u64 ap, reg u64 bp)
{
	inline int i;

	reg u16 t16;

	stack u16[SABER_KN] a;
	stack u16[SABER_KN] b;
	stack u16[SABER_N] r;

	// TODO: technically not necessary to copy, as r is only used as output
	for i = 0 to SABER_N {
		t16 = (u16) [rp + 2 * i];
		r[i] = t16;
	}

	for i = 0 to SABER_KN {
		t16 = (u16) [ap + 2 * i];
		a[i] = t16;
	}

	for i = 0 to SABER_KN {
		t16 = (u16) [bp + 2 * i];
		b[i] = t16;
	}

	r = polyvec_basemul_acc_montgomery_1(r, a, b);

	for i = 0 to SABER_N {
		t16 = r[i];
		(u16) [rp + 2 * i] = t16;
	}
}


export fn polyvec_matrix_vector_mul_jazz(reg u64 tp, reg u64 ap, reg u64 sp, reg u64 transpose)
{
	inline int i;

	reg u16 t16;

	stack u16[SABER_KKN] a;
	stack u16[SABER_KN] s;
	stack u16[SABER_KN] t;

	// TODO: technically not necessary to copy, as t is only used as output
	for i = 0 to SABER_KN {
		t16 = (u16) [tp + 2 * i];
		t[i] = t16;
	}

	for i = 0 to SABER_KKN {
		t16 = (u16) [ap + 2 * i];
		a[i] = t16;
	}

	for i = 0 to SABER_KN {
		t16 = (u16) [sp + 2 * i];
		s[i] = t16;
	}

	t = polyvec_matrix_vector_mul(t, a, s, transpose);

	for i = 0 to SABER_KN {
		t16 = t[i];
		(u16) [tp + 2 * i] = t16;
	}
}


export fn polyvec_iprod_jazz(reg u64 rp, reg u64 ap, reg u64 bp)
{
	inline int i;

	reg u16 t16;

	stack u16[SABER_KN] a;
	stack u16[SABER_KN] b;
	stack u16[SABER_N] r;

	// TODO: technically not necessary to copy, as t is only used as output
	for i = 0 to SABER_N {
		t16 = (u16) [rp + 2 * i];
		r[i] = t16;
	}

	for i = 0 to SABER_KN {
		t16 = (u16) [ap + 2 * i];
		a[i] = t16;
	}

	for i = 0 to SABER_KN {
		t16 = (u16) [bp + 2 * i];
		b[i] = t16;
	}

	r = polyvec_iprod(r, a, b);

	for i = 0 to SABER_N {
		t16 = r[i];
		(u16) [rp + 2 * i] = t16;
	}
}
