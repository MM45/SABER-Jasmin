






param int CRYPTO_SECRETKEYBYTES = 1568;
param int CRYPTO_PUBLICKEYBYTES = (2 * 320 + 32);
param int CRYPTO_BYTES = 32;
param int CRYPTO_CIPHERTEXTBYTES = 736;
param int Saber_type = 1;

param int SABER_K = 2;
param int SABER_MU = 10;
param int SABER_ET = 3;

param int SABER_EQ = 13;
param int SABER_EP = 10;

param int SABER_N = 256;
param int SABER_Q = 8192;
param int SABER_P = 1024;

param int SABER_SEEDBYTES = 32;
param int SABER_NOISESEEDBYTES = 32;
param int SABER_COINBYTES = 32;
param int SABER_KEYBYTES = 32;

param int SABER_HASHBYTES = 32;

param int SABER_POLYBYTES = 416;

param int SABER_POLYVECBYTES = (SABER_K * SABER_POLYBYTES);

param int SABER_POLYVECCOMPRESSEDBYTES = (SABER_K * 320);

param int SABER_CIPHERTEXTBYTES = (SABER_POLYVECCOMPRESSEDBYTES);



param int SABER_SCALEBYTES_KEM = (SABER_ET * SABER_N / 8);

param int SABER_INDCPA_PUBLICKEYBYTES = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SEEDBYTES);
param int SABER_INDCPA_SECRETKEYBYTES = (SABER_POLYVECBYTES);

param int SABER_PUBLICKEYBYTES = (SABER_INDCPA_PUBLICKEYBYTES);

param int SABER_SECRETKEYBYTES = (SABER_INDCPA_SECRETKEYBYTES + SABER_INDCPA_PUBLICKEYBYTES + SABER_HASHBYTES + SABER_KEYBYTES);

param int SABER_BYTES_CCA_DEC = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SCALEBYTES_KEM);






inline fn SABER_pack_3bit(stack u8[SABER_SCALEBYTES_KEM] bytes, stack u16[SABER_N] data) -> stack u8[SABER_SCALEBYTES_KEM]
{
 inline int j;

 reg u8 br;

 reg u16 d1;
 reg u16 d2;
 reg u16 d3;
 reg u16 d4;

 for j = 0 to (SABER_N / 8) {

  d1 = data[8 * j];
  d1 &= 0x7;
  d2 = data[8 * j + 1];
  d2 &= 0x7;
  d2 <<= 3;
  d3 = data[8 * j + 2];
  d3 &= 0x3;
  d3 <<= 6;
  d1 |= d2;
  d1 |= d3;
  br = (8u) d1;
  bytes[3 * j] = br;


  d1 = data[8 * j + 2];
  d1 >>= 2;
  d1 &= 0x01;
  d2 = data[8 * j + 3];
  d2 &= 0x7;
  d2 <<= 1;
  d3 = data[8 * j + 4];
  d3 &= 0x7;
  d3 <<= 4;
  d4 = data[8 * j + 5];
  d4 &= 0x01;
  d4 <<= 7;
  d1 |= d2;
  d1 |= d3;
  d1 |= d4;
  br = (8u) d1;
  bytes[3 * j + 1] = br;


  d1 = data[8 * j + 5];
  d1 >>= 1;
  d1 &= 0x03;
  d2 = data[8 * j + 6];
  d2 &= 0x7;
  d2 <<= 2;
  d3 = data[8 * j + 7];
  d3 &= 0x7;
  d3 <<= 5;
  d1 |= d2;
  d1 |= d3;
  br = (8u) d1;
  bytes[3 * j + 2] = br;
 }

 return bytes;
}







inline fn SABER_un_pack3bit(stack u8[SABER_SCALEBYTES_KEM] bytes, stack u16[SABER_N] data) -> stack u16[SABER_N]
{
 inline int j;

 reg u16 b1;
 reg u16 b2;

 for j = 0 to (SABER_N / 8) {

  b1 = (16u) bytes[3 * j];
  b1 &= 0x07;
  data[8 * j] = b1;


  b1 = (16u)bytes[3 * j];
  b1 >>= 3;
  b1 &= 0x07;
  data[8 * j + 1] = b1;


  b1 = (16u) bytes[3 * j];
  b1 >>= 6;
  b1 &= 0x03;
  b2 = (16u) bytes[3 * j + 1];
  b2 &= 0x01;
  b2 <<= 2;
  b1 |= b2;
  data[8 * j + 2] = b1;


  b1 = (16u) bytes[3 * j + 1];
  b1 >>= 1;
  b1 &= 0x07;
  data[8 * j + 3] = b1;


  b1 = (16u) bytes[3 * j + 1];
  b1 >>= 4;
  b1 &= 0x07;
  data[8 * j + 4] = b1;


  b1 = (16u) bytes[3 * j + 1];
  b1 >>= 7;
  b1 &= 0x01;
  b2 = (16u) bytes[3 * j + 2];
  b2 &= 0x03;
  b2 <<= 1;
  b1 |= b2;
  data[8 * j + 5] = b1;


  b1 = (16u) bytes[3 * j + 2];
  b1 >>= 2;
  b1 &= 0x07;
  data[8 * j + 6] = b1;


  b1 = (16u) bytes[3 * j + 2];
  b1 >>= 5;
  b1 &= 0x07;
  data[8 * j + 7] = b1;
 }

 return data;
}


export fn SABER_pack_3bit_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_SCALEBYTES_KEM] bytes;
 stack u16[SABER_N] data;

 for i = 0 to SABER_N {
  td = (u16) [datap + 2 * i];
  data[i] = td;
 }

 bytes = SABER_pack_3bit(bytes, data);

 for i = 0 to SABER_SCALEBYTES_KEM {
  tb = bytes[i];
  (u8) [bytesp + i] = tb;
 }
}

export fn SABER_un_pack3bit_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_SCALEBYTES_KEM] bytes;
 stack u16[SABER_N] data;

 for i = 0 to SABER_SCALEBYTES_KEM {
  tb = (u8) [bytesp + i];
  bytes[i] = tb;
 }

 data = SABER_un_pack3bit(bytes, data);

 for i = 0 to SABER_N {
  td = data[i];
  (u16) [datap + 2 * i] = td;
 }
}
