








param int CRYPTO_SECRETKEYBYTES = 2304;
param int CRYPTO_PUBLICKEYBYTES = (3 * 320 + 32);
param int CRYPTO_BYTES = 32;
param int CRYPTO_CIPHERTEXTBYTES = 1088;
param int Saber_type = 2;

param int SABER_K = 3;
param int SABER_MU = 8;
param int SABER_ET = 4;

param int SABER_EQ = 13;
param int SABER_EP = 10;

param int SABER_N = 256;
param int SABER_Q = 8192;
param int SABER_P = 1024;

param int SABER_SEEDBYTES = 32;
param int SABER_NOISESEEDBYTES = 32;
param int SABER_COINBYTES = 32;
param int SABER_KEYBYTES = 32;

param int SABER_HASHBYTES = 32;

param int SABER_POLYBYTES = 416;

param int SABER_POLYVECBYTES = (SABER_K * SABER_POLYBYTES);

param int SABER_POLYVECCOMPRESSEDBYTES = (SABER_K * 320);

param int SABER_CIPHERTEXTBYTES = (SABER_POLYVECCOMPRESSEDBYTES);



param int SABER_SCALEBYTES_KEM = (SABER_ET * SABER_N / 8);

param int SABER_INDCPA_PUBLICKEYBYTES = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SEEDBYTES);
param int SABER_INDCPA_SECRETKEYBYTES = (SABER_POLYVECBYTES);

param int SABER_PUBLICKEYBYTES = (SABER_INDCPA_PUBLICKEYBYTES);

param int SABER_SECRETKEYBYTES = (SABER_INDCPA_SECRETKEYBYTES + SABER_INDCPA_PUBLICKEYBYTES + SABER_HASHBYTES + SABER_KEYBYTES);

param int SABER_BYTES_CCA_DEC = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SCALEBYTES_KEM);



param int SABER_KN = (SABER_K * SABER_N);
param int SABER_KKN = (SABER_K * SABER_K * SABER_N);
param int N_SB = (SABER_N / 4);
param int N_SB_RES = (2 * N_SB - 1);

param int SHAKE128_RATE = 168;
param int SHAKE256_RATE = 136;
param int SHA3_256_RATE = 136;
param int SHA3_512_RATE = 72;

param int KK13N8 = (SABER_K * SABER_K * (13 * SABER_N / 8));
param int MUNK8 = (SABER_MU * SABER_N * SABER_K / 8);

param int h1 = 4;
param int h2 = 228;




























inline fn load64(reg ptr u8[8] x) -> reg u64
{
 inline int i;

 reg u64 r;
 reg u64 t;

 r = (64u) x[0];

 for i = 1 to 8 {
  t = (64u) x[i];
  t <<= (8 * i);
  r |= t;
 }

 return r;
}

fn keccak_absorb_128_32(reg ptr u64[25] s, reg ptr u8[32] m) -> reg ptr u64[25]
{
 inline int i;

 reg u8 t8;

 reg u64 t64;

 stack u8[200] t;



 for i = 0 to SHAKE128_RATE {
  t[i] = 0;
 }

 for i = 0 to 32 {
  t8 = m[i];
  t[i] = t8;
 }

 t[32] = 0x1F;
 t[SHAKE128_RATE - 1] |= 128;

 for i = 0 to (SHAKE128_RATE / 8) {
  t64 = load64(t[8 * i:8]);
  s[i] ^= t64;
 }

 return s;
}











inline fn index(inline int x, inline int y) -> inline int {
  inline int r;
  r = (x % 5) + 5 * (y % 5);
  return r;
}


inline fn ROL64(reg u64 x, inline int c) -> reg u64 {
  reg u64 y;
  _, _, y = #ROL_64(x, c);
  return y;
}


inline fn theta(reg ptr u64[25] a) -> reg ptr u64[25] {
  inline int x, y;
  reg u64[5] c, d;

  for x = 0 to 5 {
    c[x] = 0;
    for y = 0 to 5 {
      c[x] ^= a[x + 5 * y];
    }
  }

  for x = 0 to 5 {
    d[x] = c[(x + 1) % 5];
    _, _, d[x] = #ROL_64(d[x], 1);
    d[x] ^= c[(x + 4) % 5];
  }

  for x = 0 to 5 {
    for y = 0 to 5 {
      a[x + 5 * y] ^= d[x];
    }
  }

  return a;
}


inline fn keccakRhoOffsets(inline int i) -> inline int {
  inline int r, x, y, z, t;

  r = 0;
  x = 1;
  y = 0;
  for t = 0 to 24 {
    if (i == x + 5 * y) {
      r = ((t + 1) * (t + 2) / 2) % 64;
    }
    z = (2 * x + 3 * y) % 5;
    x = y;
    y = z;
  }

  return r;
}


inline fn rho(reg ptr u64[25] a) -> reg ptr u64[25] {
  inline int x, y, i, z;

  for x = 0 to 5 {
    for y = 0 to 5 {
      i = index(x, y);
      z = keccakRhoOffsets(i);
      _, _, a[i] = #ROL_64(a[i], z);
    }
  }

  return a;
}


inline fn pi(reg ptr u64[25] a) -> reg ptr u64[25] {
  stack u64[25] b;
  reg u64 t;
  inline int x, y, i;
  for i = 0 to 25 { t = a[i]; b[i] = t; }

  for x = 0 to 5 {
    for y = 0 to 5 {
      t = b[x + 5 * y];
      i = index(y, 2 * x + 3 * y);
      a[i] = t;
    }
  }
  return a;
}


inline fn chi(reg ptr u64[25] a) -> reg ptr u64[25] {
  inline int x, y, i;
  reg u64[5] c;
  for y = 0 to 5 {
    for x = 0 to 5 {
      i = index(x + 1, y);
      c[x] = a[i];
      c[x] = !c[x];
      i = index(x + 2, y);
      c[x] &= a[i];
      i = index(x, y);
      c[x] ^= a[i];
    }
    for x = 0 to 5 {
      a[x + 5 * y] = c[x];
    }
  }
  return a;
}


inline fn iota(reg ptr u64[25] a, reg u64 c) -> reg ptr u64[25] {
  a[0] ^= c;
  return a;
}


inline fn keccakP1600_round(reg ptr u64[25] state, reg u64 c) -> reg ptr u64[25] {
  state = theta(state);
  state = rho(state);
  state = pi(state);
  state = chi(state);
  state = iota(state, c);
  return state;
}

u64[24] KeccakF_RoundConstants = {0x0000000000000001, 0x0000000000008082, 0x800000000000808a, 0x8000000080008000,
                                    0x000000000000808b, 0x0000000080000001, 0x8000000080008081, 0x8000000000008009,
                                    0x000000000000008a, 0x0000000000000088, 0x0000000080008009, 0x000000008000000a,
                                    0x000000008000808b, 0x800000000000008b, 0x8000000000008089, 0x8000000000008003,
                                    0x8000000000008002, 0x8000000000000080, 0x000000000000800a, 0x800000008000000a,
                                    0x8000000080008081, 0x8000000000008080, 0x0000000080000001, 0x8000000080008008};

fn KeccakF1600_StatePermute(reg ptr u64[25] state) -> reg ptr u64[25]
{
  inline int round;

  for round = 0 to 24 {
    state = keccakP1600_round(state, KeccakF_RoundConstants[round]);
  }

  return state;
}





inline fn store64(reg ptr u8[8] x, reg u64 u) -> reg ptr u8[8]
{
 inline int i;

 for i = 0 to 7 {
  x[i] = u;
  u >>= 8;
 }

 x[7] = u;

 return x;
}

inline fn keccak_squeezeblocks_128_128(reg ptr u8[SHAKE128_RATE] h, reg ptr u64[25] s) -> reg ptr u8[SHAKE128_RATE], reg ptr u64[25]
{
 inline int i;

 reg u64 u;



 s = KeccakF1600_StatePermute(s);

 for i = 0 to (SHAKE128_RATE / 8) {
  u = s[i];
  h[8 * i:8] = store64(h[8 * i:8], u);
 }

 return h, s;
}

inline fn shake128_32_32(reg ptr u8[32] output, reg ptr u8[32] input) -> reg ptr u8[32]
{
 inline int i;

 reg u8 t8;

 stack u8[SHAKE128_RATE] t;

 stack u64[25] s;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_128_32(s, input);




 t, s = keccak_squeezeblocks_128_128(t, s);

 for i = 0 to 32 {
  t8 = t[i];
  output[i] = t8;
 }

 return output;
}













inline fn keccak_squeezeblocks_128_KK13N8(reg ptr u8[KK13N8] h, reg ptr u64[25] s) -> reg ptr u8[KK13N8], reg ptr u64[25]
{
 inline int i;
 inline int j;
 inline int iterations;

 reg u64 u;

 iterations = KK13N8 / SHAKE128_RATE;

 for j = 0 to iterations {
  s = KeccakF1600_StatePermute(s);

  for i = 0 to (SHAKE128_RATE / 8) {
   u = s[i];
   h[j * SHAKE128_RATE + 8 * i:8] = store64(h[j * SHAKE128_RATE + 8 * i:8], u);
  }
 }

 return h, s;
}


inline fn shake128_KK13N8_32(reg ptr u8[KK13N8] output, reg ptr u8[32] input) -> reg ptr u8[KK13N8]
{
 inline int i;
 inline int nblocks;
 inline int handled;
 inline int remainder;

 reg u8 t8;

 stack u8[SHAKE128_RATE] t;

 stack u64[25] s;

 nblocks = KK13N8 / SHAKE128_RATE;
 handled = nblocks * SHAKE128_RATE;
 remainder = KK13N8 - handled;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_128_32(s, input);

 output, s = keccak_squeezeblocks_128_KK13N8(output, s);


 t, s = keccak_squeezeblocks_128_128(t, s);

 for i = 0 to remainder {
  t8 = t[i];
  output[handled + i] = t8;
 }

 return output;
}







fn BS2POL(reg ptr u8[SABER_POLYBYTES] bytes, reg ptr u16[SABER_N] data) -> reg ptr u16[SABER_N]
{
 inline int j;

 reg u16 b1;
 reg u16 b2;
 reg u16 b3;

 for j = 0 to (SABER_N / 8) {

  b1 = (16u) bytes[13 * j];
  b2 = (16u) bytes[13 * j + 1];
  b1 &= 0xff;
  b2 &= 0x1f;
  b2 <<= 8;
  b1 |= b2;
  data[8 * j] = b1;


  b1 = (16u) bytes[13 * j + 1];
  b2 = (16u) bytes[13 * j + 2];
  b3 = (16u) bytes[13 * j + 3];
  b1 >>= 5;
  b1 &= 0x07;
  b2 &= 0xff;
  b2 <<= 3;
  b3 &= 0x03;
  b3 <<= 11;
  b2 |= b3;
  b1 |= b2;
  data[8 * j + 1] = b1;


  b1 = (16u) bytes[13 * j + 3];
  b2 = (16u) bytes[13 * j + 4];
  b1 >>= 2;
  b1 &= 0x3f;
  b2 &= 0x7f;
  b2 <<= 6;
  b1 |= b2;
  data[8 * j + 2] = b1;


  b1 = (16u) bytes[13 * j + 4];
  b2 = (16u) bytes[13 * j + 5];
  b3 = (16u) bytes[13 * j + 6];
  b1 >>= 7;
  b1 &= 0x01;
  b2 &= 0xff;
  b2 <<= 1;
  b3 &= 0x0f;
  b3 <<= 9;
  b2 |= b3;
  b1 |= b2;
  data[8 * j + 3] = b1;


  b1 = (16u) bytes[13 * j + 6];
  b2 = (16u) bytes[13 * j + 7];
  b3 = (16u) bytes[13 * j + 8];
  b1 >>= 4;
  b1 &= 0x0f;
  b2 &= 0xff;
  b2 <<= 4;
  b3 &= 0x01;
  b3 <<= 12;
  b2 |= b3;
  b1 |= b2;
  data[8 * j + 4] = b1;


  b1 = (16u) bytes[13 * j + 8];
  b2 = (16u) bytes[13 * j + 9];
  b1 >>= 1;
  b1 &= 0x7f;
  b2 &= 0x3f;
  b2 <<= 7;
  b1 |= b2;
  data[8 * j + 5] = b1;


  b1 = (16u) bytes[13 * j + 9];
  b2 = (16u) bytes[13 * j + 10];
  b3 = (16u) bytes[13 * j + 11];
  b1 >>= 6;
  b1 &= 0x03;
  b2 &= 0xff;
  b2 <<= 2;
  b3 &= 0x07;
  b3 <<= 10;
  b2 |= b3;
  b1 |= b2;
  data[8 * j + 6] = b1;


  b1 = (16u) bytes[13 * j + 11];
  b2 = (16u) bytes[13 * j + 12];
  b1 >>= 3;
  b1 &= 0x1f;
  b2 &= 0xff;
  b2 <<= 5;
  b1 |= b2;
  data[8 * j + 7] = b1;
 }

 return data;
}

fn GenMatrix(reg ptr u16[SABER_KKN] a, reg ptr u8[SABER_SEEDBYTES] seed) -> reg ptr u16[SABER_KKN]
{
 inline int i;
 inline int j;
 inline int k;

 reg u16 t16;

 stack u8[KK13N8] buf;

 stack u16[SABER_N] temp_ar;

 stack ptr u16[SABER_KKN] sa;

 sa = a;

 buf = shake128_KK13N8_32(buf, seed);

 a = sa;

 for i = 0 to SABER_K {
  for j = 0 to SABER_K {
   temp_ar = BS2POL(buf[(i * SABER_K + j) * 13 * SABER_N / 8:SABER_POLYBYTES], temp_ar);

   for k = 0 to SABER_N {
    t16 = temp_ar[k];
    t16 &= (SABER_Q - 1);
    a[i * SABER_KN + j * SABER_N + k] = t16;
   }
  }
 }

 return a;
}

























fn karatsuba_simple(reg ptr u16[N_SB] a_1, reg ptr u16[N_SB] b_1, reg ptr u16[N_SB_RES] result_final) -> reg ptr u16[N_SB_RES]
{
 inline int i;
 inline int j;
 inline int N;

 reg u16 acc1;
 reg u16 acc2;
 reg u16 acc3;
 reg u16 acc4;
 reg u16 acc5;
 reg u16 acc6;
 reg u16 acc7;
 reg u16 acc8;
 reg u16 acc9;
 reg u16 acc10;
 reg u16 t16;

 stack u16[64 / 2 - 1] d01;
 stack u16[64 / 2 - 1] d0123;
 stack u16[64 / 2 - 1] d23;
 stack u16[64 - 1] result_d01;

 N = 64;


 for i = 0 to (N / 2 - 1) {
  d01[i] = 0;
  d0123[i] = 0;
  d23[i] = 0;
 }


 for i = 0 to (N - 1) {
  result_d01[i] = 0;
 }


 for i = 0 to (2 * N - 1) {
  result_final[i] = 0;
 }


 for i = 0 to (N / 4) {
  acc1 = a_1[i];
  acc2 = a_1[i + N / 4];
  acc3 = a_1[i + 2 * N / 4];
  acc4 = a_1[i + 3 * N / 4];

  for j = 0 to (N / 4) {
   acc5 = b_1[j];
   acc6 = b_1[j + N / 4];


   t16 = acc1;
   t16 *= acc5;
   t16 += result_final[i + j];
   result_final[i + j] = t16;


   t16 = acc2;
   t16 *= acc6;
   t16 += result_final[i + j + 2 * N / 4];
   result_final[i + j + 2 * N / 4] = t16;

   acc7 = acc5 + acc6;
   acc8 = acc1 + acc2;


   t16 = acc7;
   t16 *= acc8;
   t16 += d01[i + j];
   d01[i + j] = t16;

   acc7 = b_1[j + 2 * N / 4];
   acc8 = b_1[j + 3 * N / 4];


   t16 = acc7;
   t16 *= acc3;
   t16 += result_final[i + j + 4 * N / 4];
   result_final[i + j + 4 * N / 4] = t16;


   t16 = acc8;
   t16 *= acc4;
   t16 += result_final[i + j + 6 * N / 4];
   result_final[i + j + 6 * N / 4] = t16;

   acc9 = acc3 + acc4;
   acc10 = acc7 + acc8;


   t16 = acc9;
   t16 *= acc10;
   t16 += d23[i + j];
   d23[i + j] = t16;

   acc5 = acc5 + acc7;
   acc7 = acc1 + acc3;


   t16 = acc5;
   t16 *= acc7;
   t16 += result_d01[i + j];
   result_d01[i + j] = t16;

   acc6 = acc6 + acc8;
   acc8 = acc2 + acc4;


   t16 = acc6;
   t16 *= acc8;
   t16 += result_d01[i + j + 2 * N / 4];
   result_d01[i + j + 2 * N / 4] = t16;

   acc5 = acc5 + acc6;
   acc7 = acc7 + acc8;


   t16 = acc5;
   t16 *= acc7;
   t16 += d0123[i + j];
   d0123[i + j] = t16;
  }
 }

 for i = 0 to N / 2 - 1 {

  t16 = d0123[i];
  t16 -= result_d01[i];
  t16 -= result_d01[i + 2 * N / 4];
  d0123[i] = t16;


  t16 = d01[i];
  t16 -= result_final[i];
  t16 -= result_final[i + 2 * N / 4];
  d01[i] = t16;


  t16 = d23[i];
  t16 -= result_final[i + 4 * N / 4];
  t16 -= result_final[i + 6 * N / 4];
  d23[i] = t16;
 }

 for i = 0 to N / 2 -1 {

  t16 = result_d01[i + N / 4];
  t16 += d0123[i];
  result_d01[i + N / 4] = t16;


  t16 = result_final[i + N / 4];
  t16 += d01[i];
  result_final[i + N / 4] = t16;


  t16 = result_final[i + 5 * N / 4];
  t16 += d23[i];
  result_final[i + 5 * N / 4] = t16;
 }

 for i = 0 to N - 1 {

  t16 = result_d01[i];
  t16 -= result_final[i];
  t16 -= result_final[i + N];
  result_d01[i] = t16;
 }

 for i = 0 to N - 1 {

  t16 = result_final[i + N / 2];
  t16 += result_d01[i];
  result_final[i + N / 2] = t16;
 }

 return result_final;
}

inline fn toom_cook_4way(reg ptr u16[SABER_N] a1, reg ptr u16[SABER_N] b1, reg ptr u16[512] result) -> reg ptr u16[512]
{
 inline int i;
 inline int j;

 inline int AB0;
 inline int AB1;
 inline int AB2;
 inline int AB3;

 reg u16 r0;
 reg u16 r1;
 reg u16 r2;
 reg u16 r3;
 reg u16 r4;
 reg u16 r5;
 reg u16 r6;
 reg u16 r7;

 reg u16 t1;
 reg u16 t2;

 reg u32 p1;
 reg u32 p2;

 stack u16[N_SB] aw1;
 stack u16[N_SB] aw2;
 stack u16[N_SB] aw3;
 stack u16[N_SB] aw4;
 stack u16[N_SB] aw5;
 stack u16[N_SB] aw6;
 stack u16[N_SB] aw7;

 stack u16[N_SB] bw1;
 stack u16[N_SB] bw2;
 stack u16[N_SB] bw3;
 stack u16[N_SB] bw4;
 stack u16[N_SB] bw5;
 stack u16[N_SB] bw6;
 stack u16[N_SB] bw7;

 stack u16[N_SB_RES] w1;
 stack u16[N_SB_RES] w2;
 stack u16[N_SB_RES] w3;
 stack u16[N_SB_RES] w4;
 stack u16[N_SB_RES] w5;
 stack u16[N_SB_RES] w6;
 stack u16[N_SB_RES] w7;

 stack ptr u16[512] sresult;

 AB0 = 0;
 AB1 = N_SB;
 AB2 = 2 * N_SB;
 AB3 = 3 * N_SB;

 for i = 0 to N_SB_RES {
  w1[i] = 0;
  w2[i] = 0;
  w3[i] = 0;
  w4[i] = 0;
  w5[i] = 0;
  w6[i] = 0;
  w7[i] = 0;
 }

 for j = 0 to N_SB {
  r0 = a1[AB0 + j];
  r1 = a1[AB1 + j];
  r2 = a1[AB2 + j];
  r3 = a1[AB3 + j];
  r4 = r0 + r2;
  r5 = r1 + r3;
  r6 = r4 + r5;
  r7 = r4;
  r7 -= r5;

  aw3[j] = r6;
  aw4[j] = r7;


  t1 = r0;
  t1 <<= 2;
  t1 += r2;
  t1 <<= 1;
  r4 = t1;


  t1 = r1;
  t1 <<= 2;
  t1 += r3;
  r5 = t1;

  r6 = r4 + r5;
  r7 = r4;
  r7 -= r5;

  aw5[j] = r6;
  aw6[j] = r7;


  t1 = r3;
  t1 <<= 3;
  t2 = r2;
  t2 <<= 2;
  t1 += t2;
  t2 = r1;
  t2 <<= 1;
  t1 += t2;
  t1 += r0;
  r4 = t1;

  aw2[j] = r4;
  aw7[j] = r0;
  aw1[j] = r3;
 }

 for j = 0 to N_SB {
  r0 = b1[AB0 + j];
  r1 = b1[AB1 + j];
  r2 = b1[AB2 + j];
  r3 = b1[AB3 + j];
  r4 = r0 + r2;
  r5 = r1 + r3;
  r6 = r4 + r5;
  r7 = r4;
  r7 -= r5;

  bw3[j] = r6;
  bw4[j] = r7;


  t1 = r0;
  t1 <<= 2;
  t1 += r2;
  t1 <<= 1;
  r4 = t1;


  t1 = r1;
  t1 <<= 2;
  t1 += r3;
  r5 = t1;

  r6 = r4 + r5;
  r7 = r4;
  r7 -= r5;

  bw5[j] = r6;
  bw6[j] = r7;


  t1 = r3;
  t1 <<= 3;
  t2 = r2;
  t2 <<= 2;
  t1 += t2;
  t2 = r1;
  t2 <<= 1;
  t1 += t2;
  t1 += r0;
  r4 = t1;

  bw2[j] = r4;
  bw7[j] = r0;
  bw1[j] = r3;
 }

 sresult = result;

 w1 = karatsuba_simple(aw1, bw1, w1);
 w2 = karatsuba_simple(aw2, bw2, w2);
 w3 = karatsuba_simple(aw3, bw3, w3);
 w4 = karatsuba_simple(aw4, bw4, w4);
 w5 = karatsuba_simple(aw5, bw5, w5);
 w6 = karatsuba_simple(aw6, bw6, w6);
 w7 = karatsuba_simple(aw7, bw7, w7);

 result = sresult;

 for i = 0 to N_SB_RES {
  r0 = w1[i];
  r1 = w2[i];
  r2 = w3[i];
  r3 = w4[i];
  r4 = w5[i];
  r5 = w6[i];
  r6 = w7[i];

  r1 += r4;
  r5 -= r4;


  p1 = (32u) r3;
  p2 = (32u) r2;
  p1 -= p2;
  p1 >>= 1;
  r3 = (16u) p1;

  r4 -= r0;


  t1 = r6;
  t1 <<= 6;
  r4 -= t1;


   r4 <<= 1;
   r4 += r5;

   r2 += r3;


   t1 = r2;
   t1 <<= 6;
   r1 -= t1;
   r1 -= r2;

   r2 -= r6;
   r2 -= r0;


   t1 = 45 * r2;
   r1 += t1;


   p1 = (32u) r2;
   p1 <<= 3;
   p2 = (32u) r4;
   p2 -= p1;
   p2 *= 43691;
   p2 >>= 3;
   r4 = (16u) p2;

   r5 += r1;


   p1 = (32u) r3;
   p1 <<= 4;
   p2 = (32u) r1;
   p2 += p1;
   p2 *= 36409;
   p2 >>= 1;
   r1 = (16u) p2;


   p1 = (32u) r3;
   p2 = (32u) r1;
   p1 += p2;
   p1 *= -1;
   r3 = (16u) p1;


   p1 = (32u) r1;
   p1 *= 30;
   p2 = (32u) r5;
   p1 -= p2;
   p1 *= 61167;
   p1 >>= 2;
   r5 = (16u) p1;

   r2 -= r4;
   r1 -= r5;

   result[i] += r6;
   result[i + 64] += r5;
   result[i + 128] += r4;
   result[i + 192] += r3;
   result[i + 256] += r2;
   result[i + 320] += r1;
   result[i + 384] += r0;
 }

 return result;
}

fn pol_mul_q(reg ptr u16[SABER_N] a, reg ptr u16[SABER_N] b, reg ptr u16[SABER_N] res) -> reg ptr u16[SABER_N]
{
 inline int i;

 reg u16 t16;

 stack u16[512] c;

 stack ptr u16[SABER_N] sres;

 for i = 0 to 512 {
  c[i] = 0;
 }

 sres = res;

 c = toom_cook_4way(a, b, c);

 res = sres;

 for i = SABER_N to 2 * SABER_N {

  t16 = c[i - SABER_N];
  t16 -= c[i];
  res[i - SABER_N] = t16;
  t16 = SABER_Q - 1;
  res[i - SABER_N] &= t16;
 }

 return res;
}

inline fn MatrixVectorMul(reg ptr u16[SABER_KKN] a, reg ptr u16[SABER_KN] skpv, reg ptr u16[SABER_KN] res, reg u16 transpose) -> reg ptr u16[SABER_KN]
{
 inline int i;
 inline int j;
 inline int k;

 reg u16 t;

 stack u16[SABER_N] acc;

 stack ptr u16[SABER_KKN] sa;
 stack ptr u16[SABER_KN] sskpv;
 stack ptr u16[SABER_KN] sres;

 if (transpose == 1) {
  for i = 0 to SABER_K {
   for j = 0 to SABER_K {
    sa = a;
    sskpv = skpv;
    sres = res;

    acc = pol_mul_q(a[j * SABER_KN + i * SABER_N:SABER_N], skpv[j * SABER_N:SABER_N], acc);

    a = sa;
    skpv = sskpv;
    res = sres;

    for k = 0 to SABER_N {
     t = acc[k];

     res[i * SABER_N + k] += t;
     res[i * SABER_N + k] &= (SABER_Q - 1);

     acc[k] = 0;
    }
   }
  }
 } else {
  for i = 0 to SABER_K {
   for j = 0 to SABER_K {
    sa = a;
    sskpv = skpv;
    sres = res;

    acc = pol_mul_q(a[i * SABER_KN + j * SABER_N:SABER_N], skpv[j * SABER_N:SABER_N], acc);

    a = sa;
    skpv = sskpv;
    res = sres;

    for k = 0 to SABER_N {
     t = acc[k];

     res[i * SABER_N + k] += t;
     res[i * SABER_N + k] &= (SABER_Q - 1);

     acc[k] = 0;
    }
   }
  }
 }

 return res;
}













inline fn keccak_squeezeblocks_128_MUNK8(reg ptr u8[MUNK8] h, reg ptr u64[25] s) -> reg ptr u8[MUNK8], reg ptr u64[25]
{
 inline int i;
 inline int j;
 inline int iterations;

 reg u64 u;

 iterations = MUNK8 / SHAKE128_RATE;

 for j = 0 to iterations {
  s = KeccakF1600_StatePermute(s);

  for i = 0 to (SHAKE128_RATE / 8) {
   u = s[i];
   h[j * SHAKE128_RATE + 8 * i:8] = store64(h[j * SHAKE128_RATE + 8 * i:8], u);
  }
 }

 return h, s;
}


inline fn shake128_MUNK8_32(reg ptr u8[MUNK8] output, reg ptr u8[32] input) -> reg ptr u8[MUNK8]
{
 inline int i;
 inline int nblocks;
 inline int handled;
 inline int remainder;

 reg u8 t8;

 stack u8[SHAKE128_RATE] t;

 stack u64[25] s;

 nblocks = MUNK8 / SHAKE128_RATE;
 handled = nblocks * SHAKE128_RATE;
 remainder = MUNK8 - handled;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_128_32(s, input);

 output, s = keccak_squeezeblocks_128_MUNK8(output, s);


 t, s = keccak_squeezeblocks_128_128(t, s);

 for i = 0 to remainder {
  t8 = t[i];
  output[handled + i] = t8;
 }

 return output;
}







fn cbd(reg ptr u16[SABER_N] r, reg ptr u8[SABER_N] buf) -> reg ptr u16[SABER_N]
{
 inline int i;

 reg u8 t8;

 reg u16 t16;

 reg u32 t32;
 reg u32 d;
 reg u32 tt;

 stack u32[4] a;
 stack u32[4] b;

 for i = 0 to (SABER_N / 4) {

        t32 = (32u) buf[4 * i];

        tt = (32u) buf[4 * i + 1];
        tt <<= 8;
        t32 |= tt;

        tt = (32u) buf[4 * i + 2];
        tt <<= 16;
        t32 |= tt;

        tt = (32u) buf[4 * i + 3];
        tt <<= 24;
        t32 |= tt;


  tt = t32;
        tt &= 0x11111111;
  d = tt;

  tt = t32;
  tt >>= 1;
  tt &= 0x11111111;
  d += tt;

  tt = t32;
  tt >>= 2;
  tt &= 0x11111111;
  d += tt;

  tt = t32;
  tt >>= 3;
  tt &= 0x11111111;
  d += tt;


     t32 = d;
     t32 &= 0xf;
  a[0] = t32;


     t32 = d;
     t32 >>= 4;
     t32 & = 0xf;
     b[0] = t32;


     t32 = d;
     t32 >>= 8;
     t32 &= 0xf;
     a[1] = t32;


     t32 = d;
     t32 >>= 12;
     t32 &= 0xf;
     b[1] = t32;


     t32 = d;
     t32 >>= 16;
     t32 &= 0xf;
     a[2] = t32;


  t32 = d;
     t32 >>= 20;
     t32 &= 0xf;
     b[2] = t32;


     t32 = d;
     t32 >>= 24;
     t32 &= 0xf;
     a[3] = t32;


     t32 = d;
     t32 >>= 28;
     b[3] = t32;


     t32 = a[0];
     t32 -= b[0];
     t16 = (16u) t32;
     t16 &= (SABER_Q - 1);
     r[4 * i] = t16;


     t32 = a[1];
     t32 -= b[1];
     t16 = (16u) t32;
        t16 &= (SABER_Q - 1);
     r[4 * i + 1] = t16;


     t32 = a[2];
     t32 -= b[2];
     t16 = (16u) t32;
     t16 &= (SABER_Q - 1);
     r[4 * i + 2] = t16;


     t32 = a[3];
     t32 -= b[3];
     t16 = (16u) t32;
     t16 &= (SABER_Q - 1);
     r[4 * i + 3] = t16;
 }

 return r;
}

fn GenSecret(reg ptr u16[SABER_KN] r, reg ptr u8[SABER_COINBYTES] seed) -> reg ptr u16[SABER_KN]
{
 inline int i;

 stack u8[MUNK8] buf;

 stack ptr u16[SABER_KN] sr;

 sr = r;

 buf = shake128_MUNK8_32(buf, seed);

 r = sr;

 for i = 0 to SABER_K {
  r[i * SABER_N:SABER_N] = cbd(r[i * SABER_N:SABER_N], buf[i * SABER_MU * SABER_N / 8:SABER_N]);
 }

 return r;
}







inline fn POLVECq2BS(reg ptr u8[SABER_POLYVECBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u8[SABER_POLYVECBYTES]
{
 inline int i;
 inline int j;

 reg u16 d1;
 reg u16 d2;

 for i = 0 to SABER_K {
  for j = 0 to (SABER_N / 8) {

   d1 = data[i * SABER_N + 8 * j];
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j];
   d2 = data[i * SABER_N + 8 * j + 1];
   d1 >>= 8;
   d1 &= 0x1f;
   d2 &= 0x07;
   d2 <<= 5;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 1] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 1];
   d1 >>= 3;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 2] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 1];
   d2 = data[i * SABER_N + 8 * j + 2];
   d1 >>= 11;
   d1 &= 0x03;
   d2 &= 0x3f;
   d2 <<= 2;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 3] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 2];
   d2 = data[i * SABER_N + 8 * j + 3];
   d1 >>= 6;
   d1 &= 0x7f;
   d2 &= 0x01;
   d2 <<= 7;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 4] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 3];
   d1 >>= 1;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 5] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 3];
   d2 = data[i * SABER_N + 8 * j + 4];
   d1 >>= 9;
   d1 &= 0x0f;
   d2 &= 0x0f;
   d2 <<= 4;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 6] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 4];
   d1 >>= 4;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 7] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 4];
   d2 = data[i * SABER_N + 8 * j + 5];
   d1 >>= 12;
   d1 &= 0x01;
   d2 &= 0x7f;
   d2 <<= 1;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 8] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 5];
   d2 = data[i * SABER_N + 8 * j + 6];
   d1 >>= 7;
   d1 &= 0x3f;
   d2 &= 0x03;
   d2 <<= 6;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 9] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 6];
   d1 >>= 2;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 10] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 6];
   d2 = data[i * SABER_N + 8 * j + 7];
   d1 >>= 10;
   d1 &= 0x07;
   d2 &= 0x1f;
   d2 <<= 3;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 11] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 7];
   d1 >>= 5;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 12] = (8u) d1;
  }
 }

 return bytes;
}







fn POLVECp2BS(reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES]
{
 inline int i;
 inline int j;

 reg u16 d1;
 reg u16 d2;

 for i = 0 to SABER_K {
  for j = 0 to (SABER_N / 4) {

   d1 = data[i * SABER_N + 4 * j];
   d1 &= 0xff;
   bytes[i * (SABER_N * 10) / 8 + 5 * j] = (8u) d1;


   d1 = data[i * SABER_N + 4 * j];
   d2 = data[i * SABER_N + 4 * j + 1];
   d1 >>= 8;
   d1 &= 0x03;
   d2 &= 0x3f;
   d2 <<= 2;
   d1 |= d2;
   bytes[i * (SABER_N * 10) / 8 + 5 * j + 1] = (8u) d1;


   d1 = data[i * SABER_N + 4 * j + 1];
   d2 = data[i * SABER_N + 4 * j + 2];
   d1 >>= 6;
   d1 &= 0x0f;
   d2 &= 0x0f;
   d2 <<= 4;
   d1 |= d2;
   bytes[i * (SABER_N * 10) / 8 + 5 * j + 2] = (8u) d1;


   d1 = data[i * SABER_N + 4 * j + 2];
   d2 = data[i * SABER_N + 4 * j + 3];
   d1 >>= 4;
   d1 &= 0x3f;
   d2 &= 0x03;
   d2 <<= 6;
   d1 |= d2;
   bytes[i * (SABER_N * 10) / 8 + 5 * j + 3] = (8u) d1;


   d1 = data[i * SABER_N + 4 * j + 3];
   d1 >>= 2;
   d1 &= 0xff;
   bytes[i * (SABER_N * 10) / 8 + 5 * j + 4] = (8u) d1;
  }
 }

 return bytes;
}

inline fn indcpa_kem_keypair_randominc(stack u8[SABER_INDCPA_PUBLICKEYBYTES] pk, stack u8[SABER_INDCPA_SECRETKEYBYTES] sk, stack u8[SABER_SEEDBYTES] seed, stack u8[SABER_COINBYTES] noiseseed) -> stack u8[SABER_INDCPA_PUBLICKEYBYTES], stack u8[SABER_INDCPA_SECRETKEYBYTES]
{
 inline int i;

 reg u8 t8;

 stack u16[SABER_KKN] a;
 stack u16[SABER_KN] skpv;
 stack u16[SABER_KN] res;


 seed = shake128_32_32(seed, seed);

 a = GenMatrix(a, seed);

 skpv = GenSecret(skpv, noiseseed);

 for i = 0 to SABER_KN {
  res[i] = 0;
 }

 res = MatrixVectorMul(a, skpv, res, 1);

 for i = 0 to SABER_KN {
  res[i] += h1;
  res[i] &= (SABER_Q - 1);
  res[i] >>= (SABER_EQ - SABER_EP);
 }

 sk = POLVECq2BS(sk, skpv);

 pk[0:SABER_POLYVECCOMPRESSEDBYTES] = POLVECp2BS(pk[0:SABER_POLYVECCOMPRESSEDBYTES], res);

 for i = 0 to SABER_SEEDBYTES {
  t8 = seed[i];
  pk[SABER_POLYVECCOMPRESSEDBYTES + i] = t8;
 }

 return pk, sk;
}






inline fn keccak_absorb_256_PUBKEYBYTES(reg ptr u64[25] s, reg ptr u8[SABER_INDCPA_PUBLICKEYBYTES] m) -> reg ptr u64[25]
{
 inline int i;
 inline int j;
 inline int iterations;
 inline int handled;
 inline int remainder;

 reg u8 t8;

 reg u64 t64;

 stack u8[200] t;

 iterations = SABER_INDCPA_PUBLICKEYBYTES / SHA3_256_RATE;
 handled = iterations * SHA3_256_RATE;
 remainder = SABER_INDCPA_PUBLICKEYBYTES - handled;

 for j = 0 to iterations {
  for i = 0 to (SHA3_256_RATE / 8) {
   t64 = load64(m[j * SHA3_256_RATE + 8 * i:8]);
   s[i] ^= t64;
  }

  s = KeccakF1600_StatePermute(s);
 }

 for i = 0 to SHA3_256_RATE {
  t[i] = 0;
 }

 for i = 0 to remainder {
  t8 = m[handled + i];
  t[i] = t8;
 }

 t[remainder] = 0x06;
 t[SHA3_256_RATE - 1] |= 128;

 for i = 0 to (SHA3_256_RATE / 8) {
  t64 = load64(t[8 * i:8]);
  s[i] ^= t64;
 }

 return s;
}
inline fn keccak_squeezeblocks_256_256(reg ptr u8[SHA3_256_RATE] h, reg ptr u64[25] s) -> reg ptr u8[SHA3_256_RATE], reg ptr u64[25]
{
 inline int i;

 reg u64 u;



 s = KeccakF1600_StatePermute(s);

 for i = 0 to (SHA3_256_RATE / 8) {
  u = s[i];
  h[8 * i:8] = store64(h[8 * i:8], u);
 }

 return h, s;
}

fn sha3_256_PUBKEYBYTES(reg ptr u8[32] output, reg ptr u8[SABER_INDCPA_PUBLICKEYBYTES] input) -> reg ptr u8[32]
{
 inline int i;

 reg u8 t8;

 stack u8[SHA3_256_RATE] t;

 stack u64[25] s;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_256_PUBKEYBYTES(s, input);

 t, s = keccak_squeezeblocks_256_256(t, s);

 for i = 0 to 32 {
  t8 = t[i];
  output[i] = t8;
 }

 return output;
}

inline fn crypto_kem_keypair_randominc(stack u8[SABER_PUBLICKEYBYTES] pk, stack u8[SABER_SECRETKEYBYTES] sk, stack u8[SABER_KEYBYTES] random_bytes_crypto, stack u8[SABER_SEEDBYTES] indcpa_seed, stack u8[SABER_COINBYTES] indcpa_noiseseed) -> stack u8[SABER_PUBLICKEYBYTES], stack u8[SABER_SECRETKEYBYTES]
{
 inline int i;

 reg u8 t8;

 pk, sk[0:SABER_INDCPA_SECRETKEYBYTES] = indcpa_kem_keypair_randominc(pk, sk[0:SABER_INDCPA_SECRETKEYBYTES], indcpa_seed, indcpa_noiseseed);

 for i = 0 to SABER_INDCPA_PUBLICKEYBYTES {
  t8 = pk[i];
  sk[i + SABER_INDCPA_SECRETKEYBYTES] = t8;
 }

 sk[SABER_SECRETKEYBYTES - 64:SABER_HASHBYTES] = sha3_256_PUBKEYBYTES(sk[SABER_SECRETKEYBYTES - 64:SABER_HASHBYTES], pk);

 for i = 0 to SABER_KEYBYTES {
  t8 = random_bytes_crypto[i];
  sk[SABER_SECRETKEYBYTES - SABER_KEYBYTES + i] = t8;
 }

 return pk, sk;
}












inline fn keccak_absorb_256_32(reg ptr u64[25] s, reg ptr u8[32] m) -> reg ptr u64[25]
{
 inline int i;

 reg u8 t8;

 reg u64 t64;

 stack u8[200] t;



 for i = 0 to SHA3_256_RATE {
  t[i] = 0;
 }

 for i = 0 to 32 {
  t8 = m[i];
  t[i] = t8;
 }

 t[32] = 0x06;
 t[SHA3_256_RATE - 1] |= 128;

 for i = 0 to (SHA3_256_RATE / 8) {
  t64 = load64(t[8 * i:8]);
  s[i] ^= t64;
 }

 return s;
}


inline fn sha3_256_32(reg ptr u8[32] output, reg ptr u8[32] input) -> reg ptr u8[32]
{
 inline int i;

 reg u8 t8;

 stack u8[SHA3_256_RATE] t;

 stack u64[25] s;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_256_32(s, input);

 t, s = keccak_squeezeblocks_256_256(t, s);

 for i = 0 to 32 {
  t8 = t[i];
  output[i] = t8;
 }

 return output;
}






inline fn keccak_absorb_256_64(reg ptr u64[25] s, reg ptr u8[64] m) -> reg ptr u64[25]
{
 inline int i;

 reg u8 t8;

 reg u64 t64;

 stack u8[200] t;



 for i = 0 to SHA3_256_RATE {
  t[i] = 0;
 }

 for i = 0 to 64 {
  t8 = m[i];
  t[i] = t8;
 }

 t[64] = 0x06;
 t[SHA3_256_RATE - 1] |= 128;

 for i = 0 to (SHA3_256_RATE / 8) {
  t64 = load64(t[8 * i:8]);
  s[i] ^= t64;
 }

 return s;
}


fn sha3_256_64(reg ptr u8[32] output, reg ptr u8[64] input) -> reg ptr u8[32]
{
 inline int i;

 reg u8 t8;

 stack u8[SHA3_256_RATE] t;

 stack u64[25] s;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_256_64(s, input);

 t, s = keccak_squeezeblocks_256_256(t, s);

 for i = 0 to 32 {
  t8 = t[i];
  output[i] = t8;
 }

 return output;
}







inline fn keccak_absorb_256_CCADEC(reg ptr u64[25] s, reg ptr u8[SABER_BYTES_CCA_DEC] m) -> reg ptr u64[25]
{
 inline int i;
 inline int j;
 inline int iterations;
 inline int handled;
 inline int remainder;

 reg u8 t8;

 reg u64 t64;

 stack u8[200] t;

 iterations = SABER_BYTES_CCA_DEC / SHA3_256_RATE;
 handled = iterations * SHA3_256_RATE;
 remainder = SABER_BYTES_CCA_DEC - handled;

 for j = 0 to iterations {
  for i = 0 to (SHA3_256_RATE / 8) {
   t64 = load64(m[j * SHA3_256_RATE + 8 * i:8]);
   s[i] ^= t64;
  }

  s = KeccakF1600_StatePermute(s);
 }

 for i = 0 to SHA3_256_RATE {
  t[i] = 0;
 }

 for i = 0 to remainder {
  t8 = m[handled + i];
  t[i] = t8;
 }

 t[remainder] = 0x06;
 t[SHA3_256_RATE - 1] |= 128;

 for i = 0 to (SHA3_256_RATE / 8) {
  t64 = load64(t[8 * i:8]);
  s[i] ^= t64;
 }

 return s;
}


fn sha3_256_CCADEC(reg ptr u8[32] output, reg ptr u8[SABER_BYTES_CCA_DEC] input) -> reg ptr u8[32]
{
 inline int i;

 reg u8 t8;

 stack u8[SHA3_256_RATE] t;

 stack u64[25] s;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_256_CCADEC(s, input);

 t, s = keccak_squeezeblocks_256_256(t, s);

 for i = 0 to 32 {
  t8 = t[i];
  output[i] = t8;
 }

 return output;
}






inline fn keccak_absorb_512_64(reg ptr u64[25] s, reg ptr u8[64] m) -> reg ptr u64[25]
{
 inline int i;

 reg u8 t8;

 reg u64 t64;
 reg u64 tt;

 stack u8[200] t;



 for i = 0 to SHA3_512_RATE {
  t[i] = 0;
 }

 for i = 0 to 64 {
  t8 = m[i];
  t[i] = t8;
 }

 t[64] = 0x06;
 t[SHA3_512_RATE - 1] |= 128;

 for i = 0 to (SHA3_512_RATE / 8) {
  t64 = load64(t[8 * i:8]);
  s[i] ^= t64;
 }

 return s;
}
inline fn keccak_squeezeblocks_512_512(reg ptr u8[SHA3_512_RATE] h, reg ptr u64[25] s) -> reg ptr u8[SHA3_512_RATE], reg ptr u64[25]
{
 inline int i;

 reg u64 u;



 s = KeccakF1600_StatePermute(s);

 for i = 0 to (SHA3_512_RATE / 8) {
  u = s[i];
  h[8 * i:8] = store64(h[8 * i:8], u);
 }


 return h, s;
}

inline fn sha3_512_64(reg ptr u8[64] output, reg ptr u8[64] input) -> reg ptr u8[64]
{
 inline int i;

 reg u8 t8;

 stack u8[SHA3_512_RATE] t;

 stack u64[25] s;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_512_64(s, input);

 t, s = keccak_squeezeblocks_512_512(t, s);

 for i = 0 to 64 {
  t8 = t[i];
  output[i] = t8;
 }

 return output;
}







fn BS2POLVECp(reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u16[SABER_KN]
{
 inline int i;
 inline int j;

 reg u16 b1;
 reg u16 b2;

 for i = 0 to SABER_K {
  for j = 0 to (SABER_N / 4) {

   b1 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j];
   b2 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 1];
   b1 &= 0xff;
   b2 &= 0x03;
   b2 <<= 8;
   b1 |= b2;
   data[i * SABER_N + 4 * j] = b1;


   b1 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 1];
   b2 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 2];
   b1 >>= 2;
   b1 &= 0x3f;
   b2 &= 0x0f;
   b2 <<= 6;
   b1 |= b2;
   data[i * SABER_N + 4 * j + 1] = b1;


   b1 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 2];
   b2 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 3];
   b1 >>= 4;
   b1 &= 0x0f;
   b2 &= 0x3f;
   b2 <<= 4;
   b1 |= b2;
   data[i * SABER_N + 4 * j + 2] = b1;


   b1 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 3];
   b2 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 4];
   b1 >>= 6;
   b1 &= 0x03;
   b2 &= 0xff;
   b2 <<= 2;
   b1 |= b2;
   data[i * SABER_N + 4 * j + 3] = b1;
  }
 }

 return data;
}







inline fn SABER_pack_4bit(reg ptr u8[SABER_SCALEBYTES_KEM] bytes, reg ptr u16[SABER_N] data) -> reg ptr u8[SABER_SCALEBYTES_KEM]
{
 inline int j;

 reg u16 d1;
 reg u16 d2;

 for j = 0 to (SABER_N / 2) {

  d1 = data[2 * j];
  d1 &= 0x0f;
  d2 = data[2* j + 1];
  d2 &= 0x0f;
  d2 <<= 4;
  d1 |= d2;
  bytes[j] = (8u) d1;
 }

 return bytes;
}







fn pol_mul_p(reg ptr u16[SABER_N] a, reg ptr u16[SABER_N] b, reg ptr u16[SABER_N] res) -> reg ptr u16[SABER_N]
{
 inline int i;

 reg u16 t16;

 stack u16[512] c;

 stack ptr u16[SABER_N] sres;

 for i = 0 to 512 {
  c[i] = 0;
 }

 sres = res;

 c = toom_cook_4way(a, b, c);

 res = sres;

 for i = SABER_N to 2 * SABER_N {

  t16 = c[i - SABER_N];
  t16 -= c[i];
  res[i - SABER_N] = t16;
  t16 = SABER_P - 1;
  res[i - SABER_N] &= t16;
 }

 return res;
}

inline fn InnerProd(reg ptr u16[SABER_KN] pkcl, reg ptr u16[SABER_KN] skpv, reg ptr u16[SABER_N] res) -> reg ptr u16[SABER_N]
{
 inline int j;
 inline int k;

 reg u16 t;

 stack u16[SABER_N] acc;

 stack ptr u16[SABER_KN] spkcl;
 stack ptr u16[SABER_KN] sskpv;
 stack ptr u16[SABER_N] sres;

 for j = 0 to SABER_K {
  spkcl = pkcl;
  sskpv = skpv;
  sres = res;

  acc = pol_mul_p(pkcl[j * SABER_N:SABER_N], skpv[j * SABER_N:SABER_N], acc);

  pkcl = spkcl;
  skpv = sskpv;
  res = sres;

  for k = 0 to SABER_N {
   t = acc[k];

   res[k] += t;
   res[k] &= (SABER_P - 1);

   acc[k] = 0;
  }
 }

 return res;
}


inline fn indcpa_kem_enc(stack u8[SABER_KEYBYTES] message_received, stack u8[32] noiseseed, stack u8[SABER_INDCPA_PUBLICKEYBYTES] pk, stack u8[SABER_BYTES_CCA_DEC] ciphertext) -> stack u8[SABER_BYTES_CCA_DEC]
{
 inline int i;
 inline int j;
 inline int k;

 reg u8 t8;

 reg u16 t16;

 stack u8[SABER_SEEDBYTES] seed;
 stack u8[SABER_SCALEBYTES_KEM] msk_c;

 stack u16[SABER_KKN] a;
 stack u16[SABER_KN] pkcl;
 stack u16[SABER_KN] skpv1;
 stack u16[SABER_KEYBYTES * 8] message;
 stack u16[SABER_KN] res;
 stack u16[SABER_N] vprime;


 for i = 0 to SABER_SEEDBYTES {
  t8 = pk[SABER_POLYVECCOMPRESSEDBYTES + i];
  seed[i] = t8;
 }

 a = GenMatrix(a, seed);

 skpv1 = GenSecret(skpv1, noiseseed);

 for i = 0 to SABER_KN {
  res[i] = 0;
 }

 res = MatrixVectorMul(a, skpv1, res, 0);

 for i = 0 to SABER_KN {
  res[i] += h1;
  res[i] &= (SABER_Q - 1);
  res[i] >>= (SABER_EQ - SABER_EP);
 }

 ciphertext[0:SABER_POLYVECCOMPRESSEDBYTES] = POLVECp2BS(ciphertext[0:SABER_POLYVECCOMPRESSEDBYTES], res);

 pkcl = BS2POLVECp(pk[0:SABER_POLYVECCOMPRESSEDBYTES], pkcl);

 for i = 0 to SABER_N {
  vprime[i] = 0;
 }

 for i = 0 to SABER_KN {
  skpv1[i] &= (SABER_P - 1);
 }

 vprime = InnerProd(pkcl, skpv1, vprime);

 for i = 0 to SABER_N {
  vprime[i] += h1;
 }

 for j = 0 to SABER_KEYBYTES {
  for i = 0 to 8 {

   t16 = (16u) message_received[j];
   t16 >>= i;
   t16 &= 0x01;
   message[8 * j + i] = t16;
  }
 }

 for i = 0 to SABER_N {

  message[i] <<= (SABER_EP - 1);
 }

 for k = 0 to SABER_N {

  t16 = vprime[k];
  t16 -= message[k];
  t16 &= (SABER_P - 1);
  t16 >>= (SABER_EP-SABER_ET);
  vprime[k] = t16;
 }

 msk_c = SABER_pack_4bit(msk_c, vprime);

 for j = 0 to SABER_SCALEBYTES_KEM {
  t8 = msk_c[j];
  ciphertext[SABER_POLYVECCOMPRESSEDBYTES + j] = t8;
 }

 return ciphertext;
}

inline fn crypto_kem_enc_randominc(stack u8[SABER_BYTES_CCA_DEC] c, stack u8[SABER_HASHBYTES] k, stack u8[SABER_INDCPA_PUBLICKEYBYTES] pk, stack u8[32] random_bytes_crypto) -> stack u8[SABER_BYTES_CCA_DEC], stack u8[SABER_HASHBYTES]
{
 inline int i;

 reg u8 t8;

 stack u8[64] kr;
 stack u8[64] buf;

 for i = 0 to 32 {
  t8 = random_bytes_crypto[i];
  buf[i] = t8;
 }

 buf[0:32] = sha3_256_32(buf[0:32], buf[0:32]);

 buf[32:32] = sha3_256_PUBKEYBYTES(buf[32:32], pk);

 kr = sha3_512_64(kr, buf);

 c = indcpa_kem_enc(buf[0:32], kr[32:32], pk, c);

 kr[32:32] = sha3_256_CCADEC(kr[32:32], c);

 k = sha3_256_64(k, kr);

 return c, k;
}




















inline fn BS2POLVECq(reg ptr u8[SABER_POLYVECBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u16[SABER_KN]
{
 inline int i;
 inline int j;

 reg u16 b1;
 reg u16 b2;
 reg u16 b3;

 for i = 0 to SABER_K {
  for j = 0 to (SABER_N / 8) {

   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j];
   b1 &= 0xff;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 1];
   b2 &= 0x1f;
   b2 <<= 8;
   b1 |= b2;
   data[i * SABER_N + 8 * j] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 1];
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 2];
   b3 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 3];
   b1 >>= 5;
   b1 &= 0x07;
   b2 &= 0xff;
   b2 <<= 3;
   b3 &= 0x03;
   b3 <<= 11;
   b2 |= b3;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 1] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 3];
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 4];
   b1 >>= 2;
   b1 &= 0x3f;
   b2 &= 0x7f;
   b2 <<= 6;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 2] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 4];
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 5];
   b3 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 6];
   b1 >>= 7;
   b1 &= 0x01;
   b2 &= 0xff;
   b2 <<= 1;
   b3 &= 0x0f;
   b3 <<= 9;
   b2 |= b3;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 3] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 6];
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 7];
   b3 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 8];
   b1 >>= 4;
   b1 &= 0x0f;
   b2 &= 0xff;
   b2 <<= 4;
   b3 &= 0x01;
   b3 <<= 12;
   b2 |= b3;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 4] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 8];
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 9];
   b1 >>= 1;
   b1 &= 0x7f;
   b2 &= 0x3f;
   b2 <<= 7;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 5] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 9];
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 10];
   b3 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 11];
   b1 >>= 6;
   b1 &= 0x03;
   b2 &= 0xff;
   b2 <<= 2;
   b3 &= 0x07;
   b3 <<= 10;
   b2 |= b3;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 6] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 11];
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 12];
   b1 >>= 3;
   b1 &= 0x1f;
   b2 &= 0xff;
   b2 <<= 5;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 7] = b1;
  }
 }

 return data;
}







inline fn SABER_un_pack4bit(reg ptr u8[SABER_SCALEBYTES_KEM] bytes, reg ptr u16[SABER_N] ar) -> reg ptr u16[SABER_N]
{
 inline int j;

 reg u16 b1;

 for j = 0 to (SABER_N / 2) {

  b1 = (16u) bytes[j];
  b1 &= 0x0f;
  ar[2 * j] = b1;


  b1 = (16u) bytes[j];
  b1 >>= 4;
  b1 &= 0x0f;
  ar[2 * j + 1] = b1;
 }

 return ar;
}








inline fn POL2MSG(stack u16[SABER_N] message_dec_unpacked, stack u8[SABER_KEYBYTES] message_dec) -> stack u8[SABER_KEYBYTES]
{
 inline int i;
 inline int j;

 reg u8 t8;

 reg u16 t16;

 for j = 0 to SABER_KEYBYTES {
  message_dec[j] = 0;

  for i = 0 to 8 {
   t16 = message_dec_unpacked[j * 8 + i];
   t16 <<= i;
   t8 = (8u) t16;
   message_dec[j] |= t8;
  }
 }

 return message_dec;
}

inline fn indcpa_kem_dec(stack u8[SABER_INDCPA_SECRETKEYBYTES] sk, stack u8[SABER_BYTES_CCA_DEC] ciphertext, stack u8[SABER_KEYBYTES] message_dec) -> stack u8[SABER_KEYBYTES]
{
 inline int i;

 reg u8 t8;

 reg u16 t16;

 stack u8[SABER_SCALEBYTES_KEM] scale_ar;

 stack u16[SABER_KN] sksv;
 stack u16[SABER_KN] pksv;
 stack u16[SABER_N] v;
 stack u16[SABER_N] op;

 sksv = BS2POLVECq(sk, sksv);

 pksv = BS2POLVECp(ciphertext[0:SABER_POLYVECCOMPRESSEDBYTES], pksv);

 for i = 0 to SABER_N {
  v[i] = 0;
 }

 for i = 0 to SABER_KN {
  sksv[i] &= (SABER_P - 1);
 }

 v = InnerProd(pksv, sksv, v);

 for i = 0 to SABER_SCALEBYTES_KEM {
  t8 = ciphertext[SABER_POLYVECCOMPRESSEDBYTES + i];
  scale_ar[i] = t8;
 }

 op = SABER_un_pack4bit(scale_ar, op);

 for i = 0 to SABER_N {

  t16 = op[i];
  t16 <<= (SABER_EP-SABER_ET);
  v[i] += h2;
  v[i] -= t16;
  v[i] &= (SABER_P - 1);
  v[i] >>= (SABER_EP - 1);
 }

 message_dec = POL2MSG(v, message_dec);

 return message_dec;
}











inline fn cmov(stack u8[SABER_KEYBYTES] r, stack u8[SABER_KEYBYTES] x, reg u8 b) -> stack u8[SABER_KEYBYTES]
{
 inline int i;

 reg u8 t8;

 reg u64 t64;

 _, _, _, _, _, b = #NEG_8(b);

 for i = 0 to SABER_KEYBYTES {

  t8 = x[i];
  t8 ^= r[i];
  t8 &= b;
  r[i] ^= t8;
 }

 return r;
}







inline fn verify(stack u8[SABER_BYTES_CCA_DEC] a, stack u8[SABER_BYTES_CCA_DEC] b) -> reg u64
{
 inline int i;

 reg u8 t8;
 reg u8 tr;

 reg u64 r;

 tr = 0;
 for i = 0 to SABER_BYTES_CCA_DEC {

  t8 = a[i];
  t8 ^= b[i];
  tr |= t8;
 }


 r = (64u) tr;
 r *= -1;
 r >>= 63;

 return r;
}

inline fn crypto_kem_dec(stack u8[SABER_HASHBYTES] k, stack u8[SABER_BYTES_CCA_DEC] c, stack u8[SABER_SECRETKEYBYTES] sk) -> stack u8[SABER_HASHBYTES]
{
 inline int i;

 reg u8 t8;

 reg u64 fail;

 stack u8[SABER_BYTES_CCA_DEC] cmp;
 stack u8[64] buf;
 stack u8[64] kr;

 buf[0:SABER_KEYBYTES] = indcpa_kem_dec(sk[0:SABER_INDCPA_SECRETKEYBYTES], c, buf[0:SABER_KEYBYTES]);

 for i = 0 to 32 {
  t8 = sk[SABER_SECRETKEYBYTES - 64 + i];
  buf[32 + i] = t8;
 }

 kr = sha3_512_64(kr, buf);

 cmp = indcpa_kem_enc(buf[0:SABER_KEYBYTES], kr[32:32], sk[SABER_INDCPA_SECRETKEYBYTES:SABER_INDCPA_PUBLICKEYBYTES], cmp);

 fail = verify(c, cmp);

 kr[32:32] = sha3_256_CCADEC(kr[32:32], c);

 t8 = (8u) fail;

 kr[0:SABER_KEYBYTES] = cmov(kr[0:SABER_KEYBYTES], sk[(SABER_SECRETKEYBYTES - SABER_KEYBYTES):SABER_KEYBYTES], t8);

 k = sha3_256_64(k, kr);

 return k;
}


export fn crypto_kem_keypair_randominc_jazz(reg u64 pkp, reg u64 skp, reg u64 random_bytes_cryptop, reg u64 indcpa_seedp, reg u64 indcpa_noiseseedp)
{
 inline int i;

 reg u8 t8;

 stack u8[SABER_PUBLICKEYBYTES] pk;
 stack u8[SABER_SECRETKEYBYTES] sk;
 stack u8[SABER_KEYBYTES] random_bytes_crypto;
 stack u8[SABER_SEEDBYTES] indcpa_seed;
 stack u8[SABER_COINBYTES] indcpa_noiseseed;

 stack u64 spkp;
 stack u64 sskp;

 for i = 0 to SABER_KEYBYTES {
  t8 = (u8) [random_bytes_cryptop + i];
  random_bytes_crypto[i] = t8;
 }

 for i = 0 to SABER_SEEDBYTES {
  t8 = (u8) [indcpa_seedp + i];
  indcpa_seed[i] = t8;
 }

 for i = 0 to SABER_COINBYTES {
  t8 = (u8) [indcpa_noiseseedp + i];
  indcpa_noiseseed[i] = t8;
 }

 spkp = pkp;
 sskp = skp;

 pk, sk = crypto_kem_keypair_randominc(pk, sk, random_bytes_crypto, indcpa_seed, indcpa_noiseseed);

 pkp = spkp;
 skp = sskp;

 for i = 0 to SABER_PUBLICKEYBYTES {
  t8 = pk[i] ;
  (u8) [pkp + i] = t8;
 }

 for i = 0 to SABER_SECRETKEYBYTES {
  t8 = sk[i];
  (u8) [skp + i] = t8;
 }
}


export fn crypto_kem_enc_randominc_jazz(reg u64 cp, reg u64 kp, reg u64 pkp, reg u64 random_bytes_cryptop)
{
 inline int i;

 reg u8 t8;

 stack u8[SABER_BYTES_CCA_DEC] c;
 stack u8[SABER_HASHBYTES] k;
 stack u8[SABER_INDCPA_PUBLICKEYBYTES] pk;
 stack u8[32] random_bytes_crypto;

 stack u64 scp;
 stack u64 skp;

 for i = 0 to SABER_INDCPA_PUBLICKEYBYTES {
  t8 = (u8) [pkp + i];
  pk[i] = t8;
 }

 for i = 0 to 32 {
  t8 = (u8) [random_bytes_cryptop + i];
  random_bytes_crypto[i] = t8;
 }

 scp = cp;
 skp = kp;

 c, k = crypto_kem_enc_randominc(c, k, pk, random_bytes_crypto);

 cp = scp;
 kp = skp;

 for i = 0 to SABER_BYTES_CCA_DEC {
  t8 = c[i] ;
  (u8) [cp + i] = t8;
 }

 for i = 0 to SABER_HASHBYTES {
  t8 = k[i];
  (u8) [kp + i] = t8;
 }
}


export fn crypto_kem_dec_jazz(reg u64 kp, reg u64 cp, reg u64 skp)
{
 inline int i;

 reg u8 t8;

 stack u8[SABER_HASHBYTES] k;
 stack u8[SABER_BYTES_CCA_DEC] c;
 stack u8[SABER_SECRETKEYBYTES] sk;

 stack u64 stkp;

 for i = 0 to SABER_BYTES_CCA_DEC {
  t8 = (u8) [cp + i];
  c[i] = t8;
 }

 for i = 0 to SABER_SECRETKEYBYTES {
  t8 = (u8) [skp + i];
  sk[i] = t8;
 }

 stkp = kp;

 k = crypto_kem_dec(k, c, sk);

 kp = stkp;

 for i = 0 to SABER_HASHBYTES {
  t8 = k[i];
  (u8) [kp + i] = t8;
 }
}
