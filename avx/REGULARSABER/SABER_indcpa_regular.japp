








param int CRYPTO_SECRETKEYBYTES = 2304;
param int CRYPTO_PUBLICKEYBYTES = (3 * 320 + 32);
param int CRYPTO_BYTES = 32;
param int CRYPTO_CIPHERTEXTBYTES = 1088;
param int Saber_type = 2;

param int SABER_K = 3;
param int SABER_MU = 8;
param int SABER_ET = 4;

param int SABER_EQ = 13;
param int SABER_EP = 10;

param int SABER_N = 256;
param int SABER_Q = 8192;
param int SABER_P = 1024;

param int SABER_SEEDBYTES = 32;
param int SABER_NOISESEEDBYTES = 32;
param int SABER_COINBYTES = 32;
param int SABER_KEYBYTES = 32;

param int SABER_HASHBYTES = 32;

param int SABER_POLYBYTES = 416;

param int SABER_POLYVECBYTES = (SABER_K * SABER_POLYBYTES);

param int SABER_POLYVECCOMPRESSEDBYTES = (SABER_K * 320);

param int SABER_CIPHERTEXTBYTES = (SABER_POLYVECCOMPRESSEDBYTES);



param int SABER_SCALEBYTES_KEM = (SABER_ET * SABER_N / 8);

param int SABER_INDCPA_PUBLICKEYBYTES = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SEEDBYTES);
param int SABER_INDCPA_SECRETKEYBYTES = (SABER_POLYVECBYTES);

param int SABER_PUBLICKEYBYTES = (SABER_INDCPA_PUBLICKEYBYTES);

param int SABER_SECRETKEYBYTES = (SABER_INDCPA_SECRETKEYBYTES + SABER_INDCPA_PUBLICKEYBYTES + SABER_HASHBYTES + SABER_KEYBYTES);

param int SABER_BYTES_CCA_DEC = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SCALEBYTES_KEM);



param int SABER_KN = (SABER_K * SABER_N);
param int SABER_KKN = (SABER_K * SABER_K * SABER_N);
param int N_SB = (SABER_N / 4);
param int N_SB_RES = (2 * N_SB - 1);

param int SHAKE128_RATE = 168;
param int SHAKE256_RATE = 136;
param int SHA3_256_RATE = 136;
param int SHA3_512_RATE = 72;

param int KK13N8 = (SABER_K * SABER_K * (13 * SABER_N / 8));
param int MUNK8 = (SABER_MU * SABER_N * SABER_K / 8);

param int h1 = 4;
param int h2 = 228;






















fn keccak_absorb_128_32(reg ptr u64[25] s, reg ptr u8[32] m) -> reg ptr u64[25]
{
 inline int i;
 inline int j;

 reg u8 t8;

 reg u64 t64;
 reg u64 tt;

 stack u8[200] t;

 for i = 0 to SHAKE128_RATE {
  t[i] = 0;
 }

 for i = 0 to 32 {
  t8 = m[i];
  t[i] = t8;
 }

 t[32] = 0x1F;
 t[SHAKE128_RATE - 1] |= 128;

 for i = 0 to (SHAKE128_RATE / 8) {
  t64 = (64u) t[8 * i];

  tt = (64u) t[8 * i + 1];
  tt <<= 8;
  t64 |= tt;

  tt = (64u) t[8 * i + 2];
  tt <<= 16;
  t64 |= tt;

  tt = (64u) t[8 * i + 3];
  tt <<= 24;
  t64 |= tt;

  tt = (64u) t[8 * i + 4];
  tt <<= 32;
  t64 |= tt;

  tt = (64u) t[8 * i + 5];
  tt <<= 40;
  t64 |= tt;

  tt = (64u) t[8 * i + 6];
  tt <<= 48;
  t64 |= tt;

  tt = (64u) t[8 * i + 7];
  tt <<= 56;
  t64 |= tt;

  s[i] ^= t64;
 }

 return s;
}











inline fn index(inline int x, inline int y) -> inline int {
  inline int r;
  r = (x % 5) + 5 * (y % 5);
  return r;
}


inline fn ROL64(reg u64 x, inline int c) -> reg u64 {
  reg u64 y;
  _, _, y = #ROL_64(x, c);
  return y;
}

inline fn theta(reg ptr u64[25] a) -> reg ptr u64[25] {
  inline int x, y;
  reg u64[5] c, d;

  for x = 0 to 5 {
    c[x] = 0;
    for y = 0 to 5 {
      c[x] ^= a[x + 5 * y];
    }
  }

  for x = 0 to 5 {







    d[x] = c[(x + 1) % 5];
    _, _, d[x] = #ROL_64(d[x], 1);
    d[x] ^= c[(x + 4) % 5];
  }

  for x = 0 to 5 {
    for y = 0 to 5 {
      a[x + 5 * y] ^= d[x];
    }
  }

  return a;
}


inline fn keccakRhoOffsets(inline int i) -> inline int {
  inline int r, x, y, z, t;

  r = 0;
  x = 1;
  y = 0;
  for t = 0 to 24 {
    if (i == x + 5 * y) {
      r = ((t + 1) * (t + 2) / 2) % 64;
    }
    z = (2 * x + 3 * y) % 5;
    x = y;
    y = z;
  }

  return r;
}


inline fn rho(reg ptr u64[25] a) -> reg ptr u64[25] {
  inline int x, y, i, z;

  for x = 0 to 5 {
    for y = 0 to 5 {
      i = index(x, y);
      z = keccakRhoOffsets(i);
      _, _, a[i] = #ROL_64(a[i], z);
    }
  }

  return a;
}


inline fn pi(reg ptr u64[25] a) -> reg ptr u64[25] {
  stack u64[25] b;
  reg u64 t;
  inline int x, y, i;
  for i = 0 to 25 { t = a[i]; b[i] = t; }

  for x = 0 to 5 {
    for y = 0 to 5 {
      t = b[x + 5 * y];
      i = index(y, 2 * x + 3 * y);
      a[i] = t;
    }
  }
  return a;
}


inline fn chi(reg ptr u64[25] a) -> reg ptr u64[25] {
  inline int x, y, i;
  reg u64[5] c;
  for y = 0 to 5 {
    for x = 0 to 5 {
      i = index(x + 1, y);
      c[x] = a[i];
      c[x] = !c[x];
      i = index(x + 2, y);
      c[x] &= a[i];
      i = index(x, y);
      c[x] ^= a[i];
    }
    for x = 0 to 5 {
      a[x + 5 * y] = c[x];
    }
  }
  return a;
}


inline fn iota(reg ptr u64[25] a, reg u64 c) -> reg ptr u64[25] {
  a[0] ^= c;
  return a;
}


inline fn keccakP1600_round(reg ptr u64[25] state, reg u64 c) -> reg ptr u64[25] {
  state = theta(state);
  state = rho(state);
  state = pi(state);
  state = chi(state);
  state = iota(state, c);
  return state;
}

u64[24] KeccakF_RoundConstants = {0x0000000000000001, 0x0000000000008082, 0x800000000000808a, 0x8000000080008000,
                                    0x000000000000808b, 0x0000000080000001, 0x8000000080008081, 0x8000000000008009,
                                    0x000000000000008a, 0x0000000000000088, 0x0000000080008009, 0x000000008000000a,
                                    0x000000008000808b, 0x800000000000008b, 0x8000000000008089, 0x8000000000008003,
                                    0x8000000000008002, 0x8000000000000080, 0x000000000000800a, 0x800000008000000a,
                                    0x8000000080008081, 0x8000000000008080, 0x0000000080000001, 0x8000000080008008};

fn KeccakF1600_StatePermute(reg ptr u64[25] state) -> reg ptr u64[25]
{
  inline int round;

  for round = 0 to 24 {
    state = keccakP1600_round(state, KeccakF_RoundConstants[round]);
  }

  return state;
}

inline fn keccak_squeezeblocks_128_128(reg ptr u8[SHAKE128_RATE] h, reg ptr u64[25] s) -> reg ptr u8[SHAKE128_RATE], reg ptr u64[25]
{
 inline int i;
 inline int j;

 reg u64 u;

 s = KeccakF1600_StatePermute(s);

 for i = 0 to (SHAKE128_RATE / 8) {


  u = s[i];
  for j = 0 to 8 {
   h[8 * i + j] = (8u) u;
   u >>= 8;
  }
 }

 return h, s;
}

inline fn shake128_32_32(reg ptr u8[32] output, reg ptr u8[32] input) -> reg ptr u8[32]
{
 inline int i;

 reg u8 t8;

 stack u8[SHAKE128_RATE] t;

 stack u64[25] s;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_128_32(s, input);

 t, s = keccak_squeezeblocks_128_128(t, s);

 for i = 0 to 32 {
  t8 = t[i];
  output[i] = t8;
 }

 return output;
}













inline fn keccak_squeezeblocks_128_KK13N8(reg ptr u8[KK13N8] h, reg ptr u64[25] s) -> reg ptr u8[KK13N8], reg ptr u64[25]
{
 inline int i;
 inline int j;
 inline int iterations;

 reg u64 u;

 iterations = KK13N8 / SHAKE128_RATE;

 for j = 0 to iterations {
  s = KeccakF1600_StatePermute(s);

  for i = 0 to (SHAKE128_RATE / 8) {
   u = s[i];


   h[j * SHAKE128_RATE + 8 * i] = (8u) u;
   u >>= 8;

   h[j * SHAKE128_RATE + 8 * i + 1] = (8u) u;
   u >>= 8;

   h[j * SHAKE128_RATE + 8 * i + 2] = (8u) u;
   u >>= 8;

   h[j * SHAKE128_RATE + 8 * i + 3] = (8u) u;
   u >>= 8;

   h[j * SHAKE128_RATE + 8 * i + 4] = (8u) u;
   u >>= 8;

   h[j * SHAKE128_RATE + 8 * i + 5] = (8u) u;
   u >>= 8;

   h[j * SHAKE128_RATE + 8 * i + 6] = (8u) u;
   u >>= 8;

   h[j * SHAKE128_RATE + 8 * i + 7] = (8u) u;
   u >>= 8;
  }
 }

 return h, s;
}


inline fn shake128_KK13N8_32(reg ptr u8[KK13N8] output, reg ptr u8[32] input) -> reg ptr u8[KK13N8]
{
 inline int i;
 inline int nblocks;
 inline int handled;
 inline int remainder;

 reg u8 t8;

 stack u8[SHAKE128_RATE] t;

 stack u64[25] s;

 nblocks = KK13N8 / SHAKE128_RATE;
 handled = nblocks * SHAKE128_RATE;
 remainder = KK13N8 - handled;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_128_32(s, input);

 output, s = keccak_squeezeblocks_128_KK13N8(output, s);

 if (remainder > 0) {
  t, s = keccak_squeezeblocks_128_128(t, s);

  for i = 0 to remainder {
   t8 = t[i];
   output[handled + i] = t8;
  }
 }

 return output;
}







fn BS2POLq(reg ptr u8[SABER_POLYBYTES] bytes, reg ptr u16[SABER_N] data) -> reg ptr u16[SABER_N]
{
 inline int j;

 reg u16 b1;
 reg u16 b2;
 reg u16 b3;


 for j = 0 to (SABER_N / 8) {

  b1 = (16u) bytes[13 * j];
  b1 &= 0xff;
  b2 = (16u) bytes[13 * j + 1];
  b2 &= 0x1f;
  b2 <<= 8;
  b1 |= b2;
  data[8 * j] = b1;


  b1 = (16u) bytes[13 * j + 1];
  b1 >>= 5;
  b1 &= 0x07;
  b2 = (16u) bytes[13 * j + 2];
  b2 &= 0xff;
  b2 <<= 3;
  b3 = (16u) bytes[13 * j + 3];
  b3 &= 0x03;
  b3 <<= 11;
  b2 |= b3;
  b1 |= b2;
  data[8 * j + 1] = b1;


  b1 = (16u) bytes[13 * j + 3];
  b1 >>= 2;
  b1 &= 0x3f;
  b2 = (16u) bytes[13 * j + 4];
  b2 &= 0x7f;
  b2 <<= 6;
  b1 |= b2;
  data[8 * j + 2] = b1;


  b1 = (16u) bytes[13 * j + 4];
  b1 >>= 7;
  b1 &= 0x01;
  b2 = (16u) bytes[13 * j + 5];
  b2 &= 0xff;
  b2 <<= 1;
  b3 = (16u) bytes[13 * j + 6];
  b3 &= 0x0f;
  b3 <<= 9;
  b2 |= b3;
  b1 |= b2;
  data[8 * j + 3] = b1;


  b1 = (16u) bytes[13 * j + 6];
  b1 >>= 4;
  b1 &= 0x0f;
  b2 = (16u) bytes[13 * j + 7];
  b2 &= 0xff;
  b2 <<= 4;
  b3 = (16u) bytes[13 * j + 8];
  b3 &= 0x01;
  b3 <<= 12;
  b2 |= b3;
  b1 |= b2;
  data[8 * j + 4] = b1;


  b1 = (16u) bytes[13 * j + 8];
  b1 >>= 1;
  b1 &= 0x7f;
  b2 = (16u) bytes[13 * j + 9];
  b2 &= 0x3f;
  b2 <<= 7;
  b1 |= b2;
  data[8 * j + 5] = b1;


  b1 = (16u) bytes[13 * j + 9];
  b1 >>= 6;
  b1 &= 0x03;
  b2 = (16u) bytes[13 * j + 10];
  b2 &= 0xff;
  b2 <<= 2;
  b3 = (16u) bytes[13 * j + 11];
  b3 &= 0x07;
  b3 <<= 10;
  b2 |= b3;
  b1 |= b2;
  data[8 * j + 6] = b1;


  b1 = (16u) bytes[13 * j + 11];
  b1 >>= 3;
  b1 &= 0x1f;
  b2 = (16u) bytes[13 * j + 12];
  b2 &= 0xff;
  b2 <<= 5;
  b1 |= b2;
  data[8 * j + 7] = b1;
 }

 return data;
}

fn GenMatrix(reg ptr u16[SABER_KKN] a, reg ptr u8[SABER_SEEDBYTES] seed) -> reg ptr u16[SABER_KKN]
{
 inline int i;
 inline int j;
 inline int k;
 inline int one_vector;

 reg u8 t8;

 reg u16 t16;

 stack u8[KK13N8] buf;

 stack u16[SABER_N] temp_ar;

 stack ptr u16[SABER_KKN] sa;

 one_vector = 13 * SABER_N / 8;

 sa = a;

 buf = shake128_KK13N8_32(buf, seed);

 a = sa;

 for i = 0 to SABER_K {
  for j = 0 to SABER_K {
   temp_ar = BS2POLq(buf[(i * SABER_K + j) * one_vector:SABER_POLYBYTES], temp_ar);

   for k = 0 to SABER_N {
    t16 = temp_ar[k];
    t16 &= (SABER_Q - 1);
    a[i * SABER_KN + j * SABER_N + k] = t16;
   }
  }
 }

 return a;
}













inline fn keccak_squeezeblocks_128_MUNK8(reg ptr u8[MUNK8] h, reg ptr u64[25] s) -> reg ptr u8[MUNK8], reg ptr u64[25]
{
 inline int i;
 inline int j;
 inline int iterations;

 reg u64 u;

 iterations = MUNK8 / SHAKE128_RATE;

 for j = 0 to iterations {
  s = KeccakF1600_StatePermute(s);

  for i = 0 to (SHAKE128_RATE / 8) {
   u = s[i];


   h[j * SHAKE128_RATE + 8 * i] = (8u) u;
   u >>= 8;

   h[j * SHAKE128_RATE + 8 * i + 1] = (8u) u;
   u >>= 8;

   h[j * SHAKE128_RATE + 8 * i + 2] = (8u) u;
   u >>= 8;

   h[j * SHAKE128_RATE + 8 * i + 3] = (8u) u;
   u >>= 8;

   h[j * SHAKE128_RATE + 8 * i + 4] = (8u) u;
   u >>= 8;

   h[j * SHAKE128_RATE + 8 * i + 5] = (8u) u;
   u >>= 8;

   h[j * SHAKE128_RATE + 8 * i + 6] = (8u) u;
   u >>= 8;

   h[j * SHAKE128_RATE + 8 * i + 7] = (8u) u;
   u >>= 8;
  }
 }

 return h, s;
}


inline fn shake128_MUNK8_32(reg ptr u8[MUNK8] output, reg ptr u8[32] input) -> reg ptr u8[MUNK8]
{
 inline int i;
 inline int nblocks;
 inline int handled;
 inline int remainder;

 reg u8 t8;

 stack u8[SHAKE128_RATE] t;

 stack u64[25] s;

 nblocks = MUNK8 / SHAKE128_RATE;
 handled = nblocks * SHAKE128_RATE;
 remainder = MUNK8 - handled;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_128_32(s, input);

 output, s = keccak_squeezeblocks_128_MUNK8(output, s);

 if (remainder > 0) {
  t, s = keccak_squeezeblocks_128_128(t, s);

  for i = 0 to remainder {
   t8 = t[i];
   output[handled + i] = t8;
  }
 }

 return output;
}







fn cbd(reg ptr u16[SABER_N] r, reg ptr u8[SABER_N] buf) -> reg ptr u16[SABER_N]
{
 inline int i;

 reg u8 t8;

 reg u16 t16;

 reg u32 t32;
 reg u32 d;
 reg u32 tt;

 stack u32[4] a;
 stack u32[4] b;

 for i = 0 to (SABER_N / 4) {

        t32 = (32u) buf[4 * i];

        tt = (32u) buf[4 * i + 1];
        tt <<= 8;
        t32 |= tt;

        tt = (32u) buf[4 * i + 2];
        tt <<= 16;
        t32 |= tt;

        tt = (32u) buf[4 * i + 3];
        tt <<= 24;
        t32 |= tt;

  d = 0;


  tt = t32;
        tt &= 0x11111111;
  d += tt;

  tt = t32;
  tt >>= 1;
  tt &= 0x11111111;
  d += tt;

  tt = t32;
  tt >>= 2;
  tt &= 0x11111111;
  d += tt;

  tt = t32;
  tt >>= 3;
  tt &= 0x11111111;
  d += tt;


     t32 = d;
     t32 &= 0xf;
  a[0] = t32;


     t32 = d;
     t32 >>= 4;
     t32 & = 0xf;
     b[0] = t32;


     t32 = d;
     t32 >>= 8;
     t32 &= 0xf;
     a[1] = t32;


     t32 = d;
     t32 >>= 12;
     t32 &= 0xf;
     b[1] = t32;


     t32 = d;
     t32 >>= 16;
     t32 &= 0xf;
     a[2] = t32;


  t32 = d;
     t32 >>= 20;
     t32 &= 0xf;
     b[2] = t32;


     t32 = d;
     t32 >>= 24;
     t32 &= 0xf;
     a[3] = t32;


     t32 = d;
     t32 >>= 28;
     b[3] = t32;


     t32 = a[0];
     t32 -= b[0];
     t16 = (16u) t32;
     t16 &= (SABER_Q - 1);
     r[4 * i] = t16;


     t32 = a[1];
     t32 -= b[1];
     t16 = (16u) t32;
        t16 &= (SABER_Q - 1);
     r[4 * i + 1] = t16;


     t32 = a[2];
     t32 -= b[2];
     t16 = (16u) t32;
     t16 &= (SABER_Q - 1);
     r[4 * i + 2] = t16;


     t32 = a[3];
     t32 -= b[3];
     t16 = (16u) t32;
     t16 &= (SABER_Q - 1);
     r[4 * i + 3] = t16;
 }

 return r;
}

fn GenSecret(reg ptr u16[SABER_KN] r, reg ptr u8[SABER_COINBYTES] seed) -> reg ptr u16[SABER_KN]
{
 inline int i;
 inline int j;

 reg u8 t8;

 reg u16 t16;


 stack u8[MUNK8] buf;
 stack u8[SABER_N] tbuf;

 stack u16[SABER_N] tr;

 stack ptr u16[SABER_KN] sr;

 sr = r;

 buf = shake128_MUNK8_32(buf, seed);

 r = sr;

 for i = 0 to SABER_K {

  for j = 0 to SABER_N {
   t8 = buf[i * SABER_MU * SABER_N / 8 + j];
   tbuf[j] = t8;
  }

  tr = cbd(tr, tbuf);



  for j = 0 to SABER_N {
   t16 = tr[j];
   r[i * SABER_N + j] = t16;
  }
 }

 return r;
}







inline fn POLVECq2BS(reg ptr u8[SABER_POLYVECBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u8[SABER_POLYVECBYTES]
{
 inline int i;
 inline int j;

 reg u16 d1;
 reg u16 d2;

 for i = 0 to SABER_K {
  for j = 0 to (SABER_N / 8) {



   d1 = data[i * SABER_N + 8 * j];
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j];
   d1 >>= 8;
   d1 &= 0x1f;
   d2 = data[i * SABER_N + 8 * j + 1];
   d2 &= 0x07;
   d2 <<= 5;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 1] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 1];
   d1 >>= 3;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 2] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 1];
   d1 >>= 11;
   d1 &= 0x03;
   d2 = data[i * SABER_N + 8 * j + 2];
   d2 &= 0x3f;
   d2 <<= 2;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 3] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 2];
   d1 >>= 6;
   d1 &= 0x7f;
   d2 = data[i * SABER_N + 8 * j + 3];
   d2 &= 0x01;
   d2 <<= 7;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 4] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 3];
   d1 >>= 1;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 5] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 3];
   d1 >>= 9;
   d1 &= 0x0f;
   d2 = data[i * SABER_N + 8 * j + 4];
   d2 &= 0x0f;
   d2 <<= 4;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 6] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 4];
   d1 >>= 4;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 7] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 4];
   d1 >>= 12;
   d1 &= 0x01;
   d2 = data[i * SABER_N + 8 * j + 5];
   d2 &= 0x7f;
   d2 <<= 1;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 8] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 5];
   d1 >>= 7;
   d1 &= 0x3f;
   d2 = data[i * SABER_N + 8 * j + 6];
   d2 &= 0x03;
   d2 <<= 6;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 9] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 6];
   d1 >>= 2;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 10] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 6];
   d1 >>= 10;
   d1 &= 0x07;
   d2 = data[i * SABER_N + 8 * j + 7];
   d2 &= 0x1f;
   d2 <<= 3;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 11] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 7];
   d1 >>= 5;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 12] = (8u) d1;
  }
 }

 return bytes;
}







fn POLVECp2BS(reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES]
{
 inline int i;
 inline int j;

 reg u16 d1;
 reg u16 d2;

 for i = 0 to SABER_K {
  for j = 0 to (SABER_N / 4) {

   d1 = data[i * SABER_N + 4 * j];
   d1 &= 0xff;
   bytes[i * (SABER_N * 10) / 8 + 5 * j] = (8u) d1;


   d1 = data[i * SABER_N + 4 * j];
   d1 >>= 8;
   d1 &= 0x03;
   d2 = data[i * SABER_N + 4 * j + 1];
   d2 &= 0x3f;
   d2 <<= 2;
   d1 |= d2;
   bytes[i * (SABER_N * 10) / 8 + 5 * j + 1] = (8u) d1;


   d1 = data[i * SABER_N + 4 * j + 1];
   d1 >>= 6;
   d1 &= 0x0f;
   d2 = data[i * SABER_N + 4 * j + 2];
   d2 &= 0x0f;
   d2 <<= 4;
   d1 |= d2;
   bytes[i * (SABER_N * 10) / 8 + 5 * j + 2] = (8u) d1;


   d1 = data[i * SABER_N + 4 * j + 2];
   d1 >>= 4;
   d1 &= 0x3f;
   d2 = data[i * SABER_N + 4 * j + 3];
   d2 &= 0x03;
   d2 <<= 6;
   d1 |= d2;
   bytes[i * (SABER_N * 10) / 8 + 5 * j + 3] = (8u) d1;


   d1 = data[i * SABER_N + 4 * j + 3];
   d1 >>= 2;
   d1 &= 0xff;
   bytes[i * (SABER_N * 10) / 8 + 5 * j + 4] = (8u) d1;
  }
 }

 return bytes;
}

inline fn load_256(reg u256 r, stack u16[16] buf) -> reg u256
{
 inline int i;

 reg u256 t256;

 r = (256u) buf[0];
 for i = 1 to 16 {
  t256 = (256u) buf[i];
  t256 <<= 16 * i;
  r |= t256;
 }

 return r;
}

inline fn indcpa_kem_keypair_randominc(stack u8[SABER_INDCPA_PUBLICKEYBYTES] pk, stack u8[SABER_INDCPA_SECRETKEYBYTES] sk, stack u8[SABER_SEEDBYTES] seed, stack u8[SABER_COINBYTES] noiseseed) -> stack u8[SABER_INDCPA_PUBLICKEYBYTES], stack u8[SABER_INDCPA_SECRETKEYBYTES]
{
 inline int i;
 inline int j;
 inline int k;

 reg u8 t8;

 reg u256 mod;
 reg u256 mask_load;
 reg u256 H1_avx;
 reg u256 H2_avx;
 reg u256 floor_round;
 reg u256 t256;

 stack u16[SABER_KKN] a;
 stack u16[SABER_KN] skpv1;

 stack u256[SABER_KKN / 16] a_avx;
 stack u256[SABER_KN / 16] sk_avx;
 stack u256[SABER_KN / 16] res_avx;
 stack u256[SABER_K * 64] b_bucket;

 mask_load = #VPBROADCAST_4u64(0xFFFFFFFF);

 mod = #VPBROADCAST_16u16(SABER_Q - 1);
 floor_round = #VPBROADCAST_16u16(4);
 H1_avx = #VPBROADCAST_16u16(h1);


 seed = shake128_32_32(seed, seed);

 a = GenMatrix(a, seed);

 skpv1 = GenSecret(skpv1, noiseseed);

 for i = 0 to SABER_K {
  for j = 0 to SABER_N / 16 {
   t256 = load_256(t256, skpv1[i * SABER_N + j * 16:16]);
   sk_avx[i * SABER_N + j] = t256;
  }
 }

 for i = 0 to SABER_K {
  for j = 0 to SABER_K {
   for k = 0 to SABER_N / 16 {
    t256 = load_256(t256, a[i * SABER_KN + j * SABER_N + k * 16:16]);
    a_avx[i * SABER_KN + j * SABER_N + k] = t256;
   }
  }
 }



 for i = 0 to SABER_KN / 16 {
  res_avx[i] +16u16= H1_avx;
  res_avx[i] &16u16= (SABER_Q - 1);
  res_avx[i] >>16u16= (SABER_EQ - SABER_EP);
 }

 sk = POLVECq2BS(sk, skpv1);

 for i = 0 to SABER_K {
  for j = 0 to SABER_N / 16 {
   skpv1[i * SABER_N + j * 16] = #VMOVQ(skpv1[i * SABER_N + j * 16], mask_load, res_avx[i * SABER_N + j]);
  }
 }

 pk[0:SABER_POLYVECCOMPRESSEDBYTES] = POLVECp2BS(pk[0:SABER_POLYVECCOMPRESSEDBYTES], res);

 for i = 0 to SABER_SEEDBYTES {
  t8 = seed[i];
  pk[SABER_POLYVECCOMPRESSEDBYTES + i] = t8;
 }

 return pk, sk;
}
export fn GenMatrix_jazz(reg u64 ap, reg u64 seedp)
{
 inline int i;

 reg u8 t8;

 reg u16 t16;

 stack u8[SABER_SEEDBYTES] seed;

 stack u16[SABER_KKN] a;

 stack u64 sap;

 for i = 0 to SABER_KKN {
  t16 = (u16) [ap + 2 * i];
  a[i] = t16;
 }

 for i = 0 to SABER_SEEDBYTES {
  t8 = (u8) [seedp + i];
  seed[i] = t8;
 }

 sap = ap;

 a = GenMatrix(a, seed);

 ap = sap;

 for i = 0 to SABER_KKN {
  t16 = a[i];
  (u16) [ap + 2 * i] = t16;
 }
}
