/*** fips202_regular_KeccakF1600_StatePermute.jahh: File containing the Jasmin implementation of KeccakF1600_StatePermute function from fips202.c, with (regular) SABER parameters ***/

#ifndef KECCAKF1600_STATEPERMUTE_HH
#define KECCAKF1600_STATEPERMUTE_HH

u256[6] rhotates_left = {0x0000000000000003000000000000001200000000000000240000000000000029,
                          0x0000000000000001000000000000003e000000000000001c000000000000001b,
                          0x000000000000002d000000000000000600000000000000380000000000000027,
                          0x000000000000000a000000000000003d00000000000000370000000000000008,
                          0x0000000000000002000000000000000f00000000000000190000000000000014,
                          0x000000000000002c000000000000002b0000000000000015000000000000000e};

u256[6] rhotates_right = {0x000000000000003d000000000000002e000000000000001c0000000000000017,
                          0x000000000000003f000000000000000200000000000000240000000000000025,
                          0x0000000000000013000000000000003a00000000000000080000000000000019,
                          0x0000000000000036000000000000000300000000000000090000000000000038,
                          0x000000000000003e00000000000000310000000000000027000000000000002c,
                          0x00000000000000140000000000000015000000000000002b0000000000000032};

u256[24] iotas = {0x0000000000000001000000000000000100000000000000010000000000000001, 
                    0x0000000000008082000000000000808200000000000080820000000000008082, 
                    0x800000000000808a800000000000808a800000000000808a800000000000808a, 
                    0x8000000080008000800000008000800080000000800080008000000080008000, 
                    0x000000000000808b000000000000808b000000000000808b000000000000808b, 
                    0x0000000080000001000000008000000100000000800000010000000080000001, 
                    0x8000000080008081800000008000808180000000800080818000000080008081, 
                    0x8000000000008009800000000000800980000000000080098000000000008009, 
                    0x000000000000008a000000000000008a000000000000008a000000000000008a, 
                    0x0000000000000088000000000000008800000000000000880000000000000088, 
                    0x0000000080008009000000008000800900000000800080090000000080008009, 
                    0x000000008000000a000000008000000a000000008000000a000000008000000a, 
                    0x000000008000808b000000008000808b000000008000808b000000008000808b, 
                    0x800000000000008b800000000000008b800000000000008b800000000000008b, 
                    0x8000000000008089800000000000808980000000000080898000000000008089, 
                    0x8000000000008003800000000000800380000000000080038000000000008003, 
                    0x8000000000008002800000000000800280000000000080028000000000008002, 
                    0x8000000000000080800000000000008080000000000000808000000000000080, 
                    0x000000000000800a000000000000800a000000000000800a000000000000800a, 
                    0x800000008000000a800000008000000a800000008000000a800000008000000a, 
                    0x8000000080008081800000008000808180000000800080818000000080008081, 
                    0x8000000000008080800000000000808080000000000080808000000000008080, 
                    0x0000000080000001000000008000000100000000800000010000000080000001, 
                    0x8000000080008008800000008000800880000000800080088000000080008008};

fn KeccakF1600_StatePermute(
  reg ptr u256[7] state,
) -> reg ptr u256[7]
{
  reg u256[9] t;
  reg u256 c00 c14 d00 d14;

  reg bool zf;
  reg u32 r;

  r = 24;
  align while
  {

    //######################################## Theta
    c00 = #VPSHUFD_256(state[2], (4u2)[1,0,3,2]);
    c14 = state[5] ^ state[3];
    t[2] = state[4] ^ state[6];
    c14 = c14 ^ state[1];
    c14 = c14 ^ t[2];
    t[4] = #VPERMQ(c14, (4u2)[2,1,0,3]);
    c00 = c00 ^ state[2];
    t[0] = #VPERMQ(c00, (4u2)[1,0,3,2]);
    t[1] = c14 >>4u64 63;
    t[2] = c14 +4u64 c14;
    t[1] = t[1] | t[2];
    d14 = #VPERMQ(t[1], (4u2)[0,3,2,1]);
    d00 = t[1] ^ t[4];
    d00 = #VPERMQ(d00, (4u2)[0,0,0,0]);
    c00 = c00 ^ state[0];
    c00 = c00 ^ t[0];
    t[0] = c00 >>4u64 63;
    t[1] = c00 +4u64 c00;
    t[1] = t[1] | t[0];
    state[2] = state[2] ^ d00;
    state[0] = state[0] ^ d00;
    d14 = #VPBLENDD_256(d14, t[1], (8u1)[1,1,0,0,0,0,0,0]);
    t[4] = #VPBLENDD_256(t[4], c00, (8u1)[0,0,0,0,0,0,1,1]);
    d14 = d14 ^ t[4];

    //######################################## Rho + Pi + pre-Chi shuffle
    t[3] = #VPSLLV_4u64(state[2], B256(rhotates_left,0,96) );
    state[2] = #VPSRLV_4u64(state[2], B256(rhotates_right,0,96) );
    state[2] = state[2] | t[3];
    state[3] = state[3] ^ d14;
    t[4] = #VPSLLV_4u64(state[3], B256(rhotates_left,2,96) );
    state[3] = #VPSRLV_4u64(state[3], B256(rhotates_right,2,96) );
    state[3] = state[3] | t[4];
    state[4] = state[4] ^ d14;
    t[5] = #VPSLLV_4u64(state[4], B256(rhotates_left,3,96) );
    state[4] = #VPSRLV_4u64(state[4], B256(rhotates_right,3,96) );
    state[4] = state[4] | t[5];
    state[5] = state[5] ^ d14;
    t[6] = #VPSLLV_4u64(state[5], B256(rhotates_left,4,96) );
    state[5] = #VPSRLV_4u64(state[5], B256(rhotates_right,4,96) );
    state[5] = state[5] | t[6];
    state[6] = state[6] ^ d14;
    t[3] = #VPERMQ(state[2], (4u2)[2,0,3,1]);
    t[4] = #VPERMQ(state[3], (4u2)[2,0,3,1]);
    t[7] = #VPSLLV_4u64(state[6], B256(rhotates_left,5,96) );
    t[1] = #VPSRLV_4u64(state[6], B256(rhotates_right,5,96) );
    t[1] = t[1] | t[7];
    state[1] = state[1] ^ d14;
    t[5] = #VPERMQ(state[4], (4u2)[0,1,2,3]);
    t[6] = #VPERMQ(state[5], (4u2)[1,3,0,2]);
    t[8] = #VPSLLV_4u64(state[1], B256(rhotates_left,1,96) );
    t[2] = #VPSRLV_4u64(state[1], B256(rhotates_right,1,96) );
    t[2] = t[2] | t[8];

    //######################################## Chi
    t[7] = #VPSRLDQ_256(t[1], 8);
    t[0] = !t[1] & t[7];
    state[3] = #VPBLENDD_256(t[2], t[6], (8u1)[0,0,0,0,1,1,0,0]);
    t[8] = #VPBLENDD_256(t[4], t[2], (8u1)[0,0,0,0,1,1,0,0]);
    state[5] = #VPBLENDD_256(t[3], t[4], (8u1)[0,0,0,0,1,1,0,0]);
    t[7] = #VPBLENDD_256(t[2], t[3], (8u1)[0,0,0,0,1,1,0,0]);
    state[3] = #VPBLENDD_256(state[3], t[4], (8u1)[0,0,1,1,0,0,0,0]);
    t[8] = #VPBLENDD_256(t[8], t[5], (8u1)[0,0,1,1,0,0,0,0]);
    state[5] = #VPBLENDD_256(state[5], t[2], (8u1)[0,0,1,1,0,0,0,0]);
    t[7] = #VPBLENDD_256(t[7], t[6], (8u1)[0,0,1,1,0,0,0,0]);
    state[3] = #VPBLENDD_256(state[3], t[5], (8u1)[1,1,0,0,0,0,0,0]);
    t[8] = #VPBLENDD_256(t[8], t[6], (8u1)[1,1,0,0,0,0,0,0]);
    state[5] = #VPBLENDD_256(state[5], t[6], (8u1)[1,1,0,0,0,0,0,0]);
    t[7] = #VPBLENDD_256(t[7], t[4], (8u1)[1,1,0,0,0,0,0,0]);
    state[3] = !state[3] & t[8];
    state[5] = !state[5] & t[7];
    state[6] = #VPBLENDD_256(t[5], t[2], (8u1)[0,0,0,0,1,1,0,0]);
    t[8] = #VPBLENDD_256(t[3], t[5], (8u1)[0,0,0,0,1,1,0,0]);
    state[3] = state[3] ^ t[3];
    state[6] = #VPBLENDD_256(state[6], t[3], (8u1)[0,0,1,1,0,0,0,0]);
    t[8] = #VPBLENDD_256(t[8], t[4], (8u1)[0,0,1,1,0,0,0,0]);
    state[5] = state[5] ^ t[5];
    state[6] = #VPBLENDD_256(state[6], t[4], (8u1)[1,1,0,0,0,0,0,0]);
    t[8] = #VPBLENDD_256(t[8], t[2], (8u1)[1,1,0,0,0,0,0,0]);
    state[6] = !state[6] & t[8];
    state[6] = state[6] ^ t[6];
    state[4] = #VPERMQ(t[1], (4u2)[0,1,3,2]);
    t[8] = #VPBLENDD_256(state[4], state[0], (8u1)[0,0,1,1,0,0,0,0]);
    state[1] = #VPERMQ(t[1], (4u2)[0,3,2,1]);
    state[1] = #VPBLENDD_256(state[1], state[0], (8u1)[1,1,0,0,0,0,0,0]);
    state[1] = !state[1] & t[8];
    state[2] = #VPBLENDD_256(t[4], t[5], (8u1)[0,0,0,0,1,1,0,0]);
    t[7] = #VPBLENDD_256(t[6], t[4], (8u1)[0,0,0,0,1,1,0,0]);
    state[2] = #VPBLENDD_256(state[2], t[6], (8u1)[0,0,1,1,0,0,0,0]);
    t[7] = #VPBLENDD_256(t[7], t[3], (8u1)[0,0,1,1,0,0,0,0]);
    state[2] = #VPBLENDD_256(state[2], t[3], (8u1)[1,1,0,0,0,0,0,0]);
    t[7] = #VPBLENDD_256(t[7], t[5], (8u1)[1,1,0,0,0,0,0,0]);
    state[2] = !state[2] & t[7];
    state[2] = state[2] ^ t[2];
    t[0] = #VPERMQ(t[0], (4u2)[0,0,0,0]);
    state[3] = #VPERMQ(state[3], (4u2)[0,1,2,3]);
    state[5] = #VPERMQ(state[5], (4u2)[2,0,3,1]);
    state[6] = #VPERMQ(state[6], (4u2)[1,3,0,2]);
    state[4] = #VPBLENDD_256(t[6], t[3], (8u1)[0,0,0,0,1,1,0,0]);
    t[7] = #VPBLENDD_256(t[5], t[6], (8u1)[0,0,0,0,1,1,0,0]);
    state[4] = #VPBLENDD_256(state[4], t[5], (8u1)[0,0,1,1,0,0,0,0]);
    t[7] = #VPBLENDD_256(t[7], t[2], (8u1)[0,0,1,1,0,0,0,0]);
    state[4] = #VPBLENDD_256(state[4], t[2], (8u1)[1,1,0,0,0,0,0,0]);
    t[7] = #VPBLENDD_256(t[7], t[3], (8u1)[1,1,0,0,0,0,0,0]);
    state[4] = !state[4] & t[7];
    state[0] = state[0] ^ t[0];
    state[1] = state[1] ^ t[1];
    state[4] = state[4] ^ t[4];

    //######################################## Iota
    state[0] = state[0] ^ B256(iotas,0,0);

    iotas = iotas + 32;
    (_,_,_,zf,r) = #DEC_32(r);
  } (!zf)

  return state;
}


fn KeccakF1600_StatePermute(reg ptr u64[25] state) -> reg ptr u64[25]
{
  inline int round;

  for round = 0 to 24 {
    state = keccakP1600_round(state, KeccakF_RoundConstants[round]);
  }

  return state;
}

#endif