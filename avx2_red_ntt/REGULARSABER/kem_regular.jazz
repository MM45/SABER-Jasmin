/*** kem_regular.jazz: File containing the Jasmin wrappers of the functions in the kem_regular*.jahh files, only used for unit testing ***/

#include "SABER_params.jahh"
#include "kem_regular_crypto_kem_keypair_randominc.jahh"
#include "kem_regular_crypto_kem_enc_randominc.jahh"
#include "kem_regular_crypto_kem_dec.jahh"


export fn crypto_kem_keypair_randominc_jazz(reg u64 pkp, reg u64 skp, reg u64 random_bytes_cryptop, reg u64 indcpa_seedp, reg u64 indcpa_noiseseedp)
{
	reg u8 t8;

	reg u64 i;

	stack u8[SABER_PUBLICKEYBYTES] pk;
	stack u8[SABER_SECRETKEYBYTES] sk;
	stack u8[SABER_KEYBYTES] random_bytes_crypto;
	stack u8[SABER_SEEDBYTES] indcpa_seed;
	stack u8[SABER_COINBYTES] indcpa_noiseseed;

	stack u64 spkp;
	stack u64 sskp;

	i = 0;
	while (i < SABER_KEYBYTES) {
		t8 = (u8) [random_bytes_cryptop + i];
		random_bytes_crypto[(int) i] = t8;

		i += 1;
	}

	i = 0;
	while (i < SABER_SEEDBYTES) {
		t8 = (u8) [indcpa_seedp + i];
		indcpa_seed[(int) i] = t8;

		i += 1;
	}

	i = 0;
	while (i < SABER_COINBYTES) {
		t8 = (u8) [indcpa_noiseseedp + i];
		indcpa_noiseseed[(int) i] = t8;

		i += 1;
	}

	spkp = pkp;
	sskp = skp;

	pk, sk = crypto_kem_keypair_randominc(pk, sk, random_bytes_crypto, indcpa_seed, indcpa_noiseseed);

	pkp = spkp;
	skp = sskp;

	i = 0;
	while (i < SABER_PUBLICKEYBYTES) {
		t8 = pk[(int) i] ;
		(u8) [pkp + i] = t8;

		i += 1;
	}

	i = 0;
	while (i < SABER_SECRETKEYBYTES) {
		t8 = sk[(int) i];
		(u8) [skp + i] = t8;

		i += 1;
	}
}


export fn crypto_kem_enc_randominc_jazz(reg u64 cp, reg u64 kp, reg u64 pkp, reg u64 random_bytes_cryptop)
{
	reg u8 t8;

	reg u64 i;

	stack u8[SABER_BYTES_CCA_DEC] c;
	stack u8[SABER_HASHBYTES] k;
	stack u8[SABER_INDCPA_PUBLICKEYBYTES] pk;
	stack u8[32] random_bytes_crypto;

	stack u64 scp;
	stack u64 skp;

	i = 0;
	while (i < SABER_INDCPA_PUBLICKEYBYTES) {
		t8 = (u8) [pkp + i];
		pk[(int) i] = t8;

		i += 1;
	}

	i = 0;
	while (i < 32) {
		t8 = (u8) [random_bytes_cryptop + i];
		random_bytes_crypto[(int) i] = t8;

		i += 1;
	}

	scp = cp;
	skp = kp;

	c, k = crypto_kem_enc_randominc(c, k, pk, random_bytes_crypto);

	cp = scp;
	kp = skp;

	i = 0;
	while (i < SABER_BYTES_CCA_DEC) {
		t8 = c[(int) i] ;
		(u8) [cp + i] = t8;

		i += 1;
	}

	i = 0;
	while (i < SABER_HASHBYTES) {
		t8 = k[(int) i];
		(u8) [kp + i] = t8;
		
		i += 1;
	}
}

export fn crypto_kem_dec_jazz(reg u64 kp, reg u64 cp, reg u64 skp)
{
	reg u8 t8;

	reg u64 i;

	stack u8[SABER_HASHBYTES] k;
	stack u8[SABER_BYTES_CCA_DEC] c;
	stack u8[SABER_SECRETKEYBYTES] sk;

	stack u64 stkp;

	i = 0;
	while (i < SABER_BYTES_CCA_DEC) {
		t8 = (u8) [cp + i];
		c[(int) i] = t8;

		i += 1;
	}
	
	i = 0;
	while (i < SABER_SECRETKEYBYTES) {
		t8 = (u8) [skp + i];
		sk[(int) i] = t8;

		i += 1;
	}

	stkp = kp;

	k = crypto_kem_dec(k, c, sk);
	
	kp = stkp;

	i = 0;
	while (i < SABER_HASHBYTES) {
		t8 = k[(int) i];
		(u8) [kp + i] = t8;

		i += 1;
	}
}