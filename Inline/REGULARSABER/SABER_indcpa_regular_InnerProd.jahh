/*** SABER_indcpa_regular_InnerProd.jahh: File containing the Jasmin implementation of the InnerProd function from SABER_indcpa.c, with (regular) SABER parameters ***/

#ifndef INNERPROD_HH
#define INNERPROD_HH

#include "SABER_params.jahh"
#include "poly_mul_regular_pol_mul.jahh"

inline fn InnerProd(stack u16[SABER_KN] pkcl, stack u16[SABER_KN] skpv, stack u16[SABER_N] res) -> stack u16[SABER_N]
{
	
	inline int k;

	reg u16 t;

	reg u64 j;
	reg u64 address;

	stack u16[SABER_N] acc;

	stack u16[SABER_N] ta;
	stack u16[SABER_N] tb;

	j = 0;
	while (j < SABER_K) {
		// copy values to arguments
		for k = 0 to SABER_N {
			// address = j * SABER_N + k
			address = j * SABER_N;
			address += k;

			t = pkcl[(int) address];
			ta[k] = t;

			t = skpv[(int) address];
			tb[k] = t;
		}

		acc = pol_mul(ta, tb, acc, SABER_P);

		for k = 0 to SABER_N {
			t = acc[k];
			res[k] += t;
			res[k] &= (SABER_P - 1);
			acc[k] = 0;
		}
		j += 1;
	}

	return res;
}

#endif