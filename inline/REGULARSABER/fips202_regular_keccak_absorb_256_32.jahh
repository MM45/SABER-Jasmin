/*** fips202_regular_keccak_absorb_256_32.jahh: File containing the Jasmin implementation of keccak_absorb function from fips202.c, where rate == SHA3256RATE, mlen == 32 and with (regular) SABER parameters ***/

#ifndef KECCAK_ABSORB_256_32_HH
#define KECCAK_ABSORB_256_32_HH

#include "SABER_params.jahh"
#include "fips202_regular_load64.jahh"
#include "fips202_regular_KeccakF1600_StatePermute.jahh"

inline fn keccak_absorb_256_32(stack u64[25] s, stack u8[32] m, reg u8 p) -> stack u64[25]
{
	inline int j;

	reg u8 t8;

	reg u64 i;
	reg u64 mp;
	reg u64 address;
	reg u64 mlen;
	reg u64 t64;
	
	stack u8[8] load_arg;
	stack u8[200] t;

	mp = 0;
	mlen = 32;
	// TODO: 32 < SHA3_256_RATE (=136), so can remove while loop
	while (mlen >= SHA3_256_RATE) {
		
		i = 0;
		while (i < (SHA3_256_RATE / 8)) {
			
			for j = 0 to 8 {
				// address = mp + 8 * i + j
				address = 8 * i;
				address += mp;
				address += j;

				t8 = m[(int) address];
				load_arg[j] = t8;
			}

			t64 = load64(load_arg);
			s[(int) i] ^= t64;

			i += 1;
		}

		s = KeccakF1600_StatePermute(s);
		mlen -= SHA3_256_RATE;
		mp += SHA3_256_RATE;
	}


	i = 0;
	while (i < SHA3_256_RATE) {
		t[(int) i] = 0;

		i += 1;
	}

	i = 0;
	while (i < mlen) {
		address = mp;
		address += i;
		t8 = m[(int) address];
		t[(int) i] = t8;

		i += 1;
	}

	t[(int) i] = p;
	t[SHA3_256_RATE - 1] |= 128;

	i = 0;
	while (i < (SHA3_256_RATE / 8)) {
		
		for j = 0 to 8 {
			address = 8 * i;
			address += j;

			t8 = t[(int) address];
			load_arg[j] = t8;
		}

		t64 = load64(load_arg);
		s[(int) i] ^= t64;

		i += 1;
	}

	return s;
}

#endif