








param int CRYPTO_SECRETKEYBYTES = 2304;
param int CRYPTO_PUBLICKEYBYTES = (3 * 320 + 32);
param int CRYPTO_BYTES = 32;
param int CRYPTO_CIPHERTEXTBYTES = 1088;
param int Saber_type = 2;

param int SABER_K = 3;
param int SABER_MU = 8;
param int SABER_ET = 4;

param int SABER_EQ = 13;
param int SABER_EP = 10;

param int SABER_N = 256;
param int SABER_Q = 8192;
param int SABER_P = 1024;

param int SABER_SEEDBYTES = 32;
param int SABER_NOISESEEDBYTES = 32;
param int SABER_COINBYTES = 32;
param int SABER_KEYBYTES = 32;

param int SABER_HASHBYTES = 32;

param int SABER_POLYBYTES = 416;

param int SABER_POLYVECBYTES = (SABER_K * SABER_POLYBYTES);

param int SABER_POLYVECCOMPRESSEDBYTES = (SABER_K * 320);

param int SABER_CIPHERTEXTBYTES = (SABER_POLYVECCOMPRESSEDBYTES);



param int SABER_SCALEBYTES_KEM = (SABER_ET * SABER_N / 8);

param int SABER_INDCPA_PUBLICKEYBYTES = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SEEDBYTES);
param int SABER_INDCPA_SECRETKEYBYTES = (SABER_POLYVECBYTES);

param int SABER_PUBLICKEYBYTES = (SABER_INDCPA_PUBLICKEYBYTES);

param int SABER_SECRETKEYBYTES = (SABER_INDCPA_SECRETKEYBYTES + SABER_INDCPA_PUBLICKEYBYTES + SABER_HASHBYTES + SABER_KEYBYTES);

param int SABER_BYTES_CCA_DEC = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SCALEBYTES_KEM);



param int SABER_KN = (SABER_K * SABER_N);
param int SABER_KKN = (SABER_K * SABER_K * SABER_N);
param int N_SB = (SABER_N / 4);
param int N_SB_RES = (2 * N_SB - 1);

param int SHAKE128_RATE = 168;
param int SHAKE256_RATE = 136;
param int SHA3_256_RATE = 136;
param int SHA3_512_RATE = 72;

param int KK13N8 = (SABER_K * SABER_K * (13 * SABER_N / 8));
param int MUNK8 = (SABER_MU * SABER_N * SABER_K / 8);

param int h1 = 4;
param int h2 = 228;






inline fn SABER_pack_4bit(stack u8[SABER_SCALEBYTES_KEM] bytes, stack u16[SABER_N] data) -> stack u8[SABER_SCALEBYTES_KEM]
{
 inline int j;

 reg u16 d1;
 reg u16 d2;

 for j = 0 to (SABER_N / 2) {

  d1 = data[2 * j];
  d1 &= 0x0f;
  d2 = data[2* j + 1];
  d2 &= 0x0f;
  d2 <<= 4;
  d1 |= d2;
  bytes[j] = (8u) d1;
 }

 return bytes;
}







inline fn SABER_un_pack4bit(stack u8[SABER_SCALEBYTES_KEM] bytes, stack u16[SABER_N] ar) -> stack u16[SABER_N]
{
 inline int j;

 reg u16 b1;

 for j = 0 to (SABER_N / 2) {

  b1 = (16u) bytes[j];
  b1 &= 0x0f;
  ar[2 * j] = b1;


  b1 = (16u) bytes[j];
  b1 >>= 4;
  b1 &= 0x0f;
  ar[2 * j + 1] = b1;
 }

 return ar;
}







inline fn POLVECp2BS(stack u8[SABER_POLYVECCOMPRESSEDBYTES] bytes, stack u16[SABER_KN] data) -> stack u8[SABER_POLYVECCOMPRESSEDBYTES]
{
 inline int i;
 inline int j;

 reg u16 d1;
 reg u16 d2;

 for i = 0 to SABER_K {
  for j = 0 to (SABER_N / 4) {

   d1 = data[i * SABER_N + 4 * j];
   d1 &= 0xff;
   bytes[i * (SABER_N * 10) / 8 + 5 * j] = (8u) d1;


   d1 = data[i * SABER_N + 4 * j];
   d1 >>= 8;
   d1 &= 0x03;
   d2 = data[i * SABER_N + 4 * j + 1];
   d2 &= 0x3f;
   d2 <<= 2;
   d1 |= d2;
   bytes[i * (SABER_N * 10) / 8 + 5 * j + 1] = (8u) d1;


   d1 = data[i * SABER_N + 4 * j + 1];
   d1 >>= 6;
   d1 &= 0x0f;
   d2 = data[i * SABER_N + 4 * j + 2];
   d2 &= 0x0f;
   d2 <<= 4;
   d1 |= d2;
   bytes[i * (SABER_N * 10) / 8 + 5 * j + 2] = (8u) d1;


   d1 = data[i * SABER_N + 4 * j + 2];
   d1 >>= 4;
   d1 &= 0x3f;
   d2 = data[i * SABER_N + 4 * j + 3];
   d2 &= 0x03;
   d2 <<= 6;
   d1 |= d2;
   bytes[i * (SABER_N * 10) / 8 + 5 * j + 3] = (8u) d1;


   d1 = data[i * SABER_N + 4 * j + 3];
   d1 >>= 2;
   d1 &= 0xff;
   bytes[i * (SABER_N * 10) / 8 + 5 * j + 4] = (8u) d1;
  }
 }

 return bytes;
}







inline fn POLVECq2BS(stack u8[SABER_POLYVECBYTES] bytes, stack u16[SABER_KN] data) -> stack u8[SABER_POLYVECBYTES]
{
 inline int i;
 inline int j;

 reg u16 d1;
 reg u16 d2;

 for i = 0 to SABER_K {
  for j = 0 to (SABER_N / 8) {



   d1 = data[i * SABER_N + 8 * j];
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j];
   d1 >>= 8;
   d1 &= 0x1f;
   d2 = data[i * SABER_N + 8 * j + 1];
   d2 &= 0x07;
   d2 <<= 5;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 1] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 1];
   d1 >>= 3;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 2] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 1];
   d1 >>= 11;
   d1 &= 0x03;
   d2 = data[i * SABER_N + 8 * j + 2];
   d2 &= 0x3f;
   d2 <<= 2;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 3] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 2];
   d1 >>= 6;
   d1 &= 0x7f;
   d2 = data[i * SABER_N + 8 * j + 3];
   d2 &= 0x01;
   d2 <<= 7;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 4] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 3];
   d1 >>= 1;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 5] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 3];
   d1 >>= 9;
   d1 &= 0x0f;
   d2 = data[i * SABER_N + 8 * j + 4];
   d2 &= 0x0f;
   d2 <<= 4;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 6] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 4];
   d1 >>= 4;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 7] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 4];
   d1 >>= 12;
   d1 &= 0x01;
   d2 = data[i * SABER_N + 8 * j + 5];
   d2 &= 0x7f;
   d2 <<= 1;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 8] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 5];
   d1 >>= 7;
   d1 &= 0x3f;
   d2 = data[i * SABER_N + 8 * j + 6];
   d2 &= 0x03;
   d2 <<= 6;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 9] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 6];
   d1 >>= 2;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 10] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 6];
   d1 >>= 10;
   d1 &= 0x07;
   d2 = data[i * SABER_N + 8 * j + 7];
   d2 &= 0x1f;
   d2 <<= 3;
   d1 |= d2;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 11] = (8u) d1;


   d1 = data[i * SABER_N + 8 * j + 7];
   d1 >>= 5;
   d1 &= 0xff;
   bytes[i * (SABER_N * 13) / 8 + 13 * j + 12] = (8u) d1;
  }
 }

 return bytes;
}







inline fn BS2POLVECp(stack u8[SABER_POLYVECCOMPRESSEDBYTES] bytes, stack u16[SABER_KN] data) -> stack u16[SABER_KN]
{
 inline int i;
 inline int j;

 reg u16 b1;
 reg u16 b2;

 for i = 0 to SABER_K {
  for j = 0 to (SABER_N / 4) {


   b1 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j];
   b1 &= 0xff;
   b2 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 1];
   b2 &= 0x03;
   b2 <<= 8;
   b1 |= b2;
   data[i * SABER_N + 4 * j] = b1;


   b1 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 1];
   b1 >>= 2;
   b1 &= 0x3f;
   b2 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 2];
   b2 &= 0x0f;
   b2 <<= 6;
   b1 |= b2;
   data[i * SABER_N + 4 * j + 1] = b1;


   b1 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 2];
   b1 >>= 4;
   b1 &= 0x0f;
   b2 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 3];
   b2 &= 0x3f;
   b2 <<= 4;
   b1 |= b2;
   data[i * SABER_N + 4 * j + 2] = b1;


   b1 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 3];
   b1 >>= 6;
   b1 &= 0x03;
   b2 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 4];
   b2 &= 0xff;
   b2 <<= 2;
   b1 |= b2;
   data[i * SABER_N + 4 * j + 3] = b1;
  }
 }

 return data;
}







inline fn BS2POLVECq(stack u8[SABER_POLYVECBYTES] bytes, stack u16[SABER_KN] data) -> stack u16[SABER_KN]
{
 inline int i;
 inline int j;

 reg u16 b1;
 reg u16 b2;
 reg u16 b3;

 for i = 0 to SABER_K {
  for j = 0 to (SABER_N / 8) {



   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j];
   b1 &= 0xff;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 1];
   b2 &= 0x1f;
   b2 <<= 8;
   b1 |= b2;
   data[i * SABER_N + 8 * j] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 1];
   b1 >>= 5;
   b1 &= 0x07;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 2];
   b2 &= 0xff;
   b2 <<= 3;
   b3 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 3];
   b3 &= 0x03;
   b3 <<= 11;
   b2 |= b3;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 1] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 3];
   b1 >>= 2;
   b1 &= 0x3f;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 4];
   b2 &= 0x7f;
   b2 <<= 6;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 2] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 4];
   b1 >>= 7;
   b1 &= 0x01;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 5];
   b2 &= 0xff;
   b2 <<= 1;
   b3 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 6];
   b3 &= 0x0f;
   b3 <<= 9;
   b2 |= b3;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 3] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 6];
   b1 >>= 4;
   b1 &= 0x0f;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 7];
   b2 &= 0xff;
   b2 <<= 4;
   b3 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 8];
   b3 &= 0x01;
   b3 <<= 12;
   b2 |= b3;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 4] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 8];
   b1 >>= 1;
   b1 &= 0x7f;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 9];
   b2 &= 0x3f;
   b2 <<= 7;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 5] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 9];
   b1 >>= 6;
   b1 &= 0x03;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 10];
   b2 &= 0xff;
   b2 <<= 2;
   b3 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 11];
   b3 &= 0x07;
   b3 <<= 10;
   b2 |= b3;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 6] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 11];
   b1 >>= 3;
   b1 &= 0x1f;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 12];
   b2 &= 0xff;
   b2 <<= 5;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 7] = b1;
  }
 }

 return data;
}







inline fn BS2POL(stack u8[SABER_POLYBYTES] bytes, stack u16[SABER_N] data) -> stack u16[SABER_N]
{
 inline int j;

 reg u16 b1;
 reg u16 b2;
 reg u16 b3;


 for j = 0 to (SABER_N / 8) {

  b1 = (16u) bytes[13 * j];
  b1 &= 0xff;
  b2 = (16u) bytes[13 * j + 1];
  b2 &= 0x1f;
  b2 <<= 8;
  b1 |= b2;
  data[8 * j] = b1;


  b1 = (16u) bytes[13 * j + 1];
  b1 >>= 5;
  b1 &= 0x07;
  b2 = (16u) bytes[13 * j + 2];
  b2 &= 0xff;
  b2 <<= 3;
  b3 = (16u) bytes[13 * j + 3];
  b3 &= 0x03;
  b3 <<= 11;
  b2 |= b3;
  b1 |= b2;
  data[8 * j + 1] = b1;


  b1 = (16u) bytes[13 * j + 3];
  b1 >>= 2;
  b1 &= 0x3f;
  b2 = (16u) bytes[13 * j + 4];
  b2 &= 0x7f;
  b2 <<= 6;
  b1 |= b2;
  data[8 * j + 2] = b1;


  b1 = (16u) bytes[13 * j + 4];
  b1 >>= 7;
  b1 &= 0x01;
  b2 = (16u) bytes[13 * j + 5];
  b2 &= 0xff;
  b2 <<= 1;
  b3 = (16u) bytes[13 * j + 6];
  b3 &= 0x0f;
  b3 <<= 9;
  b2 |= b3;
  b1 |= b2;
  data[8 * j + 3] = b1;


  b1 = (16u) bytes[13 * j + 6];
  b1 >>= 4;
  b1 &= 0x0f;
  b2 = (16u) bytes[13 * j + 7];
  b2 &= 0xff;
  b2 <<= 4;
  b3 = (16u) bytes[13 * j + 8];
  b3 &= 0x01;
  b3 <<= 12;
  b2 |= b3;
  b1 |= b2;
  data[8 * j + 4] = b1;


  b1 = (16u) bytes[13 * j + 8];
  b1 >>= 1;
  b1 &= 0x7f;
  b2 = (16u) bytes[13 * j + 9];
  b2 &= 0x3f;
  b2 <<= 7;
  b1 |= b2;
  data[8 * j + 5] = b1;


  b1 = (16u) bytes[13 * j + 9];
  b1 >>= 6;
  b1 &= 0x03;
  b2 = (16u) bytes[13 * j + 10];
  b2 &= 0xff;
  b2 <<= 2;
  b3 = (16u) bytes[13 * j + 11];
  b3 &= 0x07;
  b3 <<= 10;
  b2 |= b3;
  b1 |= b2;
  data[8 * j + 6] = b1;


  b1 = (16u) bytes[13 * j + 11];
  b1 >>= 3;
  b1 &= 0x1f;
  b2 = (16u) bytes[13 * j + 12];
  b2 &= 0xff;
  b2 <<= 5;
  b1 |= b2;
  data[8 * j + 7] = b1;
 }

 return data;
}

export fn SABER_pack_4bit_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_SCALEBYTES_KEM] bytes;
 stack u16[SABER_N] data;


 for i = 0 to SABER_SCALEBYTES_KEM {
  tb = (u8) [bytesp + i];
  bytes[i] = tb;
 }

 for i = 0 to SABER_N {
  td = (u16) [datap + 2 * i];
  data[i] = td;
 }

 bytes = SABER_pack_4bit(bytes, data);

 for i = 0 to SABER_SCALEBYTES_KEM {
  tb = bytes[i];
  (u8) [bytesp + i] = tb;
 }
}

export fn SABER_un_pack4bit_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_SCALEBYTES_KEM] bytes;
 stack u16[SABER_N] data;

 for i = 0 to SABER_SCALEBYTES_KEM {
  tb = (u8) [bytesp + i];
  bytes[i] = tb;
 }


 for i = 0 to SABER_N {
  td = (u16) [datap + 2 * i];
  data[i] = td;
 }

 data = SABER_un_pack4bit(bytes, data);

 for i = 0 to SABER_N {
  td = data[i];
  (u16) [datap + 2 * i] = td;
 }
}

export fn POLVECp2BS_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_POLYVECCOMPRESSEDBYTES] bytes;
 stack u16[SABER_KN] data;


 for i = 0 to SABER_POLYVECCOMPRESSEDBYTES {
  tb = (u8) [bytesp + i];
  bytes[i] = tb;
 }

 for i = 0 to SABER_KN {
  td = (u16) [datap + 2 * i];
  data[i] = td;
 }

 bytes = POLVECp2BS(bytes, data);

 for i = 0 to SABER_POLYVECCOMPRESSEDBYTES {
  tb = bytes[i];
  (u8) [bytesp + i] = tb;
 }
}

export fn POLVECq2BS_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_POLYVECBYTES] bytes;
 stack u16[SABER_KN] data;


 for i = 0 to SABER_POLYVECBYTES {
  tb = (u8) [bytesp + i];
  bytes[i] = tb;
 }

 for i = 0 to SABER_KN {
  td = (u16) [datap + 2 * i];
  data[i] = td;
 }

 bytes = POLVECq2BS(bytes, data);

 for i = 0 to SABER_POLYVECBYTES {
  tb = bytes[i];
  (u8) [bytesp + i] = tb;
 }
}

export fn BS2POLVECp_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_POLYVECCOMPRESSEDBYTES] bytes;
 stack u16[SABER_KN] data;


 for i = 0 to SABER_POLYVECCOMPRESSEDBYTES {
  tb = (u8) [bytesp + i];
  bytes[i] = tb;
 }


 for i = 0 to SABER_KN {
  td = (u16) [datap + 2 * i];
  data[i] = td;
 }

 data = BS2POLVECp(bytes, data);

 for i = 0 to SABER_KN {
  td = data[i];
  (u16) [datap + 2 * i] = td;
 }
}

export fn BS2POLVECq_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_POLYVECBYTES] bytes;
 stack u16[SABER_KN] data;


 for i = 0 to SABER_POLYVECBYTES {
  tb = (u8) [bytesp + i];
  bytes[i] = tb;
 }


 for i = 0 to SABER_KN {
  td = (u16) [datap + 2 * i];
  data[i] = td;
 }

 data = BS2POLVECq(bytes, data);

 for i = 0 to SABER_KN {
  td = data[i];
  (u16) [datap + 2 * i] = td;
 }
}

export fn BS2POL_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_POLYBYTES] bytes;
 stack u16[SABER_N] data;


 for i = 0 to SABER_POLYBYTES {
  tb = (u8) [bytesp + i];
  bytes[i] = tb;
 }


 for i = 0 to SABER_N {
  td = (u16) [datap + 2 * i];
  data[i] = td;
 }

 data = BS2POL(bytes, data);

 for i = 0 to SABER_N {
  td = data[i];
  (u16) [datap + 2 * i] = td;
 }
}
