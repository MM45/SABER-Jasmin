








param int CRYPTO_SECRETKEYBYTES = 2304;
param int CRYPTO_PUBLICKEYBYTES = (3 * 320 + 32);
param int CRYPTO_BYTES = 32;
param int CRYPTO_CIPHERTEXTBYTES = 1088;
param int Saber_type = 2;

param int SABER_K = 3;
param int SABER_MU = 8;
param int SABER_ET = 4;

param int SABER_EQ = 13;
param int SABER_EP = 10;

param int SABER_N = 256;
param int SABER_Q = 8192;
param int SABER_P = 1024;

param int SABER_SEEDBYTES = 32;
param int SABER_NOISESEEDBYTES = 32;
param int SABER_COINBYTES = 32;
param int SABER_KEYBYTES = 32;

param int SABER_HASHBYTES = 32;

param int SABER_POLYBYTES = 416;

param int SABER_POLYVECBYTES = (SABER_K * SABER_POLYBYTES);

param int SABER_POLYVECCOMPRESSEDBYTES = (SABER_K * 320);

param int SABER_CIPHERTEXTBYTES = (SABER_POLYVECCOMPRESSEDBYTES);



param int SABER_SCALEBYTES_KEM = (SABER_ET * SABER_N / 8);

param int SABER_INDCPA_PUBLICKEYBYTES = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SEEDBYTES);
param int SABER_INDCPA_SECRETKEYBYTES = (SABER_POLYVECBYTES);

param int SABER_PUBLICKEYBYTES = (SABER_INDCPA_PUBLICKEYBYTES);

param int SABER_SECRETKEYBYTES = (SABER_INDCPA_SECRETKEYBYTES + SABER_INDCPA_PUBLICKEYBYTES + SABER_HASHBYTES + SABER_KEYBYTES);

param int SABER_BYTES_CCA_DEC = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SCALEBYTES_KEM);



param int SABER_KN = (SABER_K * SABER_N);
param int SABER_KKN = (SABER_K * SABER_K * SABER_N);
param int N_SB = (SABER_N / 4);
param int N_SB_RES = (2 * N_SB - 1);

param int SHAKE128_RATE = 168;
param int SHAKE256_RATE = 136;
param int SHA3_256_RATE = 136;
param int SHA3_512_RATE = 72;

param int KK13N8 = (SABER_K * SABER_K * (13 * SABER_N / 8));
param int MUNK8 = (SABER_MU * SABER_N * SABER_K / 8);

param int h1 = 4;
param int h2 = 228;


















fn BS2POLVECp(reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u16[SABER_KN]
{
 inline int i;
 inline int j;

 reg u16 b1;
 reg u16 b2;

 for i = 0 to SABER_K {
  for j = 0 to (SABER_N / 4) {


   b1 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j];
   b1 &= 0xff;
   b2 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 1];
   b2 &= 0x03;
   b2 <<= 8;
   b1 |= b2;
   data[i * SABER_N + 4 * j] = b1;


   b1 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 1];
   b1 >>= 2;
   b1 &= 0x3f;
   b2 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 2];
   b2 &= 0x0f;
   b2 <<= 6;
   b1 |= b2;
   data[i * SABER_N + 4 * j + 1] = b1;


   b1 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 2];
   b1 >>= 4;
   b1 &= 0x0f;
   b2 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 3];
   b2 &= 0x3f;
   b2 <<= 4;
   b1 |= b2;
   data[i * SABER_N + 4 * j + 2] = b1;


   b1 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 3];
   b1 >>= 6;
   b1 &= 0x03;
   b2 = (16u) bytes[i * (SABER_N * 10) / 8 + 5 * j + 4];
   b2 &= 0xff;
   b2 <<= 2;
   b1 |= b2;
   data[i * SABER_N + 4 * j + 3] = b1;
  }
 }

 return data;
}







inline fn BS2POLVECq(reg ptr u8[SABER_POLYVECBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u16[SABER_KN]
{
 inline int i;
 inline int j;

 reg u16 b1;
 reg u16 b2;
 reg u16 b3;

 for i = 0 to SABER_K {
  for j = 0 to (SABER_N / 8) {



   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j];
   b1 &= 0xff;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 1];
   b2 &= 0x1f;
   b2 <<= 8;
   b1 |= b2;
   data[i * SABER_N + 8 * j] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 1];
   b1 >>= 5;
   b1 &= 0x07;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 2];
   b2 &= 0xff;
   b2 <<= 3;
   b3 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 3];
   b3 &= 0x03;
   b3 <<= 11;
   b2 |= b3;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 1] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 3];
   b1 >>= 2;
   b1 &= 0x3f;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 4];
   b2 &= 0x7f;
   b2 <<= 6;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 2] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 4];
   b1 >>= 7;
   b1 &= 0x01;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 5];
   b2 &= 0xff;
   b2 <<= 1;
   b3 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 6];
   b3 &= 0x0f;
   b3 <<= 9;
   b2 |= b3;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 3] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 6];
   b1 >>= 4;
   b1 &= 0x0f;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 7];
   b2 &= 0xff;
   b2 <<= 4;
   b3 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 8];
   b3 &= 0x01;
   b3 <<= 12;
   b2 |= b3;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 4] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 8];
   b1 >>= 1;
   b1 &= 0x7f;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 9];
   b2 &= 0x3f;
   b2 <<= 7;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 5] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 9];
   b1 >>= 6;
   b1 &= 0x03;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 10];
   b2 &= 0xff;
   b2 <<= 2;
   b3 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 11];
   b3 &= 0x07;
   b3 <<= 10;
   b2 |= b3;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 6] = b1;


   b1 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 11];
   b1 >>= 3;
   b1 &= 0x1f;
   b2 = (16u) bytes[i * (SABER_N * 13) / 8 + 13 * j + 12];
   b2 &= 0xff;
   b2 <<= 5;
   b1 |= b2;
   data[i * SABER_N + 8 * j + 7] = b1;
  }
 }

 return data;
}







inline fn SABER_un_pack4bit(reg ptr u8[SABER_SCALEBYTES_KEM] bytes, reg ptr u16[SABER_N] ar) -> reg ptr u16[SABER_N]
{
 inline int j;

 reg u16 b1;

 for j = 0 to (SABER_N / 2) {

  b1 = (16u) bytes[j];
  b1 &= 0x0f;
  ar[2 * j] = b1;


  b1 = (16u) bytes[j];
  b1 >>= 4;
  b1 &= 0x0f;
  ar[2 * j + 1] = b1;
 }

 return ar;
}

























fn karatsuba_simple(reg ptr u16[N_SB] a_1, reg ptr u16[N_SB] b_1, reg ptr u16[N_SB_RES] result_final) -> reg ptr u16[N_SB_RES]
{
 inline int i;
 inline int j;
 inline int N;

 reg u16 acc1;
 reg u16 acc2;
 reg u16 acc3;
 reg u16 acc4;
 reg u16 acc5;
 reg u16 acc6;
 reg u16 acc7;
 reg u16 acc8;
 reg u16 acc9;
 reg u16 acc10;
 reg u16 t16;

 stack u16[64 / 2 - 1] d01;
 stack u16[64 / 2 - 1] d0123;
 stack u16[64 / 2 - 1] d23;
 stack u16[64 - 1] result_d01;

 N = 64;


 for i = 0 to (N / 2 - 1) {
  d01[i] = 0;
  d0123[i] = 0;
  d23[i] = 0;
  result_d01[i] = 0;
  result_final[i] = 0;
 }

 for i = (N / 2 - 1) to (N - 1) {
  result_d01[i] = 0;
  result_final[i] = 0;
 }

 for i = (N - 1) to (2 * N - 1) {
  result_final[i] = 0;
 }


 for i = 0 to (N / 4) {
  acc1 = a_1[i];
  acc2 = a_1[i + N / 4];
  acc3 = a_1[i + 2 * N / 4];
  acc4 = a_1[i + 3 * N / 4];

  for j = 0 to (N / 4) {
   acc5 = b_1[j];
   acc6 = b_1[j + N / 4];


   t16 = acc1;
   t16 *= acc5;
   t16 += result_final[i + j];
   result_final[i + j] = t16;


   t16 = acc2;
   t16 *= acc6;
   t16 += result_final[i + j + 2 * N / 4];
   result_final[i + j + 2 * N / 4] = t16;

   acc7 = acc5 + acc6;
   acc8 = acc1 + acc2;


   t16 = acc7;
   t16 *= acc8;
   t16 += d01[i + j];
   d01[i + j] = t16;

   acc7 = b_1[j + 2 * N / 4];
   acc8 = b_1[j + 3 * N / 4];


   t16 = acc7;
   t16 *= acc3;
   t16 += result_final[i + j + 4 * N / 4];
   result_final[i + j + 4 * N / 4] = t16;


   t16 = acc8;
   t16 *= acc4;
   t16 += result_final[i + j + 6 * N / 4];
   result_final[i + j + 6 * N / 4] = t16;

   acc9 = acc3 + acc4;
   acc10 = acc7 + acc8;


   t16 = acc9;
   t16 *= acc10;
   t16 += d23[i + j];
   d23[i + j] = t16;

   acc5 = acc5 + acc7;
   acc7 = acc1 + acc3;


   t16 = acc5;
   t16 *= acc7;
   t16 += result_d01[i + j];
   result_d01[i + j] = t16;

   acc6 = acc6 + acc8;
   acc8 = acc2 + acc4;


   t16 = acc6;
   t16 *= acc8;
   t16 += result_d01[i + j + 2 * N / 4];
   result_d01[i + j + 2 * N / 4] = t16;

   acc5 = acc5 + acc6;
   acc7 = acc7 + acc8;


   t16 = acc5;
   t16 *= acc7;
   t16 += d0123[i + j];
   d0123[i + j] = t16;
  }
 }

 for i = 0 to N / 2 - 1 {

  t16 = d0123[i];
  t16 -= result_d01[i];
  t16 -= result_d01[i + 2 * N / 4];
  d0123[i] = t16;


  t16 = d01[i];
  t16 -= result_final[i];
  t16 -= result_final[i + 2 * N / 4];
  d01[i] = t16;


  t16 = d23[i];
  t16 -= result_final[i + 4 * N / 4];
  t16 -= result_final[i + 6 * N / 4];
  d23[i] = t16;
 }

 for i = 0 to N / 2 -1 {

  t16 = result_d01[i + N / 4];
  t16 += d0123[i];
  result_d01[i + N / 4] = t16;


  t16 = result_final[i + N / 4];
  t16 += d01[i];
  result_final[i + N / 4] = t16;


  t16 = result_final[i + 5 * N / 4];
  t16 += d23[i];
  result_final[i + 5 * N / 4] = t16;
 }

 for i = 0 to N - 1 {

  t16 = result_d01[i];
  t16 -= result_final[i];
  t16 -= result_final[i + N];
  result_d01[i] = t16;
 }

 for i = 0 to N - 1 {

  t16 = result_final[i + N / 2];
  t16 += result_d01[i];
  result_final[i + N / 2] = t16;
 }

 return result_final;
}

inline fn toom_cook_4way(reg ptr u16[SABER_N] a1, reg ptr u16[SABER_N] b1, reg ptr u16[512] result) -> reg ptr u16[512]
{
 inline int i;
 inline int j;

 inline int AB0;
 inline int AB1;
 inline int AB2;
 inline int AB3;

 reg u16 r0;
 reg u16 r1;
 reg u16 r2;
 reg u16 r3;
 reg u16 r4;
 reg u16 r5;
 reg u16 r6;
 reg u16 r7;

 reg u16 t1;
 reg u16 t2;

 reg u32 p1;
 reg u32 p2;

 stack u16[N_SB] aw1;
 stack u16[N_SB] aw2;
 stack u16[N_SB] aw3;
 stack u16[N_SB] aw4;
 stack u16[N_SB] aw5;
 stack u16[N_SB] aw6;
 stack u16[N_SB] aw7;

 stack u16[N_SB] bw1;
 stack u16[N_SB] bw2;
 stack u16[N_SB] bw3;
 stack u16[N_SB] bw4;
 stack u16[N_SB] bw5;
 stack u16[N_SB] bw6;
 stack u16[N_SB] bw7;

 stack u16[N_SB_RES] w1;
 stack u16[N_SB_RES] w2;
 stack u16[N_SB_RES] w3;
 stack u16[N_SB_RES] w4;
 stack u16[N_SB_RES] w5;
 stack u16[N_SB_RES] w6;
 stack u16[N_SB_RES] w7;

 stack ptr u16[512] sresult;

 AB0 = 0;
 AB1 = N_SB;
 AB2 = 2 * N_SB;
 AB3 = 3 * N_SB;

 for i = 0 to N_SB_RES {
  w1[i] = 0;
  w2[i] = 0;
  w3[i] = 0;
  w4[i] = 0;
  w5[i] = 0;
  w6[i] = 0;
  w7[i] = 0;
 }

 for j = 0 to N_SB {
  r0 = a1[AB0 + j];
  r1 = a1[AB1 + j];
  r2 = a1[AB2 + j];
  r3 = a1[AB3 + j];
  r4 = r0 + r2;
  r5 = r1 + r3;
  r6 = r4 + r5;
  r7 = r4;
  r7 -= r5;

  aw3[j] = r6;
  aw4[j] = r7;


  t1 = r0;
  t1 <<= 2;
  t1 += r2;
  t1 <<= 1;
  r4 = t1;


  t1 = r1;
  t1 <<= 2;
  t1 += r3;
  r5 = t1;

  r6 = r4 + r5;
  r7 = r4;
  r7 -= r5;

  aw5[j] = r6;
  aw6[j] = r7;


  t1 = r3;
  t1 <<= 3;
  t2 = r2;
  t2 <<= 2;
  t1 += t2;
  t2 = r1;
  t2 <<= 1;
  t1 += t2;
  t1 += r0;
  r4 = t1;

  aw2[j] = r4;
  aw7[j] = r0;
  aw1[j] = r3;
 }

 for j = 0 to N_SB {
  r0 = b1[AB0 + j];
  r1 = b1[AB1 + j];
  r2 = b1[AB2 + j];
  r3 = b1[AB3 + j];
  r4 = r0 + r2;
  r5 = r1 + r3;
  r6 = r4 + r5;
  r7 = r4;
  r7 -= r5;

  bw3[j] = r6;
  bw4[j] = r7;


  t1 = r0;
  t1 <<= 2;
  t1 += r2;
  t1 <<= 1;
  r4 = t1;


  t1 = r1;
  t1 <<= 2;
  t1 += r3;
  r5 = t1;

  r6 = r4 + r5;
  r7 = r4;
  r7 -= r5;

  bw5[j] = r6;
  bw6[j] = r7;


  t1 = r3;
  t1 <<= 3;
  t2 = r2;
  t2 <<= 2;
  t1 += t2;
  t2 = r1;
  t2 <<= 1;
  t1 += t2;
  t1 += r0;
  r4 = t1;

  bw2[j] = r4;
  bw7[j] = r0;
  bw1[j] = r3;
 }

 sresult = result;

 w1 = karatsuba_simple(aw1, bw1, w1);
 w2 = karatsuba_simple(aw2, bw2, w2);
 w3 = karatsuba_simple(aw3, bw3, w3);
 w4 = karatsuba_simple(aw4, bw4, w4);
 w5 = karatsuba_simple(aw5, bw5, w5);
 w6 = karatsuba_simple(aw6, bw6, w6);
 w7 = karatsuba_simple(aw7, bw7, w7);

 result = sresult;

 for i = 0 to N_SB_RES {
  r0 = w1[i];
  r1 = w2[i];
  r2 = w3[i];
  r3 = w4[i];
  r4 = w5[i];
  r5 = w6[i];
  r6 = w7[i];

  r1 += r4;
  r5 -= r4;


  p1 = (32u) r3;

  p2 = (32u) r2;

  p1 -= p2;
  p1 >>= 1;
  r3 = (16u) p1;

  r4 -= r0;


  t1 = r6;
  t1 <<= 6;
  r4 -= t1;


   r4 <<= 1;
   r4 += r5;

   r2 += r3;


   t1 = r2;
   t1 <<= 6;
   r1 -= t1;
   r1 -= r2;

   r2 -= r6;
   r2 -= r0;


   t1 = 45 * r2;
   r1 += t1;


   p1 = (32u) r2;

   p1 <<= 3;
   p2 = (32u) r4;

   p2 -= p1;
   p2 *= 43691;
   p2 >>= 3;
   r4 = (16u) p2;

   r5 += r1;


   p1 = (32u) r3;

   p1 <<= 4;
   p2 = (32u) r1;

   p2 += p1;
   p2 *= 36409;
   p2 >>= 1;
   r1 = (16u) p2;


   p1 = (32u) r3;

   p2 = (32u) r1;

   p1 += p2;
   p1 *= -1;
   r3 = (16u) p1;


   p1 = (32u) r1;

   p1 *= 30;
   p2 = (32u) r5;

   p1 -= p2;
   p1 *= 61167;
   p1 >>= 2;
   r5 = (16u) p1;

   r2 -= r4;
   r1 -= r5;

   result[i] += r6;
   result[i + 64] += r5;
   result[i + 128] += r4;
   result[i + 192] += r3;
   result[i + 256] += r2;
   result[i + 320] += r1;
   result[i + 384] += r0;
 }

 return result;
}

fn pol_mul_p(reg ptr u16[SABER_N] a, reg ptr u16[SABER_N] b, reg ptr u16[SABER_N] res) -> reg ptr u16[SABER_N]
{
 inline int i;

 reg u16 t16;

 stack u16[512] c;

 stack ptr u16[SABER_N] sres;

 for i = 0 to 512 {
  c[i] = 0;
 }

 sres = res;

 c = toom_cook_4way(a, b, c);

 res = sres;

 for i = SABER_N to 2 * SABER_N {

  t16 = c[i - SABER_N];
  t16 -= c[i];
  res[i - SABER_N] = t16;
  t16 = SABER_P - 1;
  res[i - SABER_N] &= t16;
 }

 return res;
}

inline fn InnerProd(reg ptr u16[SABER_KN] pkcl, reg ptr u16[SABER_KN] skpv, reg ptr u16[SABER_N] res) -> reg ptr u16[SABER_N]
{
 inline int j;
 inline int k;

 reg u16 t;

 stack u16[SABER_N] acc;

 stack u16[SABER_N] ta;
 stack u16[SABER_N] tb;

 stack ptr u16[SABER_KN] spkcl;
 stack ptr u16[SABER_KN] sskpv;
 stack ptr u16[SABER_N] sres;

 for j = 0 to SABER_K {

  for k = 0 to SABER_N {
   t = pkcl[j * SABER_N + k];
   ta[k] = t;

   t = skpv[j * SABER_N + k];
   tb[k] = t;
  }

  spkcl = pkcl;
  sskpv = skpv;
  sres = res;

  acc = pol_mul_p(ta, tb, acc);

  pkcl = spkcl;
  skpv = sskpv;
  res = sres;

  for k = 0 to SABER_N {
   t = acc[k];
   res[k] += t;
   res[k] &= (SABER_P - 1);
   acc[k] = 0;
  }
 }

 return res;
}







inline fn POL2MSG(stack u16[SABER_N] message_dec_unpacked, stack u8[SABER_KEYBYTES] message_dec) -> stack u8[SABER_KEYBYTES]
{
 inline int i;
 inline int j;

 reg u8 t8;

 reg u16 t16;


 for j = 0 to SABER_KEYBYTES {
  message_dec[j] = 0;

  for i = 0 to 8 {
   t16 = message_dec_unpacked[j * 8 + i];
   t16 <<= i;
   t8 = (8u) t16;
   message_dec[j] |= t8;
  }
 }

 return message_dec;
}


inline fn indcpa_kem_dec(stack u8[SABER_INDCPA_SECRETKEYBYTES] sk, stack u8[SABER_BYTES_CCA_DEC] ciphertext, stack u8[SABER_KEYBYTES] message_dec) -> stack u8[SABER_KEYBYTES]
{
 inline int i;
 inline int j;

 reg u8 t8;

 reg u16 t16;

 stack u8[SABER_POLYVECCOMPRESSEDBYTES] tciphertext;
 stack u8[SABER_SCALEBYTES_KEM] scale_ar;

 stack u16[SABER_KN] sksv;
 stack u16[SABER_KN] pksv;
 stack u16[SABER_N] v;
 stack u16[SABER_N] op;


 for i = 0 to SABER_POLYVECCOMPRESSEDBYTES {
  t8 = ciphertext[i];
  tciphertext[i] = t8;
 }

 sksv = BS2POLVECq(sk, sksv);

 pksv = BS2POLVECp(tciphertext, pksv);

 for i = 0 to SABER_N {
  v[i] = 0;
 }

 for i = 0 to SABER_K {
  for j = 0 to SABER_N {
   sksv[i * SABER_N + j] &= (SABER_P - 1);
  }
 }

 v = InnerProd(pksv, sksv, v);

 for i = 0 to SABER_SCALEBYTES_KEM {
  t8 = ciphertext[SABER_POLYVECCOMPRESSEDBYTES + i];
  scale_ar[i] = t8;
 }

 op = SABER_un_pack4bit(scale_ar, op);

 for i = 0 to SABER_N {

  t16 = op[i];
  t16 <<= (SABER_EP-SABER_ET);
  v[i] += h2;
  v[i] -= t16;
  v[i] &= (SABER_P - 1);
  v[i] >>= (SABER_EP - 1);
 }

 message_dec = POL2MSG(v, message_dec);

 return message_dec;
}
export fn indcpa_kem_dec_jazz(reg u64 skp, reg u64 ciphertextp, reg u64 message_decp)
{
 inline int i;

 reg u8 t8;

 stack u8[SABER_INDCPA_SECRETKEYBYTES] sk;
 stack u8[SABER_BYTES_CCA_DEC] ciphertext;
 stack u8[SABER_KEYBYTES] message_dec;

 stack u64 smessage_decp;

 for i = 0 to SABER_INDCPA_SECRETKEYBYTES {
  t8 = (u8) [skp + i];
  sk[i] = t8;
 }

 for i = 0 to SABER_BYTES_CCA_DEC {
  t8 = (u8) [ciphertextp + i];
  ciphertext[i] = t8;
 }

 for i = 0 to SABER_KEYBYTES {
  t8 = (u8) [message_decp + i];
  message_dec[i] = t8;
 }

 smessage_decp = message_decp;

 message_dec = indcpa_kem_dec(sk, ciphertext, message_dec);

 message_decp = smessage_decp;

 for i = 0 to SABER_KEYBYTES {
  t8 = message_dec[i];
  (u8) [message_decp + i] = t8;
 }
}
