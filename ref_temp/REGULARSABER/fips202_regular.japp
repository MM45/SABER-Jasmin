








param int CRYPTO_SECRETKEYBYTES = 2304;
param int CRYPTO_PUBLICKEYBYTES = (3 * 320 + 32);
param int CRYPTO_BYTES = 32;
param int CRYPTO_CIPHERTEXTBYTES = 1088;
param int Saber_type = 2;

param int SABER_K = 3;
param int SABER_MU = 8;
param int SABER_ET = 4;

param int SABER_EQ = 13;
param int SABER_EP = 10;

param int SABER_N = 256;
param int SABER_Q = 8192;
param int SABER_P = 1024;

param int SABER_SEEDBYTES = 32;
param int SABER_NOISESEEDBYTES = 32;
param int SABER_COINBYTES = 32;
param int SABER_KEYBYTES = 32;

param int SABER_HASHBYTES = 32;

param int SABER_POLYBYTES = 416;

param int SABER_POLYVECBYTES = (SABER_K * SABER_POLYBYTES);

param int SABER_POLYVECCOMPRESSEDBYTES = (SABER_K * 320);

param int SABER_CIPHERTEXTBYTES = (SABER_POLYVECCOMPRESSEDBYTES);



param int SABER_SCALEBYTES_KEM = (SABER_ET * SABER_N / 8);

param int SABER_INDCPA_PUBLICKEYBYTES = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SEEDBYTES);
param int SABER_INDCPA_SECRETKEYBYTES = (SABER_POLYVECBYTES);

param int SABER_PUBLICKEYBYTES = (SABER_INDCPA_PUBLICKEYBYTES);

param int SABER_SECRETKEYBYTES = (SABER_INDCPA_SECRETKEYBYTES + SABER_INDCPA_PUBLICKEYBYTES + SABER_HASHBYTES + SABER_KEYBYTES);

param int SABER_BYTES_CCA_DEC = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SCALEBYTES_KEM);



param int SABER_KN = (SABER_K * SABER_N);
param int SABER_KKN = (SABER_K * SABER_K * SABER_N);
param int N_SB = (SABER_N / 4);
param int N_SB_RES = (2 * N_SB - 1);

param int SHAKE128_RATE = 168;
param int SHAKE256_RATE = 136;
param int SHA3_256_RATE = 136;
param int SHA3_512_RATE = 72;

param int KK13N8 = (SABER_K * SABER_K * (13 * SABER_N / 8));
param int MUNK8 = (SABER_MU * SABER_N * SABER_K / 8);

param int h1 = 4;
param int h2 = 228;










inline fn load64(reg ptr u8[8] x) -> reg u64
{
 inline int i;

 reg u64 r;
 reg u64 t;

 r = (64u) x[0];

 for i = 1 to 8 {
  t = (64u) x[i];
  t <<= (8 * i);
  r |= t;
 }

 return r;
}

fn keccak_absorb_128_32(reg ptr u64[25] s, reg ptr u8[32] m) -> reg ptr u64[25]
{
 inline int i;

 reg u8 t8;

 reg u64 t64;

 stack u8[200] t;

 for i = 0 to SHAKE128_RATE {
  t[i] = 0;
 }

 for i = 0 to 32 {
  t8 = m[i];
  t[i] = t8;
 }

 t[32] = 0x1F;
 t[SHAKE128_RATE - 1] |= 128;

 for i = 0 to (SHAKE128_RATE / 8) {
  t64 = load64(t[8 * i:8]);
  s[i] ^= t64;
 }

 return s;
}
inline fn keccak_absorb_256_32(reg ptr u64[25] s, reg ptr u8[32] m) -> reg ptr u64[25]
{
 inline int i;

 reg u8 t8;

 reg u64 t64;

 stack u8[200] t;

 for i = 0 to SHA3_256_RATE {
  t[i] = 0;
 }

 for i = 0 to 32 {
  t8 = m[i];
  s[u8 i] ^= t8;
 }

 s[u8 32] ^= 0x06;
 s[u8 SHA3_256_RATE - 1] ^= 128;






 return s;
}
inline fn keccak_absorb_256_64(reg ptr u64[25] s, reg ptr u8[64] m) -> reg ptr u64[25]
{
 inline int i;

 reg u8 t8;

 reg u64 t64;

 stack u8[200] t;

 for i = 0 to SHA3_256_RATE {
  t[i] = 0;
 }

 for i = 0 to 64 {
  t8 = m[i];
  t[i] = t8;
 }

 t[64] = 0x06;
 t[SHA3_256_RATE - 1] |= 128;

 for i = 0 to (SHA3_256_RATE / 8) {
  t64 = load64(t[8 * i:8]);
  s[i] ^= t64;
 }

 return s;
}
inline fn keccak_absorb_512_64(reg ptr u64[25] s, reg ptr u8[64] m) -> reg ptr u64[25]
{
 inline int i;
 inline int j;

 reg u8 t8;

 reg u64 t64;
 reg u64 tt;

 stack u8[200] t;

 for i = 0 to SHA3_512_RATE {
  t[i] = 0;
 }

 for i = 0 to 64 {
  t8 = m[i];
  t[i] = t8;
 }

 t[64] = 0x06;
 t[SHA3_512_RATE - 1] |= 128;

 for i = 0 to (SHA3_512_RATE / 8) {
  t64 = load64(t[8 * i:8]);
  s[i] ^= t64;
 }

 return s;
}











inline fn index(inline int x, inline int y) -> inline int {
  inline int r;
  r = (x % 5) + 5 * (y % 5);
  return r;
}


inline fn ROL64(reg u64 x, inline int c) -> reg u64 {
  reg u64 y;
  _, _, y = #ROL_64(x, c);
  return y;
}

inline fn theta(reg ptr u64[25] a) -> reg ptr u64[25] {
  inline int x, y;
  reg u64[5] c, d;

  for x = 0 to 5 {
    c[x] = 0;
    for y = 0 to 5 {
      c[x] ^= a[x + 5 * y];
    }
  }

  for x = 0 to 5 {







    d[x] = c[(x + 1) % 5];
    _, _, d[x] = #ROL_64(d[x], 1);
    d[x] ^= c[(x + 4) % 5];
  }

  for x = 0 to 5 {
    for y = 0 to 5 {
      a[x + 5 * y] ^= d[x];
    }
  }

  return a;
}


inline fn keccakRhoOffsets(inline int i) -> inline int {
  inline int r, x, y, z, t;

  r = 0;
  x = 1;
  y = 0;
  for t = 0 to 24 {
    if (i == x + 5 * y) {
      r = ((t + 1) * (t + 2) / 2) % 64;
    }
    z = (2 * x + 3 * y) % 5;
    x = y;
    y = z;
  }

  return r;
}


inline fn rho(reg ptr u64[25] a) -> reg ptr u64[25] {
  inline int x, y, i, z;

  for x = 0 to 5 {
    for y = 0 to 5 {
      i = index(x, y);
      z = keccakRhoOffsets(i);
      _, _, a[i] = #ROL_64(a[i], z);
    }
  }

  return a;
}


inline fn pi(reg ptr u64[25] a) -> reg ptr u64[25] {
  stack u64[25] b;
  reg u64 t;
  inline int x, y, i;
  for i = 0 to 25 { t = a[i]; b[i] = t; }

  for x = 0 to 5 {
    for y = 0 to 5 {
      t = b[x + 5 * y];
      i = index(y, 2 * x + 3 * y);
      a[i] = t;
    }
  }
  return a;
}


inline fn chi(reg ptr u64[25] a) -> reg ptr u64[25] {
  inline int x, y, i;
  reg u64[5] c;
  for y = 0 to 5 {
    for x = 0 to 5 {
      i = index(x + 1, y);
      c[x] = a[i];
      c[x] = !c[x];
      i = index(x + 2, y);
      c[x] &= a[i];
      i = index(x, y);
      c[x] ^= a[i];
    }
    for x = 0 to 5 {
      a[x + 5 * y] = c[x];
    }
  }
  return a;
}


inline fn iota(reg ptr u64[25] a, reg u64 c) -> reg ptr u64[25] {
  a[0] ^= c;
  return a;
}


inline fn keccakP1600_round(reg ptr u64[25] state, reg u64 c) -> reg ptr u64[25] {
  state = theta(state);
  state = rho(state);
  state = pi(state);
  state = chi(state);
  state = iota(state, c);
  return state;
}

u64[24] KeccakF_RoundConstants = {0x0000000000000001, 0x0000000000008082, 0x800000000000808a, 0x8000000080008000,
                                    0x000000000000808b, 0x0000000080000001, 0x8000000080008081, 0x8000000000008009,
                                    0x000000000000008a, 0x0000000000000088, 0x0000000080008009, 0x000000008000000a,
                                    0x000000008000808b, 0x800000000000008b, 0x8000000000008089, 0x8000000000008003,
                                    0x8000000000008002, 0x8000000000000080, 0x000000000000800a, 0x800000008000000a,
                                    0x8000000080008081, 0x8000000000008080, 0x0000000080000001, 0x8000000080008008};

fn KeccakF1600_StatePermute(reg ptr u64[25] state) -> reg ptr u64[25]
{
  inline int round;

  for round = 0 to 24 {
    state = keccakP1600_round(state, KeccakF_RoundConstants[round]);
  }

  return state;
}


inline fn keccak_absorb_256_PUBKEYBYTES(reg ptr u64[25] s, reg ptr u8[SABER_INDCPA_PUBLICKEYBYTES] m) -> reg ptr u64[25]
{
 inline int i;
 inline int j;
 inline int iterations;
 inline int handled;
 inline int remainder;

 reg u8 t8;

 reg u64 t64;

 stack u8[200] t;

 iterations = SABER_INDCPA_PUBLICKEYBYTES / SHA3_256_RATE;
 handled = iterations * SHA3_256_RATE;
 remainder = SABER_INDCPA_PUBLICKEYBYTES - handled;

 for j = 0 to iterations {
  for i = 0 to (SHA3_256_RATE / 8) {
   t64 = load64(m[j * SHA3_256_RATE + 8 * i:8]);
   s[i] ^= t64;
  }

  s = KeccakF1600_StatePermute(s);
 }

 for i = 0 to SHA3_256_RATE {
  t[i] = 0;
 }

 for i = 0 to remainder {
  t8 = m[handled + i];
  t[i] = t8;
 }

 t[remainder] = 0x06;
 t[SHA3_256_RATE - 1] |= 128;

 for i = 0 to (SHA3_256_RATE / 8) {
  t64 = load64(t[8 * i:8]);
  s[i] ^= t64;
 }

 return s;
}
inline fn keccak_absorb_256_CCADEC(reg ptr u64[25] s, reg ptr u8[SABER_BYTES_CCA_DEC] m) -> reg ptr u64[25]
{
 inline int i;
 inline int j;
 inline int iterations;
 inline int handled;
 inline int remainder;

 reg u8 t8;

 reg u64 t64;

 stack u8[200] t;

 iterations = SABER_BYTES_CCA_DEC / SHA3_256_RATE;
 handled = iterations * SHA3_256_RATE;
 remainder = SABER_BYTES_CCA_DEC - handled;

 for j = 0 to iterations {
  for i = 0 to (SHA3_256_RATE / 8) {
   t64 = load64(m[j * SHA3_256_RATE + 8 * i:8]);
   s[i] ^= t64;
  }

  s = KeccakF1600_StatePermute(s);
 }

 for i = 0 to SHA3_256_RATE {
  t[i] = 0;
 }

 for i = 0 to remainder {
  t8 = m[handled + i];
  t[i] = t8;
 }

 t[remainder] = 0x06;
 t[SHA3_256_RATE - 1] |= 128;

 for i = 0 to (SHA3_256_RATE / 8) {
  t64 = load64(t[8 * i:8]);
  s[i] ^= t64;
 }

 return s;
}












inline fn store64(reg ptr u8[8] x, reg u64 u) -> reg ptr u8[8]
{
 inline int i;

 for i = 0 to 7 {
  x[i] = u;
  u >>= 8;
 }

 x[7] = u;

 return x;
}

inline fn keccak_squeezeblocks_128_128(reg ptr u8[SHAKE128_RATE] h, reg ptr u64[25] s) -> reg ptr u8[SHAKE128_RATE], reg ptr u64[25]
{
 inline int i;

 reg u64 u;

 s = KeccakF1600_StatePermute(s);

 for i = 0 to (SHAKE128_RATE / 8) {
  u = s[i];
  h[8 * i:8] = store64(h[8 * i:8], u);
 }

 return h, s;
}







inline fn shake128_32_32(reg ptr u8[32] output, reg ptr u8[32] input) -> reg ptr u8[32]
{
 inline int i;

 reg u8 t8;

 stack u8[SHAKE128_RATE] t;

 stack u64[25] s;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_128_32(s, input);

 t, s = keccak_squeezeblocks_128_128(t, s);

 for i = 0 to 32 {
  t8 = t[i];
  output[i] = t8;
 }

 return output;
}
inline fn keccak_squeezeblocks_128_KK13N8(reg ptr u8[KK13N8] h, reg ptr u64[25] s) -> reg ptr u8[KK13N8], reg ptr u64[25]
{
 inline int i;
 inline int j;
 inline int iterations;

 reg u64 u;

 iterations = KK13N8 / SHAKE128_RATE;

 for j = 0 to iterations {
  s = KeccakF1600_StatePermute(s);

  for i = 0 to (SHAKE128_RATE / 8) {
   u = s[i];
   h[j * SHAKE128_RATE + 8 * i:8] = store64(h[j * SHAKE128_RATE + 8 * i:8], u);
  }
 }

 return h, s;
}









inline fn shake128_KK13N8_32(reg ptr u8[KK13N8] output, reg ptr u8[32] input) -> reg ptr u8[KK13N8]
{
 inline int i;
 inline int nblocks;
 inline int handled;
 inline int remainder;

 reg u8 t8;

 stack u8[SHAKE128_RATE] t;

 stack u64[25] s;

 nblocks = KK13N8 / SHAKE128_RATE;
 handled = nblocks * SHAKE128_RATE;
 remainder = KK13N8 - handled;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_128_32(s, input);

 output, s = keccak_squeezeblocks_128_KK13N8(output, s);

 if (remainder > 0) {
  t, s = keccak_squeezeblocks_128_128(t, s);

  for i = 0 to remainder {
   t8 = t[i];
   output[handled + i] = t8;
  }
 }

 return output;
}
inline fn keccak_squeezeblocks_128_MUNK8(reg ptr u8[MUNK8] h, reg ptr u64[25] s) -> reg ptr u8[MUNK8], reg ptr u64[25]
{
 inline int i;
 inline int j;
 inline int iterations;

 reg u64 u;

 iterations = MUNK8 / SHAKE128_RATE;

 for j = 0 to iterations {
  s = KeccakF1600_StatePermute(s);

  for i = 0 to (SHAKE128_RATE / 8) {
   u = s[i];
   h[j * SHAKE128_RATE + 8 * i:8] = store64(h[j * SHAKE128_RATE + 8 * i:8], u);
  }
 }

 return h, s;
}









inline fn shake128_MUNK8_32(reg ptr u8[MUNK8] output, reg ptr u8[32] input) -> reg ptr u8[MUNK8]
{
 inline int i;
 inline int nblocks;
 inline int handled;
 inline int remainder;

 reg u8 t8;

 stack u8[SHAKE128_RATE] t;

 stack u64[25] s;

 nblocks = MUNK8 / SHAKE128_RATE;
 handled = nblocks * SHAKE128_RATE;
 remainder = MUNK8 - handled;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_128_32(s, input);

 output, s = keccak_squeezeblocks_128_MUNK8(output, s);

 if (remainder > 0) {
  t, s = keccak_squeezeblocks_128_128(t, s);

  for i = 0 to remainder {
   t8 = t[i];
   output[handled + i] = t8;
  }
 }

 return output;
}
inline fn keccak_squeezeblocks_256_256(reg ptr u8[SHA3_256_RATE] h, reg ptr u64[25] s) -> reg ptr u8[SHA3_256_RATE], reg ptr u64[25]
{
 inline int i;

 reg u64 u;

 s = KeccakF1600_StatePermute(s);

 for i = 0 to (SHA3_256_RATE / 8) {
  u = s[i];
  h[8 * i:8] = store64(h[8 * i:8], u);
 }

 return h, s;
}







inline fn sha3_256_32(reg ptr u8[32] output, reg ptr u8[32] input) -> reg ptr u8[32]
{
 inline int i;

 reg u8 t8;

 stack u8[SHA3_256_RATE] t;

 stack u64[25] s;

 for i = 0 to 25 {
  s[i] =0;
 }

 s = keccak_absorb_256_32(s, input);

 t, s = keccak_squeezeblocks_256_256(t, s);

 for i = 0 to 32 {
  t8 = t[i];
  output[i] = t8;
 }

 return output;
}








fn sha3_256_64(reg ptr u8[32] output, reg ptr u8[64] input) -> reg ptr u8[32]
{
 inline int i;

 reg u8 t8;

 stack u8[SHA3_256_RATE] t;

 stack u64[25] s;

 for i = 0 to 25 {
  s[i] =0;
 }

 s = keccak_absorb_256_64(s, input);

 t, s = keccak_squeezeblocks_256_256(t, s);

 for i = 0 to 32 {
  t8 = t[i];
  output[i] = t8;
 }

 return output;
}








fn sha3_256_PUBKEYBYTES(reg ptr u8[32] output, reg ptr u8[SABER_INDCPA_PUBLICKEYBYTES] input) -> reg ptr u8[32]
{
 inline int i;

 reg u8 t8;

 stack u8[SHA3_256_RATE] t;

 stack u64[25] s;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_256_PUBKEYBYTES(s, input);

 t, s = keccak_squeezeblocks_256_256(t, s);

 for i = 0 to 32 {
  t8 = t[i];
  output[i] = t8;
 }

 return output;
}








fn sha3_256_CCADEC(reg ptr u8[32] output, reg ptr u8[SABER_BYTES_CCA_DEC] input) -> reg ptr u8[32]
{
 inline int i;

 reg u8 t8;

 stack u8[SHA3_256_RATE] t;

 stack u64[25] s;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_256_CCADEC(s, input);

 t, s = keccak_squeezeblocks_256_256(t, s);

 for i = 0 to 32 {
  t8 = t[i];
  output[i] = t8;
 }

 return output;
}
inline fn keccak_squeezeblocks_512_512(reg ptr u8[SHA3_512_RATE] h, reg ptr u64[25] s) -> reg ptr u8[SHA3_512_RATE], reg ptr u64[25]
{
 inline int i;

 reg u64 u;

 s = KeccakF1600_StatePermute(s);

 for i = 0 to (SHA3_512_RATE / 8) {
  u = s[i];
  h[8 * i:8] = store64(h[8 * i:8], u);
 }


 return h, s;
}







inline fn sha3_512_64(reg ptr u8[64] output, reg ptr u8[64] input) -> reg ptr u8[64]
{
 inline int i;

 reg u8 t8;

 stack u8[SHA3_512_RATE] t;

 stack u64[25] s;

 for i = 0 to 25 {
  s[i] = 0;
 }

 s = keccak_absorb_512_64(s, input);

 t, s = keccak_squeezeblocks_512_512(t, s);

 for i = 0 to 64 {
  t8 = t[i];
  output[i] = t8;
 }

 return output;
}


export fn sha3_256_CCADEC_jazz(reg u64 outputp, reg u64 inputp)
{
 inline int i;

 reg u8 t;

 stack u8[32] output;
 stack u8[SABER_BYTES_CCA_DEC] input;

 stack u64 soutputp;

 for i = 0 to SABER_BYTES_CCA_DEC {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = sha3_256_CCADEC(output, input);

 outputp = soutputp;

 for i = 0 to 32 {
  t = output[i];
  (u8) [outputp + i] = t;
 }
}


export fn sha3_256_PUBKEYBYTES_jazz(reg u64 outputp, reg u64 inputp)
{
 inline int i;

 reg u8 t;

 stack u8[32] output;
 stack u8[SABER_INDCPA_PUBLICKEYBYTES] input;

 stack u64 soutputp;

 for i = 0 to SABER_INDCPA_PUBLICKEYBYTES {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = sha3_256_PUBKEYBYTES(output, input);

 outputp = soutputp;

 for i = 0 to 32 {
  t = output[i];
  (u8) [outputp + i] = t;
 }
}


export fn sha3_256_64_jazz(reg u64 outputp, reg u64 inputp)
{
 inline int i;

 reg u8 t;

 stack u8[32] output;
 stack u8[64] input;

 stack u64 soutputp;

 for i = 0 to 64 {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = sha3_256_64(output, input);

 outputp = soutputp;

 for i = 0 to 32 {
  t = output[i];
  (u8) [outputp + i] = t;
 }
}



export fn keccak_squeezeblocks_256_256_jazz(reg u64 hp, reg u64 sp)
{
 inline int i;

 reg u8 th;

 reg u64 ts;

 stack u8[SHA3_256_RATE] h;

 stack u64[25] s;

 stack u64 shp;
 stack u64 ssp;

 for i = 0 to 25 {
  ts = (u64) [sp + 8 * i];
  s[i] = ts;
 }

 shp = hp;
 ssp = sp;

 h, s = keccak_squeezeblocks_256_256(h, s);

 hp = shp;
 sp = ssp;

 for i = 0 to SHA3_256_RATE {
  th = h[i];
  (u8) [hp + i] = th;
 }

 for i = 0 to 25 {
  ts = s[i];
  (u64) [sp + 8 * i] = ts;
 }

}


export fn keccak_squeezeblocks_128_MUNK8_jazz(reg u64 hp, reg u64 sp)
{
 inline int i;

 reg u8 th;

 reg u64 ts;

 stack u8[MUNK8] h;

 stack u64[25] s;

 stack u64 shp;
 stack u64 ssp;

 for i = 0 to MUNK8 {
  th = (u8) [hp + i];
  h[i] = th;
 }

 for i = 0 to 25 {
  ts = (u64) [sp + 8 * i];
  s[i] = ts;
 }

 shp = hp;
 ssp = sp;

 h, s = keccak_squeezeblocks_128_MUNK8(h, s);

 hp = shp;
 sp = ssp;

 for i = 0 to MUNK8 {
  th = h[i];
  (u8) [hp + i] = th;
 }

 for i = 0 to 25 {
  ts = s[i];
  (u64) [sp + 8 * i] = ts;
 }

}


export fn shake128_KK13N8_32_jazz(reg u64 outputp, reg u64 inputp)
{
 inline int i;

 reg u8 t;

 stack u8[KK13N8] output;
 stack u8[32] input;

 stack u64 soutputp;

 for i = 0 to 32 {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = shake128_KK13N8_32(output, input);

 outputp = soutputp;

 for i = 0 to KK13N8 {
  t = output[i];
  (u8) [outputp + i] = t;
 }
}


export fn keccak_squeezeblocks_128_KK13N8_jazz(reg u64 hp, reg u64 sp)
{
 inline int i;

 reg u8 th;

 reg u64 ts;

 stack u8[KK13N8] h;

 stack u64[25] s;

 stack u64 shp;
 stack u64 ssp;

 for i = 0 to KK13N8 {
  th = (u8) [hp + i];
  h[i] = th;
 }

 for i = 0 to 25 {
  ts = (u64) [sp + 8 * i];
  s[i] = ts;
 }

 shp = hp;
 ssp = sp;

 h, s = keccak_squeezeblocks_128_KK13N8(h, s);

 hp = shp;
 sp = ssp;

 for i = 0 to KK13N8 {
  th = h[i];
  (u8) [hp + i] = th;
 }

 for i = 0 to 25 {
  ts = s[i];
  (u64) [sp + 8 * i] = ts;
 }
}


export fn shake128_32_32_jazz(reg u64 outputp, reg u64 inputp)
{
 inline int i;

 reg u8 t;

 stack u8[32] output;
 stack u8[32] input;

 stack u64 soutputp;

 for i = 0 to 32 {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = shake128_32_32(output, input);

 outputp = soutputp;

 for i = 0 to 32 {
  t = output[i];
  (u8) [outputp + i] = t;
 }
}


export fn keccak_squeezeblocks_128_128_jazz(reg u64 hp, reg u64 sp)
{
 inline int i;

 reg u8 th;

 reg u64 ts;

 stack u8[SHAKE128_RATE] h;

 stack u64[25] s;

 stack u64 shp;
 stack u64 ssp;

 for i = 0 to 25 {
  ts = (u64) [sp + 8 * i];
  s[i] = ts;
 }

 shp = hp;
 ssp = sp;

 h, s = keccak_squeezeblocks_128_128(h, s);

 hp = shp;
 sp = ssp;

 for i = 0 to SHAKE128_RATE {
  th = h[i];
  (u8) [hp + i] = th;
 }

 for i = 0 to 25 {
  ts = s[i];
  (u64) [sp + 8 * i] = ts;
 }
}


export fn shake128_MUNK8_32_jazz(reg u64 outputp, reg u64 inputp)
{
 inline int i;

 reg u8 t;

 stack u8[MUNK8] output;
 stack u8[32] input;

 stack u64 soutputp;

 for i = 0 to 32 {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = shake128_MUNK8_32(output, input);

 outputp = soutputp;

 for i = 0 to MUNK8 {
  t = output[i];
  (u8) [outputp + i] = t;
 }
}


export fn keccak_absorb_256_CCADEC_jazz(reg u64 sp, reg u64 mp)
{
 inline int i;

 reg u8 tm;

 reg u64 ts;

 stack u8[SABER_BYTES_CCA_DEC] m;

 stack u64[25] s;

 stack u64 ssp;

 for i = 0 to 25 {
  ts = (u64) [sp + 8 * i];
  s[i] = ts;
 }

 for i = 0 to SABER_BYTES_CCA_DEC {
  tm = (u8) [mp + i];
  m[i] = tm;
 }

 ssp = sp;

 s = keccak_absorb_256_CCADEC(s, m);

 sp = ssp;

 for i = 0 to 25 {
  ts = s[i];
  (u64) [sp + 8 * i] = ts;
 }
}


export fn keccak_squeezeblocks_512_512_jazz(reg u64 hp, reg u64 sp)
{
 inline int i;

 reg u8 th;

 reg u64 ts;

 stack u8[SHA3_512_RATE] h;

 stack u64[25] s;

 stack u64 shp;
 stack u64 ssp;

 for i = 0 to 25 {
  ts = (u64) [sp + 8 * i];
  s[i] = ts;
 }

 shp = hp;
 ssp = sp;

 h, s = keccak_squeezeblocks_512_512(h, s);

 hp = shp;
 sp = ssp;

 for i = 0 to SHA3_512_RATE {
  th = h[i];
  (u8) [hp + i] = th;
 }

 for i = 0 to 25 {
  ts = s[i];
  (u64) [sp + 8 * i] = ts;
 }
}


export fn keccak_absorb_512_64_jazz(reg u64 sp, reg u64 mp)
{
 inline int i;

 reg u8 tm;

 reg u64 ts;

 stack u8[64] m;

 stack u64[25] s;

 for i = 0 to 25 {
  ts = (u64) [sp + 8 * i];
  s[i] = ts;
 }

 for i = 0 to 64 {
  tm = (u8) [mp + i];
  m[i] = tm;
 }

 s = keccak_absorb_512_64(s, m);

 for i = 0 to 25 {
  ts = s[i];
  (u64) [sp + 8 * i] = ts;
 }
}


export fn keccak_absorb_256_64_jazz(reg u64 sp, reg u64 mp)
{
 inline int i;

 reg u8 tm;

 reg u64 ts;

 stack u8[64] m;

 stack u64[25] s;

 for i = 0 to 25 {
  ts = (u64) [sp + 8 * i];
  s[i] = ts;
 }

 for i = 0 to 64 {
  tm = (u8) [mp + i];
  m[i] = tm;
 }

 s = keccak_absorb_256_64(s, m);

 for i = 0 to 25 {
  ts = s[i];
  (u64) [sp + 8 * i] = ts;
 }
}


export fn keccak_absorb_256_32_jazz(reg u64 sp, reg u64 mp)
{
 inline int i;

 reg u8 tm;

 reg u64 ts;

 stack u8[32] m;

 stack u64[25] s;

 for i = 0 to 25 {
  ts = (u64) [sp + 8 * i];
  s[i] = ts;
 }

 for i = 0 to 32 {
  tm = (u8) [mp + i];
  m[i] = tm;
 }

 s = keccak_absorb_256_32(s, m);

 for i = 0 to 25 {
  ts = s[i];
  (u64) [sp + 8 * i] = ts;
 }
}


export fn keccak_absorb_128_32_jazz(reg u64 sp, reg u64 mp)
{
 inline int i;

 reg u8 tm;

 reg u64 ts;

 stack u8[32] m;

 stack u64[25] s;

 for i = 0 to 25 {
  ts = (u64) [sp + 8 * i];
  s[i] = ts;
 }

 for i = 0 to 32 {
  tm = (u8) [mp + i];
  m[i] = tm;
 }

 s = keccak_absorb_128_32(s, m);

 for i = 0 to 25 {
  ts = s[i];
  (u64) [sp + 8 * i] = ts;
 }
}

export fn KeccakF1600_StatePermute_jazz(reg u64 statep)
{
 inline int i;

 reg u64 t;

 stack u64[25] state;

 for i = 0 to 25 {
  t = (u64) [statep + 8 * i];
  state[i] = t;
 }

 state = KeccakF1600_StatePermute(state);

 for i = 0 to 25 {
  t = state[i];
  (u64) [statep + 8 * i] = t;
 }
}



export fn keccak_absorb_256_PUBKEYBYTES_jazz(reg u64 sp, reg u64 mp)
{
 inline int i;

 reg u8 tm;

 reg u64 ts;

 stack u8[SABER_INDCPA_PUBLICKEYBYTES] m;

 stack u64[25] s;

 stack u64 ssp;

 for i = 0 to 25 {
  ts = (u64) [sp + 8 * i];
  s[i] = ts;
 }

 for i = 0 to SABER_INDCPA_PUBLICKEYBYTES {
  tm = (u8) [mp + i];
  m[i] = tm;
 }

 ssp = sp;

 s = keccak_absorb_256_PUBKEYBYTES(s, m);

 sp = ssp;

 for i = 0 to 25 {
  ts = s[i];
  (u64) [sp + 8 * i] = ts;
 }
}


export fn sha3_256_32_jazz(reg u64 outputp, reg u64 inputp)
{
 inline int i;

 reg u8 t;

 stack u8[32] output;
 stack u8[32] input;

 stack u64 soutputp;

 for i = 0 to 32 {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = sha3_256_32(output, input);

 outputp = soutputp;

 for i = 0 to 32 {
  t = output[i];
  (u8) [outputp + i] = t;
 }

}

export fn sha3_512_64_jazz(reg u64 outputp, reg u64 inputp)
{

 inline int i;

 reg u8 t;

 stack u8[64] output;
 stack u8[64] input;

 stack u64 soutputp;

 for i = 0 to 64 {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = sha3_512_64(output, input);

 outputp = soutputp;

 for i = 0 to 64 {
  t = output[i];
  (u8) [outputp + i] = t;
 }
}

export fn load64_jazz(reg u64 xp) -> reg u64
{
 inline int i;

 reg u8 t;

 reg u64 r;

 stack u8[8] x;

 for i = 0 to 8 {
  t = (u8) [xp + i];
  x[i] = t;
 }

 r = load64(x);

 return r;
}

export fn store64_jazz(reg u64 xp, reg u64 u)
{
 inline int i;

 reg u8 t;

 stack u8[8] x;

 x = store64(x, u);

 for i = 0 to 8 {
  t = x[i];
  (u8) [xp + i] = t;
 }
}
