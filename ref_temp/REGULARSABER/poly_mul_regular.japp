








param int CRYPTO_SECRETKEYBYTES = 2304;
param int CRYPTO_PUBLICKEYBYTES = (3 * 320 + 32);
param int CRYPTO_BYTES = 32;
param int CRYPTO_CIPHERTEXTBYTES = 1088;
param int Saber_type = 2;

param int SABER_K = 3;
param int SABER_MU = 8;
param int SABER_ET = 4;

param int SABER_EQ = 13;
param int SABER_EP = 10;

param int SABER_N = 256;
param int SABER_Q = 8192;
param int SABER_P = 1024;

param int SABER_SEEDBYTES = 32;
param int SABER_NOISESEEDBYTES = 32;
param int SABER_COINBYTES = 32;
param int SABER_KEYBYTES = 32;

param int SABER_HASHBYTES = 32;

param int SABER_POLYBYTES = 416;

param int SABER_POLYVECBYTES = (SABER_K * SABER_POLYBYTES);

param int SABER_POLYVECCOMPRESSEDBYTES = (SABER_K * 320);

param int SABER_CIPHERTEXTBYTES = (SABER_POLYVECCOMPRESSEDBYTES);



param int SABER_SCALEBYTES_KEM = (SABER_ET * SABER_N / 8);

param int SABER_INDCPA_PUBLICKEYBYTES = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SEEDBYTES);
param int SABER_INDCPA_SECRETKEYBYTES = (SABER_POLYVECBYTES);

param int SABER_PUBLICKEYBYTES = (SABER_INDCPA_PUBLICKEYBYTES);

param int SABER_SECRETKEYBYTES = (SABER_INDCPA_SECRETKEYBYTES + SABER_INDCPA_PUBLICKEYBYTES + SABER_HASHBYTES + SABER_KEYBYTES);

param int SABER_BYTES_CCA_DEC = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SCALEBYTES_KEM);



param int SABER_KN = (SABER_K * SABER_N);
param int SABER_KKN = (SABER_K * SABER_K * SABER_N);
param int N_SB = (SABER_N / 4);
param int N_SB_RES = (2 * N_SB - 1);

param int SHAKE128_RATE = 168;
param int SHAKE256_RATE = 136;
param int SHA3_256_RATE = 136;
param int SHA3_512_RATE = 72;

param int KK13N8 = (SABER_K * SABER_K * (13 * SABER_N / 8));
param int MUNK8 = (SABER_MU * SABER_N * SABER_K / 8);

param int h1 = 4;
param int h2 = 228;






fn karatsuba_simple(reg ptr u16[N_SB] a_1, reg ptr u16[N_SB] b_1, reg ptr u16[N_SB_RES] result_final) -> reg ptr u16[N_SB_RES]
{
 inline int i;
 inline int j;
 inline int N;

 reg u16 acc1;
 reg u16 acc2;
 reg u16 acc3;
 reg u16 acc4;
 reg u16 acc5;
 reg u16 acc6;
 reg u16 acc7;
 reg u16 acc8;
 reg u16 acc9;
 reg u16 acc10;
 reg u16 t16;

 stack u16[64 / 2 - 1] d01;
 stack u16[64 / 2 - 1] d0123;
 stack u16[64 / 2 - 1] d23;
 stack u16[64 - 1] result_d01;

 N = 64;


 for i = 0 to (N / 2 - 1) {
  d01[i] = 0;
  d0123[i] = 0;
  d23[i] = 0;
  result_d01[i] = 0;
  result_final[i] = 0;
 }

 for i = (N / 2 - 1) to (N - 1) {
  result_d01[i] = 0;
  result_final[i] = 0;
 }

 for i = (N - 1) to (2 * N - 1) {
  result_final[i] = 0;
 }


 for i = 0 to (N / 4) {
  acc1 = a_1[i];
  acc2 = a_1[i + N / 4];
  acc3 = a_1[i + 2 * N / 4];
  acc4 = a_1[i + 3 * N / 4];

  for j = 0 to (N / 4) {
   acc5 = b_1[j];
   acc6 = b_1[j + N / 4];


   t16 = acc1;
   t16 *= acc5;
   t16 += result_final[i + j];
   result_final[i + j] = t16;


   t16 = acc2;
   t16 *= acc6;
   t16 += result_final[i + j + 2 * N / 4];
   result_final[i + j + 2 * N / 4] = t16;

   acc7 = acc5 + acc6;
   acc8 = acc1 + acc2;


   t16 = acc7;
   t16 *= acc8;
   t16 += d01[i + j];
   d01[i + j] = t16;

   acc7 = b_1[j + 2 * N / 4];
   acc8 = b_1[j + 3 * N / 4];


   t16 = acc7;
   t16 *= acc3;
   t16 += result_final[i + j + 4 * N / 4];
   result_final[i + j + 4 * N / 4] = t16;


   t16 = acc8;
   t16 *= acc4;
   t16 += result_final[i + j + 6 * N / 4];
   result_final[i + j + 6 * N / 4] = t16;

   acc9 = acc3 + acc4;
   acc10 = acc7 + acc8;


   t16 = acc9;
   t16 *= acc10;
   t16 += d23[i + j];
   d23[i + j] = t16;

   acc5 = acc5 + acc7;
   acc7 = acc1 + acc3;


   t16 = acc5;
   t16 *= acc7;
   t16 += result_d01[i + j];
   result_d01[i + j] = t16;

   acc6 = acc6 + acc8;
   acc8 = acc2 + acc4;


   t16 = acc6;
   t16 *= acc8;
   t16 += result_d01[i + j + 2 * N / 4];
   result_d01[i + j + 2 * N / 4] = t16;

   acc5 = acc5 + acc6;
   acc7 = acc7 + acc8;


   t16 = acc5;
   t16 *= acc7;
   t16 += d0123[i + j];
   d0123[i + j] = t16;
  }
 }

 for i = 0 to N / 2 - 1 {

  t16 = d0123[i];
  t16 -= result_d01[i];
  t16 -= result_d01[i + 2 * N / 4];
  d0123[i] = t16;


  t16 = d01[i];
  t16 -= result_final[i];
  t16 -= result_final[i + 2 * N / 4];
  d01[i] = t16;


  t16 = d23[i];
  t16 -= result_final[i + 4 * N / 4];
  t16 -= result_final[i + 6 * N / 4];
  d23[i] = t16;
 }

 for i = 0 to N / 2 -1 {

  t16 = result_d01[i + N / 4];
  t16 += d0123[i];
  result_d01[i + N / 4] = t16;


  t16 = result_final[i + N / 4];
  t16 += d01[i];
  result_final[i + N / 4] = t16;


  t16 = result_final[i + 5 * N / 4];
  t16 += d23[i];
  result_final[i + 5 * N / 4] = t16;
 }

 for i = 0 to N - 1 {

  t16 = result_d01[i];
  t16 -= result_final[i];
  t16 -= result_final[i + N];
  result_d01[i] = t16;
 }

 for i = 0 to N - 1 {

  t16 = result_final[i + N / 2];
  t16 += result_d01[i];
  result_final[i + N / 2] = t16;
 }

 return result_final;
}







inline fn toom_cook_4way(reg ptr u16[SABER_N] a1, reg ptr u16[SABER_N] b1, reg ptr u16[512] result) -> reg ptr u16[512]
{
 inline int i;
 inline int j;

 inline int AB0;
 inline int AB1;
 inline int AB2;
 inline int AB3;

 reg u16 r0;
 reg u16 r1;
 reg u16 r2;
 reg u16 r3;
 reg u16 r4;
 reg u16 r5;
 reg u16 r6;
 reg u16 r7;

 reg u16 t1;
 reg u16 t2;

 reg u32 p1;
 reg u32 p2;

 stack u16[N_SB] aw1;
 stack u16[N_SB] aw2;
 stack u16[N_SB] aw3;
 stack u16[N_SB] aw4;
 stack u16[N_SB] aw5;
 stack u16[N_SB] aw6;
 stack u16[N_SB] aw7;

 stack u16[N_SB] bw1;
 stack u16[N_SB] bw2;
 stack u16[N_SB] bw3;
 stack u16[N_SB] bw4;
 stack u16[N_SB] bw5;
 stack u16[N_SB] bw6;
 stack u16[N_SB] bw7;

 stack u16[N_SB_RES] w1;
 stack u16[N_SB_RES] w2;
 stack u16[N_SB_RES] w3;
 stack u16[N_SB_RES] w4;
 stack u16[N_SB_RES] w5;
 stack u16[N_SB_RES] w6;
 stack u16[N_SB_RES] w7;

 stack ptr u16[512] sresult;

 AB0 = 0;
 AB1 = N_SB;
 AB2 = 2 * N_SB;
 AB3 = 3 * N_SB;

 for i = 0 to N_SB_RES {
  w1[i] = 0;
  w2[i] = 0;
  w3[i] = 0;
  w4[i] = 0;
  w5[i] = 0;
  w6[i] = 0;
  w7[i] = 0;
 }

 for j = 0 to N_SB {
  r0 = a1[AB0 + j];
  r1 = a1[AB1 + j];
  r2 = a1[AB2 + j];
  r3 = a1[AB3 + j];
  r4 = r0 + r2;
  r5 = r1 + r3;
  r6 = r4 + r5;
  r7 = r4;
  r7 -= r5;

  aw3[j] = r6;
  aw4[j] = r7;


  t1 = r0;
  t1 <<= 2;
  t1 += r2;
  t1 <<= 1;
  r4 = t1;


  t1 = r1;
  t1 <<= 2;
  t1 += r3;
  r5 = t1;

  r6 = r4 + r5;
  r7 = r4;
  r7 -= r5;

  aw5[j] = r6;
  aw6[j] = r7;


  t1 = r3;
  t1 <<= 3;
  t2 = r2;
  t2 <<= 2;
  t1 += t2;
  t2 = r1;
  t2 <<= 1;
  t1 += t2;
  t1 += r0;
  r4 = t1;

  aw2[j] = r4;
  aw7[j] = r0;
  aw1[j] = r3;
 }

 for j = 0 to N_SB {
  r0 = b1[AB0 + j];
  r1 = b1[AB1 + j];
  r2 = b1[AB2 + j];
  r3 = b1[AB3 + j];
  r4 = r0 + r2;
  r5 = r1 + r3;
  r6 = r4 + r5;
  r7 = r4;
  r7 -= r5;

  bw3[j] = r6;
  bw4[j] = r7;


  t1 = r0;
  t1 <<= 2;
  t1 += r2;
  t1 <<= 1;
  r4 = t1;


  t1 = r1;
  t1 <<= 2;
  t1 += r3;
  r5 = t1;

  r6 = r4 + r5;
  r7 = r4;
  r7 -= r5;

  bw5[j] = r6;
  bw6[j] = r7;


  t1 = r3;
  t1 <<= 3;
  t2 = r2;
  t2 <<= 2;
  t1 += t2;
  t2 = r1;
  t2 <<= 1;
  t1 += t2;
  t1 += r0;
  r4 = t1;

  bw2[j] = r4;
  bw7[j] = r0;
  bw1[j] = r3;
 }

 sresult = result;

 w1 = karatsuba_simple(aw1, bw1, w1);
 w2 = karatsuba_simple(aw2, bw2, w2);
 w3 = karatsuba_simple(aw3, bw3, w3);
 w4 = karatsuba_simple(aw4, bw4, w4);
 w5 = karatsuba_simple(aw5, bw5, w5);
 w6 = karatsuba_simple(aw6, bw6, w6);
 w7 = karatsuba_simple(aw7, bw7, w7);

 result = sresult;

 for i = 0 to N_SB_RES {
  r0 = w1[i];
  r1 = w2[i];
  r2 = w3[i];
  r3 = w4[i];
  r4 = w5[i];
  r5 = w6[i];
  r6 = w7[i];

  r1 += r4;
  r5 -= r4;


  p1 = (32u) r3;
  p2 = (32u) r2;
  p1 -= p2;
  p1 >>= 1;
  r3 = (16u) p1;

  r4 -= r0;


  t1 = r6;
  t1 <<= 6;
  r4 -= t1;


   r4 <<= 1;
   r4 += r5;

   r2 += r3;


   t1 = r2;
   t1 <<= 6;
   r1 -= t1;
   r1 -= r2;

   r2 -= r6;
   r2 -= r0;


   t1 = 45 * r2;
   r1 += t1;


   p1 = (32u) r2;
   p1 <<= 3;
   p2 = (32u) r4;
   p2 -= p1;
   p2 *= 43691;
   p2 >>= 3;
   r4 = (16u) p2;

   r5 += r1;


   p1 = (32u) r3;
   p1 <<= 4;
   p2 = (32u) r1;
   p2 += p1;
   p2 *= 36409;
   p2 >>= 1;
   r1 = (16u) p2;


   p1 = (32u) r3;
   p2 = (32u) r1;
   p1 += p2;
   p1 *= -1;
   r3 = (16u) p1;


   p1 = (32u) r1;
   p1 *= 30;
   p2 = (32u) r5;
   p1 -= p2;
   p1 *= 61167;
   p1 >>= 2;
   r5 = (16u) p1;

   r2 -= r4;
   r1 -= r5;

   result[i] += r6;
   result[i + 64] += r5;
   result[i + 128] += r4;
   result[i + 192] += r3;
   result[i + 256] += r2;
   result[i + 320] += r1;
   result[i + 384] += r0;
 }

 return result;
}







fn pol_mul_p(reg ptr u16[SABER_N] a, reg ptr u16[SABER_N] b, reg ptr u16[SABER_N] res) -> reg ptr u16[SABER_N]
{
 inline int i;

 reg u16 t16;

 stack u16[512] c;

 stack ptr u16[SABER_N] sres;

 for i = 0 to 512 {
  c[i] = 0;
 }

 sres = res;

 c = toom_cook_4way(a, b, c);

 res = sres;

 for i = SABER_N to 2 * SABER_N {

  t16 = c[i - SABER_N];
  t16 -= c[i];
  res[i - SABER_N] = t16;
  t16 = SABER_P - 1;
  res[i - SABER_N] &= t16;
 }

 return res;
}
fn pol_mul_q(reg ptr u16[SABER_N] a, reg ptr u16[SABER_N] b, reg ptr u16[SABER_N] res) -> reg ptr u16[SABER_N]
{
 inline int i;

 reg u16 t16;

 stack u16[512] c;

 stack ptr u16[SABER_N] sres;

 for i = 0 to 512 {
  c[i] = 0;
 }

 sres = res;

 c = toom_cook_4way(a, b, c);

 res = sres;

 for i = SABER_N to 2 * SABER_N {

  t16 = c[i - SABER_N];
  t16 -= c[i];
  res[i - SABER_N] = t16;
  t16 = SABER_Q - 1;
  res[i - SABER_N] &= t16;
 }

 return res;
}

export fn karatsuba_simple_jazz(reg u64 ap, reg u64 bp, reg u64 result_finalp)
{
 inline int i;

 reg u16 t;

 stack u16[N_SB] a_1;
 stack u16[N_SB] b_1;
 stack u16[N_SB_RES] result_final;

 stack u64 sresult_finalp;

 for i = 0 to N_SB {
  t = (u16) [ap + 2 * i];
  a_1[i] = t;
 }

 for i = 0 to N_SB {
  t = (u16) [bp + 2 * i];
  b_1[i] = t;
 }

 sresult_finalp = result_finalp;

 result_final = karatsuba_simple(a_1, b_1, result_final);

 result_finalp = sresult_finalp;

 for i = 0 to N_SB_RES {
  t = result_final[i];
  (u16) [result_finalp + 2 * i] = t;
 }

}

export fn toom_cook_4way_jazz(reg u64 ap, reg u64 bp, reg u64 resultp) {
 inline int i;

 reg u16 t;

 stack u16[SABER_N] a1;
 stack u16[SABER_N] b1;
 stack u16[512] result;

 stack u64 sresultp;

 for i = 0 to SABER_N {
  t = (u16) [ap + 2 * i];
  a1[i] = t;
 }

 for i = 0 to SABER_N {
  t = (u16) [bp + 2 * i];
  b1[i] = t;
 }

 for i = 0 to 512 {
  t = (u16) [resultp + 2 * i];
  result[i] = t;
 }

 sresultp = resultp;

 result = toom_cook_4way(a1, b1, result);

 resultp = sresultp;

 for i = 0 to 512 {
  t = result[i];
  (u16) [resultp + 2 * i] = t;
 }
}


export fn pol_mul_p_jazz(reg u64 ap, reg u64 bp, reg u64 resp)
{
 inline int i;

 reg u16 t;

 stack u16[SABER_N] a;
 stack u16[SABER_N] b;
 stack u16[SABER_N] res;

 stack u64 sresp;

 for i = 0 to SABER_N {
  t = (u16) [ap + 2 * i];
  a[i] = t;
 }

 for i = 0 to SABER_N {
  t = (u16) [bp + 2 * i];
  b[i] = t;
 }

 sresp = resp;

 res = pol_mul_p(a, b, res);

 resp = sresp;

 for i = 0 to SABER_N {
  t = res[i];
  (u16) [resp + 2 * i] = t;
 }
}

export fn pol_mul_q_jazz(reg u64 ap, reg u64 bp, reg u64 resp)
{
 inline int i;

 reg u16 t;

 stack u16[SABER_N] a;
 stack u16[SABER_N] b;
 stack u16[SABER_N] res;

 stack u64 sresp;

 for i = 0 to SABER_N {
  t = (u16) [ap + 2 * i];
  a[i] = t;
 }

 for i = 0 to SABER_N {
  t = (u16) [bp + 2 * i];
  b[i] = t;
 }

 sresp = resp;

 res = pol_mul_q(a, b, res);

 resp = sresp;

 for i = 0 to SABER_N {
  t = res[i];
  (u16) [resp + 2 * i] = t;
 }
}
