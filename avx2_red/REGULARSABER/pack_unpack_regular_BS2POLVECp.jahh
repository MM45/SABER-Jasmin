/*** pack_unpack_regular_BS2POLVECp.jahh: File containing the Jasmin implementation of the BS2POLVECp function from pack_unpack.c, with (regular) SABER parameters ***/

#ifndef BS2POLVECP_HH
#define BS2POLVECP_HH

#include "SABER_params.jahh"

fn BS2POLVECp(reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u16[SABER_KN]
{
	reg u16 b1;
	reg u16 b2;
	
	reg u64 i;
	reg u64 j;
	reg u64 address_bytes;
	reg u64 address_data;

	i = 0;
	address_bytes = 0;
	address_data = 0;
	while (i < SABER_K) {
		j = 0;
		while (j < (SABER_N / 4)) {
			// data[i][offset_data + 0]= ( bytes[ offset_byte + 0 ] & (0xff)) |  ((bytes[ offset_byte + 1 ] & 0x03)<<8);
			b1 = (16u) bytes[(int) address_bytes];
			b1 &= 0xff;
			address_bytes += 1;
			b2 = (16u) bytes[(int) address_bytes];
			b2 &= 0x03;
			b2 <<= 8;
			b1 |= b2;
			data[(int) address_data] = b1;
			
			// data[i][offset_data + 1]= ( (bytes[ offset_byte + 1 ]>>2) & (0x3f)) |  ((bytes[ offset_byte + 2 ] & 0x0f)<<6);		
			b1 = (16u) bytes[(int) address_bytes];
			b1 >>= 2;
			b1 &= 0x3f;
			address_bytes += 1;
			b2 = (16u) bytes[(int) address_bytes];
			b2 &= 0x0f;
			b2 <<= 6;
			b1 |= b2;
			address_data += 1;
			data[(int) address_data] = b1;

			// data[i][offset_data + 2]= ( (bytes[ offset_byte + 2 ]>>4) & (0x0f)) |  ((bytes[ offset_byte + 3 ] & 0x3f)<<4);
			b1 = (16u) bytes[(int) address_bytes];
			b1 >>= 4;
			b1 &= 0x0f;
			address_bytes += 1;
			b2 = (16u) bytes[(int) address_bytes];
			b2 &= 0x3f;
			b2 <<= 4;
			b1 |= b2;
			address_data += 1;
			data[(int) address_data] = b1;

			// data[i][offset_data + 3]= ( (bytes[ offset_byte + 3 ]>>6) & (0x03)) |  ((bytes[ offset_byte + 4 ] & 0xff)<<2);
			b1 = (16u) bytes[(int) address_bytes];
			b1 >>= 6;
			b1 &= 0x03;
			address_bytes += 1;
			b2 = (16u) bytes[(int) address_bytes];
			b2 &= 0xff;
			b2 <<= 2;
			b1 |= b2;
			address_data += 1;
			data[(int) address_data] = b1;
			
			j += 1;
			address_bytes += 1;
			address_data += 1;
		}
		i += 1;
	}

	return data;
}

#endif