/*** pack_unpack_regular_BS2POLVECp.jahh: File containing the Jasmin implementation of the BS2POLVECp function from pack_unpack.c, with (regular) SABER parameters ***/

#ifndef BS2POLVECP_HH
#define BS2POLVECP_HH

#include "SABER_params.jahh"

u256 twobit_mask_glob = 0x0003000300030003000300030003000300030003000300030003000300030003;
u256 fourbit_mask_glob = 0x000f000f000f000f000f000f000f000f000f000f000f000f000f000f000f000f;
u256 sixbit_mask_glob = 0x003f003f003f003f003f003f003f003f003f003f003f003f003f003f003f003f;

fn BS2POLVECp(reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u16[SABER_KN]
{
/*
	inline int i;
	inline int j;
	inline int k;

	reg u128 zero_offset128;
	reg u128 one_offset128;
	reg u128 two_offset128;
	reg u128 three_offset128;
	reg u128 four_offset128;

	reg u256 zero_offset256;
	reg u256[2] one_offset256;
	reg u256[2] two_offset256;
	reg u256[2] three_offset256;
	reg u256 four_offset256;
	reg u256[4] t256;
	reg u256[4] r;
	reg u256[4] ord_r;

	reg u256 twobit_mask;
	reg u256 fourbit_mask;
	reg u256 sixbit_mask;

	stack u8[96] tbytes;

	zero_offset128 = zero_u128;
	one_offset128 = zero_u128;
	two_offset128 = zero_u128;
	three_offset128 = zero_u128;
	four_offset128 = zero_u128;

	twobit_mask = twobit_mask_glob;
	fourbit_mask = fourbit_mask_glob;
	sixbit_mask = sixbit_mask_glob;

	//for i = 0 to SABER_K {
	//	for j = 0 to SABER_N / 64 {
			tbytes[u256 0] = bytes[u256 0];
			tbytes[u256 1] = bytes[u256 1];
			tbytes[u256 2] = bytes[u256 2];

			for k = 0 to 16 {
				zero_offset128 = #VPINSR_16u8(zero_offset128, tbytes[5 * k], k);
				one_offset128 = #VPINSR_16u8(one_offset128, tbytes[1 + 5 * k], k);
				two_offset128 = #VPINSR_16u8(two_offset128, tbytes[2 + 5 * k], k);
				three_offset128 = #VPINSR_16u8(three_offset128, tbytes[3 + 5 * k], k);
				four_offset128 = #VPINSR_16u8(four_offset128, tbytes[4 + 5 * k], k);
			}

			zero_offset256 = (256u) zero_offset128;
			one_offset256[0] = (256u) one_offset128; // #VPMOVZXBW(one_offset128);
			one_offset256[1] = (256u) one_offset128;
			two_offset256[0] = (256u) two_offset128;
			two_offset256[1] = (256u) two_offset128;
			three_offset256[0] = (256u) three_offset128;
			three_offset256[1] = (256u) three_offset128;
			four_offset256 = (256u) four_offset128;

			one_offset256[0] &= twobit_mask;
			two_offset256[0] &= fourbit_mask;
			three_offset256[0] &= sixbit_mask;

			one_offset256[1] >>16u16= 2;
			two_offset256[1] >>16u16= 4;
			three_offset256[1] >>16u16= 6;			

			one_offset256[0] <<16u16= 8;
			two_offset256[0] <<16u16= 6;
			three_offset256[0] <<16u16= 4;
			four_offset256 <<16u16= 2;

			one_offset256[1] &= sixbit_mask;
			two_offset256[1] &= fourbit_mask;
			three_offset256[1] &= twobit_mask;

			t256[0] = zero_offset256 | one_offset256[0]; // d[0]d[4]..d[56]d[60]
			t256[1] = one_offset256[1] | two_offset256[0];  // d[1]d[5]..d[57]d[61]
			t256[2] = two_offset256[1] | three_offset256[0]; // d[2]d[6]..d[58]d[62]
			t256[3] = three_offset256[1] | four_offset256;  // d[3]d[7]..d[59]d[63]

			r[0] = #VPUNPCKL_16u16(t256[0], t256[2]); // d[0]d[2]..d[14]d[32]..d[44]d[46]
			r[1] = #VPUNPCKL_16u16(t256[1], t256[3]); // d[1]d[3]..d[15]d[33]..d[45]d[47]
			r[2] = #VPUNPCKH_16u16(t256[0], t256[2]); // d[16]d[18]..d[30]d[48]..d[60]d[62]
			r[3] = #VPUNPCKH_16u16(t256[1], t256[3]); // d[17]d[19]..d[31]d[49]..d[61]d[63]

			r[0] = #VPERMQ(r[0], 216); // d[0]..d[6]d[32]..d[38]d[8]..d[14]d[40]..d[46]
			r[1] = #VPERMQ(r[1], 216); // d[1]..d[7]d[33]..d[39]d[9]..d[15]d[41]..d[47]
			r[2] = #VPERMQ(r[2], 216); // d[16]..d[22]d[48]..d[54]d[24]..d[30]d[56]..d[62]
			r[3] = #VPERMQ(r[3], 216); // d[17]..d[23]d[49]..d[55]d[25]..d[31]d[57]..d[63]

			ord_r[0] = #VPUNPCKL_16u16(r[0], r[1]); // d[0]d[1]..d[14]d[15]
			ord_r[1] = #VPUNPCKL_16u16(r[2], r[3]); // d[16]d[17]..d[31]d[31]
			ord_r[2] = #VPUNPCKH_16u16(r[0], r[1]); // d[32]d[33]..d[46]d[47]
			ord_r[3] = #VPUNPCKH_16u16(r[2], r[3]); // d[48]d[49]..d[62]d[63]

			data[u256 0] = ord_r[0];
			data[u256 1] = ord_r[1];
			data[u256 2] = ord_r[2];
			data[u256 3] = ord_r[3];
	//	}
	//}
*/

	reg u16 b1;
	reg u16 b2;
	
	reg u64 i;
	reg u64 j;
	reg u64 address_bytes;
	reg u64 address_data;

	i = 0;
	address_bytes = 0;
	address_data = 0;
	while (i < SABER_K) {
		j = 0;
		while (j < (SABER_N / 4)) {
			// data[i][offset_data + 0]= ( bytes[ offset_byte + 0 ] & (0xff)) |  ((bytes[ offset_byte + 1 ] & 0x03)<<8);
			b1 = (16u) bytes[(int) address_bytes];
			b1 &= 0xff;
			address_bytes += 1;
			b2 = (16u) bytes[(int) address_bytes];
			b2 &= 0x03;
			b2 <<= 8;
			b1 |= b2;
			data[(int) address_data] = b1;
			
			// data[i][offset_data + 1]= ( (bytes[ offset_byte + 1 ]>>2) & (0x3f)) |  ((bytes[ offset_byte + 2 ] & 0x0f)<<6);		
			b1 = (16u) bytes[(int) address_bytes];
			b1 >>= 2;
			b1 &= 0x3f;
			address_bytes += 1;
			b2 = (16u) bytes[(int) address_bytes];
			b2 &= 0x0f;
			b2 <<= 6;
			b1 |= b2;
			address_data += 1;
			data[(int) address_data] = b1;

			// data[i][offset_data + 2]= ( (bytes[ offset_byte + 2 ]>>4) & (0x0f)) |  ((bytes[ offset_byte + 3 ] & 0x3f)<<4);
			b1 = (16u) bytes[(int) address_bytes];
			b1 >>= 4;
			b1 &= 0x0f;
			address_bytes += 1;
			b2 = (16u) bytes[(int) address_bytes];
			b2 &= 0x3f;
			b2 <<= 4;
			b1 |= b2;
			address_data += 1;
			data[(int) address_data] = b1;

			// data[i][offset_data + 3]= ( (bytes[ offset_byte + 3 ]>>6) & (0x03)) |  ((bytes[ offset_byte + 4 ] & 0xff)<<2);
			b1 = (16u) bytes[(int) address_bytes];
			b1 >>= 6;
			b1 &= 0x03;
			address_bytes += 1;
			b2 = (16u) bytes[(int) address_bytes];
			b2 &= 0xff;
			b2 <<= 2;
			b1 |= b2;
			address_data += 1;
			data[(int) address_data] = b1;
			
			j += 1;
			address_bytes += 1;
			address_data += 1;
		}
		i += 1;
	}

	return data;
}

#endif