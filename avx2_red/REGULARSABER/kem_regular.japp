








param int CRYPTO_SECRETKEYBYTES = 2304;
param int CRYPTO_PUBLICKEYBYTES = (3 * 320 + 32);
param int CRYPTO_BYTES = 32;
param int CRYPTO_CIPHERTEXTBYTES = 1088;
param int Saber_type = 2;

param int SABER_K = 3;
param int SABER_MU = 8;
param int SABER_ET = 4;

param int SABER_EQ = 13;
param int SABER_EP = 10;

param int SABER_N = 256;
param int SABER_Q = 8192;
param int SABER_P = 1024;

param int SABER_SEEDBYTES = 32;
param int SABER_NOISESEEDBYTES = 32;
param int SABER_COINBYTES = 32;
param int SABER_KEYBYTES = 32;

param int SABER_HASHBYTES = 32;

param int SABER_POLYBYTES = 416;

param int SABER_POLYVECBYTES = (SABER_K * SABER_POLYBYTES);

param int SABER_POLYVECCOMPRESSEDBYTES = (SABER_K * 320);

param int SABER_CIPHERTEXTBYTES = (SABER_POLYVECCOMPRESSEDBYTES);



param int SABER_SCALEBYTES_KEM = (SABER_ET * SABER_N / 8);

param int SABER_INDCPA_PUBLICKEYBYTES = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SEEDBYTES);
param int SABER_INDCPA_SECRETKEYBYTES = (SABER_POLYVECBYTES);

param int SABER_PUBLICKEYBYTES = (SABER_INDCPA_PUBLICKEYBYTES);

param int SABER_SECRETKEYBYTES = (SABER_INDCPA_SECRETKEYBYTES + SABER_INDCPA_PUBLICKEYBYTES + SABER_HASHBYTES + SABER_KEYBYTES);

param int SABER_BYTES_CCA_DEC = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SCALEBYTES_KEM);



param int SABER_KN = (SABER_K * SABER_N);
param int SABER_KKN = (SABER_K * SABER_K * SABER_N);
param int N_SB = (SABER_N / 4);
param int N_SB_RES = (2 * N_SB - 1);

param int SHAKE128_RATE = 168;
param int SHAKE256_RATE = 136;
param int SHA3_256_RATE = 136;
param int SHA3_512_RATE = 72;

param int KK13N8 = (SABER_K * SABER_K * (13 * SABER_N / 8));
param int MUNK8 = (SABER_MU * SABER_N * SABER_K / 8);

param int h1 = 4;
param int h2 = 228;




u16 h1_u16 = h1;
u16 h2_u16 = h2;
u16 modp_u16 = SABER_P - 1;
u16 modq_u16 = SABER_Q - 1;

u128 zero_u128 = 0;
u256 zero_u256 = 0;

















u64[24] KeccakF_RoundConstants = {0x0000000000000001, 0x0000000000008082, 0x800000000000808a, 0x8000000080008000,
                                    0x000000000000808b, 0x0000000080000001, 0x8000000080008081, 0x8000000000008009,
                                    0x000000000000008a, 0x0000000000000088, 0x0000000080008009, 0x000000008000000a,
                                    0x000000008000808b, 0x800000000000008b, 0x8000000000008089, 0x8000000000008003,
                                    0x8000000000008002, 0x8000000000000080, 0x000000000000800a, 0x800000008000000a,
                                    0x8000000080008081, 0x8000000000008080, 0x0000000080000001, 0x8000000080008008};

fn KeccakF1600_StatePermute(reg ptr u64[25] state) -> reg ptr u64[25]
{

  inline int round;

  reg u64 Da, De, Di;

  reg u64[5] C;
  reg u64[5] T;

  stack u64 Do, Du;

  stack u64[25] E;

  for round = 0 to 12 {


    C[0] = state[0];
    C[1] = state[1];
    C[2] = state[2];
    C[3] = state[3];
    C[4] = state[4];

    C[0] ^= state[5];
    C[1] ^= state[6];
    C[2] ^= state[7];
    C[3] ^= state[8];
    C[4] ^= state[9];

    C[0] ^= state[10];
    C[1] ^= state[11];
    C[2] ^= state[12];
    C[3] ^= state[13];
    C[4] ^= state[14];

    C[0] ^= state[15];
    C[1] ^= state[16];
    C[2] ^= state[17];
    C[3] ^= state[18];
    C[4] ^= state[19];

    C[0] ^= state[20];
    C[1] ^= state[21];
    C[2] ^= state[22];
    C[3] ^= state[23];
    C[4] ^= state[24];

    Da = C[1];
    De = C[2];
    Di = C[3];
    Do = C[4];
    Du = C[0];

    _, _, Da = #ROL_64(Da, 1);
    _, _, De = #ROL_64(De, 1);
    _, _, Di = #ROL_64(Di, 1);
    _, _, Do = #ROL_64(Do, 1);
    _, _, Du = #ROL_64(Du, 1);

    Da ^= C[4];
    De ^= C[0];
    Di ^= C[1];
    Do ^= C[2];
    Du ^= C[3];


    C[0] = state[0];
    C[1] = state[6];
    C[2] = state[12];
    C[3] = state[18];
    C[4] = state[24];

    C[0] ^= Da;
    C[1] ^= De;
    C[2] ^= Di;
    C[3] ^= Do;
    C[4] ^= Du;

    _, _, C[1] = #ROL_64(C[1], 44);
    _, _, C[2] = #ROL_64(C[2], 43);
    _, _, C[3] = #ROL_64(C[3], 21);
    _, _, C[4] = #ROL_64(C[4], 14);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    T[0] ^= KeccakF_RoundConstants[2 * round];
    E[0] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    E[1] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    E[2] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    E[3] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    E[4] = T[4];


    C[0] = state[3];
    C[1] = state[9];
    C[2] = state[10];
    C[3] = state[16];
    C[4] = state[22];

    C[0] ^= Do;
    C[1] ^= Du;
    C[2] ^= Da;
    C[3] ^= De;
    C[4] ^= Di;

    _, _, C[0] = #ROL_64(C[0], 28);
    _, _, C[1] = #ROL_64(C[1], 20);
    _, _, C[2] = #ROL_64(C[2], 3);
    _, _, C[3] = #ROL_64(C[3], 45);
    _, _, C[4] = #ROL_64(C[4], 61);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    E[5] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    E[6] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    E[7] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    E[8] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    E[9] = T[4];


    C[0] = state[1];
    C[1] = state[7];
    C[2] = state[13];
    C[3] = state[19];
    C[4] = state[20];

    C[0] ^= De;
    C[1] ^= Di;
    C[2] ^= Do;
    C[3] ^= Du;
    C[4] ^= Da;

    _, _, C[0] = #ROL_64(C[0], 1);
    _, _, C[1] = #ROL_64(C[1], 6);
    _, _, C[2] = #ROL_64(C[2], 25);
    _, _, C[3] = #ROL_64(C[3], 8);
    _, _, C[4] = #ROL_64(C[4], 18);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    E[10] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    E[11] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    E[12] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    E[13] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    E[14] = T[4];


    C[0] = state[4];
    C[1] = state[5];
    C[2] = state[11];
    C[3] = state[17];
    C[4] = state[23];

    C[0] ^= Du;
    C[1] ^= Da;
    C[2] ^= De;
    C[3] ^= Di;
    C[4] ^= Do;

    _, _, C[0] = #ROL_64(C[0], 27);
    _, _, C[1] = #ROL_64(C[1], 36);
    _, _, C[2] = #ROL_64(C[2], 10);
    _, _, C[3] = #ROL_64(C[3], 15);
    _, _, C[4] = #ROL_64(C[4], 56);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    E[15] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    E[16] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    E[17] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    E[18] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    E[19] = T[4];


    C[0] = state[2];
    C[1] = state[8];
    C[2] = state[14];
    C[3] = state[15];
    C[4] = state[21];

    C[0] ^= Di;
    C[1] ^= Do;
    C[2] ^= Du;
    C[3] ^= Da;
    C[4] ^= De;

    _, _, C[0] = #ROL_64(C[0], 62);
    _, _, C[1] = #ROL_64(C[1], 55);
    _, _, C[2] = #ROL_64(C[2], 39);
    _, _, C[3] = #ROL_64(C[3], 41);
    _, _, C[4] = #ROL_64(C[4], 2);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    E[20] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    E[21] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    E[22] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    E[23] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    E[24] = T[4];




    C[0] = E[0];
    C[1] = E[1];
    C[2] = E[2];
    C[3] = E[3];
    C[4] = E[4];

    C[0] ^= E[5];
    C[1] ^= E[6];
    C[2] ^= E[7];
    C[3] ^= E[8];
    C[4] ^= E[9];

    C[0] ^= E[10];
    C[1] ^= E[11];
    C[2] ^= E[12];
    C[3] ^= E[13];
    C[4] ^= E[14];

    C[0] ^= E[15];
    C[1] ^= E[16];
    C[2] ^= E[17];
    C[3] ^= E[18];
    C[4] ^= E[19];

    C[0] ^= E[20];
    C[1] ^= E[21];
    C[2] ^= E[22];
    C[3] ^= E[23];
    C[4] ^= E[24];

    Da = C[1];
    De = C[2];
    Di = C[3];
    Do = C[4];
    Du = C[0];

    _, _, Da = #ROL_64(Da, 1);
    _, _, De = #ROL_64(De, 1);
    _, _, Di = #ROL_64(Di, 1);
    _, _, Do = #ROL_64(Do, 1);
    _, _, Du = #ROL_64(Du, 1);

    Da ^= C[4];
    De ^= C[0];
    Di ^= C[1];
    Do ^= C[2];
    Du ^= C[3];


    C[0] = E[0];
    C[1] = E[6];
    C[2] = E[12];
    C[3] = E[18];
    C[4] = E[24];

    C[0] ^= Da;
    C[1] ^= De;
    C[2] ^= Di;
    C[3] ^= Do;
    C[4] ^= Du;

    _, _, C[1] = #ROL_64(C[1], 44);
    _, _, C[2] = #ROL_64(C[2], 43);
    _, _, C[3] = #ROL_64(C[3], 21);
    _, _, C[4] = #ROL_64(C[4], 14);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    T[0] ^= KeccakF_RoundConstants[2 * round + 1];
    state[0] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    state[1] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    state[2] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    state[3] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    state[4] = T[4];


    C[0] = E[3];
    C[1] = E[9];
    C[2] = E[10];
    C[3] = E[16];
    C[4] = E[22];

    C[0] ^= Do;
    C[1] ^= Du;
    C[2] ^= Da;
    C[3] ^= De;
    C[4] ^= Di;

    _, _, C[0] = #ROL_64(C[0], 28);
    _, _, C[1] = #ROL_64(C[1], 20);
    _, _, C[2] = #ROL_64(C[2], 3);
    _, _, C[3] = #ROL_64(C[3], 45);
    _, _, C[4] = #ROL_64(C[4], 61);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    state[5] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    state[6] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    state[7] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    state[8] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    state[9] = T[4];


    C[0] = E[1];
    C[1] = E[7];
    C[2] = E[13];
    C[3] = E[19];
    C[4] = E[20];

    C[0] ^= De;
    C[1] ^= Di;
    C[2] ^= Do;
    C[3] ^= Du;
    C[4] ^= Da;

    _, _, C[0] = #ROL_64(C[0], 1);
    _, _, C[1] = #ROL_64(C[1], 6);
    _, _, C[2] = #ROL_64(C[2], 25);
    _, _, C[3] = #ROL_64(C[3], 8);
    _, _, C[4] = #ROL_64(C[4], 18);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    state[10] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    state[11] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    state[12] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    state[13] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    state[14] = T[4];


    C[0] = E[4];
    C[1] = E[5];
    C[2] = E[11];
    C[3] = E[17];
    C[4] = E[23];

    C[0] ^= Du;
    C[1] ^= Da;
    C[2] ^= De;
    C[3] ^= Di;
    C[4] ^= Do;

    _, _, C[0] = #ROL_64(C[0], 27);
    _, _, C[1] = #ROL_64(C[1], 36);
    _, _, C[2] = #ROL_64(C[2], 10);
    _, _, C[3] = #ROL_64(C[3], 15);
    _, _, C[4] = #ROL_64(C[4], 56);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    state[15] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    state[16] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    state[17] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    state[18] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    state[19] = T[4];


    C[0] = E[2];
    C[1] = E[8];
    C[2] = E[14];
    C[3] = E[15];
    C[4] = E[21];

    C[0] ^= Di;
    C[1] ^= Do;
    C[2] ^= Du;
    C[3] ^= Da;
    C[4] ^= De;

    _, _, C[0] = #ROL_64(C[0], 62);
    _, _, C[1] = #ROL_64(C[1], 55);
    _, _, C[2] = #ROL_64(C[2], 39);
    _, _, C[3] = #ROL_64(C[3], 41);
    _, _, C[4] = #ROL_64(C[4], 2);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    state[20] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    state[21] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    state[22] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    state[23] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    state[24] = T[4];
  }

  return state;
}







fn keccak_absorb_128_32(reg ptr u64[25] s, reg ptr u8[32] m) -> reg ptr u64[25]
{
 inline int i;

 reg u256 m256;
 reg u256 s256;

 s256 = s[u256 0];
 m256 = m[u256 0];
 s256 ^= m256;
 s[u256 0] = s256;

 s[u8 32] ^= 0x1F;
 s[u8 SHAKE128_RATE - 1] ^= 0x80;

 return s;
}

inline fn shake128_32_32(reg ptr u8[32] output, reg ptr u8[32] input) -> reg ptr u8[32]
{
 inline int i;

 reg u8 t8;

 reg u256 t256;

 stack u64[25] s;

 t256 = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256;
 }
 s[24] = 0;

 s = keccak_absorb_128_32(s, input);

 s = KeccakF1600_StatePermute(s);

 t256 = s[u256 0];
 output[u256 0] = t256;

 return output;
}






fn keccak_squeezeblocks_128_128(reg ptr u8[SHAKE128_RATE] h, reg ptr u64[25] s) -> reg ptr u8[SHAKE128_RATE], reg ptr u64[25]
{
 inline int i;

 reg u64 t64;

 s = KeccakF1600_StatePermute(s);

 for i = 0 to SHAKE128_RATE / 8 {
  t64 = s[u64 i];
  h[u64 i] = t64;
 }

 return h, s;
}

inline fn shake128_KK13N8_32(reg ptr u8[KK13N8] output, reg ptr u8[32] input) -> reg ptr u8[KK13N8]
{
 inline int i;
 inline int nblocks;

 reg u128[3] t128;
 reg u256 t256;

 stack u64[25] s;

 nblocks = 22;

 t256 = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256;
 }
 s[24] = 0;

 s = keccak_absorb_128_32(s, input);


 for i = 0 to nblocks {
  output[i * SHAKE128_RATE:SHAKE128_RATE], s = keccak_squeezeblocks_128_128(output[i * SHAKE128_RATE:SHAKE128_RATE], s);
 }

 s = KeccakF1600_StatePermute(s);

 t128[0] = s[u128 0];
 t128[1] = s[u128 1];
 t128[2] = s[u128 2];

 output[u128 231] = t128[0];
 output[u128 232] = t128[1];
 output[u128 233] = t128[2];

 return output;
}







fn BS2POLq(reg ptr u8[SABER_POLYBYTES] bytes, reg ptr u16[SABER_N] data) -> reg ptr u16[SABER_N]
{
 reg u32 b1;
 reg u32 b2;
 reg u32 b3;

 reg u64[3] address_byte;
 reg u64 address_data;

 address_byte[0] = 0;
 address_byte[1] = 1;
 address_byte[2] = 2;

 address_data = 0;

 while (address_data < SABER_N) {

  b2 = (32u) bytes[(int) address_byte[1]];
  b1 = (32u) bytes[(int) address_byte[0]];
  address_byte[0] += 3;
  b2 <<= 8;
  b2 &= 0x1f00;
  b1 |= b2;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b1 = (32u) bytes[(int) address_byte[1]];
  b2 = (32u) bytes[(int) address_byte[2]];
  address_byte[1] += 3;
  address_byte[2] += 3;
  b1 >>= 5;
  b2 <<= 3;
  b1 |= b2;
  b3 = (32u) bytes[(int) address_byte[0]];
  b3 <<= 11;
  b3 &= 0x1800;
  b1 |= b3;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b2 = (32u) bytes[(int) address_byte[1]];
  b1 = (32u) bytes[(int) address_byte[0]];
  address_byte[0] += 3;
  b2 <<= 6;
  b1 >>= 2;
  b2 &= 0x1fc0;
  b1 |= b2;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b1 = (32u) bytes[(int) address_byte[1]];
  b2 = (32u) bytes[(int) address_byte[2]];
  address_byte[1] += 3;
  address_byte[2] += 3;
  b1 >>= 7;
  b2 += b2;
  b1 |= b2;
  b3 = (32u) bytes[(int) address_byte[0]];
  b3 <<= 9;
  b3 &= 0x1e00;
  b1 |= b3;
  data[(int) address_data] = b1;
  address_data += 1;


  b1 = (32u) bytes[(int) address_byte[0]];
  b2 = (32u) bytes[(int) address_byte[1]];
  address_byte[0] += 3;
  address_byte[1] += 3;
  b1 >>= 4;
  b2 <<= 4;
  b1 |= b2;
  b3 = (32u) bytes[(int) address_byte[2]];
  b3 <<= 12;
  b3 &= 0x1000;
  b1 |= b3;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b2 = (32u) bytes[(int) address_byte[0]];
  b1 = (32u) bytes[(int) address_byte[2]];
  address_byte[2] += 3;
  b2 <<= 7;
  b1 >>= 1;
  b2 &= 0x1f80;
  b1 |= b2;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b1 = (32u) bytes[(int) address_byte[0]];
  b2 = (32u) bytes[(int) address_byte[1]];
  address_byte[0] += 3;
  b1 >>= 6;
  b2 <<= 2;
  b1 |= b2;
  b3 = (32u) bytes[(int) address_byte[2]];
  b3 <<= 10;
  b3 &= 0x1c00;
  b1 |= b3;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b1 = (32u) bytes[(int) address_byte[2]];
  b2 = (32u) bytes[(int) address_byte[0]];
  address_byte[0] += 1;
  address_byte[1] += 4;
  address_byte[2] += 4;
  b1 >>= 3;
  b2 <<= 5;
  b1 |= b2;
  data[(int) address_data] = (16u) b1;
  address_data += 1;
 }

 return data;
}

u256 qmod_glob = 0x1fff1fff1fff1fff1fff1fff1fff1fff1fff1fff1fff1fff1fff1fff1fff1fff;

fn GenMatrix(reg ptr u16[SABER_KKN] a, reg ptr u8[SABER_SEEDBYTES] seed) -> reg ptr u16[SABER_KKN]
{

 inline int i;
 inline int k;

 reg u16 t16;

 reg u256 qmod;
 reg u256 t256;

 stack u8[KK13N8] buf;

 stack ptr u16[SABER_KKN] sa;

 qmod = qmod_glob;

 sa = a;

 buf = shake128_KK13N8_32(buf, seed);

 a = sa;


 for i = 0 to SABER_K * SABER_K {
  a[i * SABER_N:SABER_N] = BS2POLq(buf[i * (13 * SABER_N / 8):SABER_POLYBYTES], a[i * SABER_N:SABER_N]);
 }


 for k = 0 to SABER_KKN / 16 {
  t256 = qmod & a[u256 k];
  a[u256 k] = t256;
 }
 return a;
}






inline fn shake128_MUNK8_32(reg ptr u8[MUNK8] output, reg ptr u8[32] input) -> reg ptr u8[MUNK8]
{
 inline int i;
 inline int nblocks;

 reg u256[3] t256;

 stack u64[25] s;

 nblocks = 4;

 t256[0] = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256[0];
 }
 s[24] = 0;

 s = keccak_absorb_128_32(s, input);


 for i = 0 to nblocks {
  output[i * SHAKE128_RATE:SHAKE128_RATE], s = keccak_squeezeblocks_128_128(output[i * SHAKE128_RATE:SHAKE128_RATE], s);
 }

 s = KeccakF1600_StatePermute(s);

 t256[0] = s[u256 0];
 t256[1] = s[u256 1];
 t256[2] = s[u256 2];

 output[u256 21] = t256[0];
 output[u256 22] = t256[1];
 output[u256 23] = t256[2];

 return output;
}







u256 one_mask_glob = 0x1111111111111111111111111111111111111111111111111111111111111111;
u256 f_mask_glob = 0x0000000f0000000f0000000f0000000f0000000f0000000f0000000f0000000f;
u256 qmod_mask_glob = 0x00001fff00001fff00001fff00001fff00001fff00001fff00001fff00001fff;
u256 sixteen_bit_mask_glob = 0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff;

fn cbd(reg ptr u16[SABER_N] r, reg ptr u8[SABER_N] buf) -> reg ptr u16[SABER_N]
{
    inline int i;

    reg u256 tt256;
    reg u256 one_mask;
    reg u256 f_mask;
    reg u256 qmod;
    reg u256 sixteen_bit_mask;

    reg u256[2] d256;
    reg u256[2] t256;
    reg u256[2] a256;
    reg u256[2] b256;
    reg u256[4] r256;
    reg u256[2] ord256;

    one_mask = one_mask_glob;
    f_mask = f_mask_glob;
    qmod = qmod_mask_glob;
    sixteen_bit_mask = sixteen_bit_mask_glob;

    for i = 0 to (SABER_N / 64) {
        t256[0] = buf[u256 2 * i];
        t256[1] = buf[u256 2 * i + 1];

        d256[0] = t256[0] & one_mask;

        tt256 = t256[0] >>8u32 1;
        tt256 &= one_mask;
        d256[0] +8u32= tt256;

        tt256 = t256[0] >>8u32 2;
        tt256 &= one_mask;
        d256[0] +8u32= tt256;

        tt256 = t256[0] >>8u32 3;
        tt256 &= one_mask;
        d256[0] +8u32= tt256;

        d256[1] = t256[1] & one_mask;

        tt256 = t256[1] >>8u32 1;
        tt256 &= one_mask;
        d256[1] +8u32= tt256;

        tt256 = t256[1] >>8u32 2;
        tt256 &= one_mask;
        d256[1] +8u32= tt256;

        tt256 = t256[1] >>8u32 3;
        tt256 &= one_mask;
        d256[1] +8u32= tt256;


        a256[0] = d256[0] & f_mask;

        b256[0] = d256[0] >>8u32 4;
        b256[0] &= f_mask;

        a256[1] = d256[1] & f_mask;

        b256[1] = d256[1] >>8u32 4;
        b256[1] &= f_mask;

        t256[0] = a256[0] -8u32 b256[0];
        t256[1] = a256[1] -8u32 b256[1];

        t256[0] &= sixteen_bit_mask;
        t256[1] &= sixteen_bit_mask;
        t256[0] &= qmod;
        t256[1] &= qmod;

        r256[0] = #VPACKUS_8u32(t256[0], t256[1]);


        a256[0] = d256[0] >>8u32 8;
        a256[0] &= f_mask;

        b256[0] = d256[0] >>8u32 12;
        b256[0] &= f_mask;

        a256[1] = d256[1] >>8u32 8;
        a256[1] &= f_mask;

        b256[1] = d256[1] >>8u32 12;
        b256[1] &= f_mask;

        t256[0] = a256[0] -8u32 b256[0];
        t256[1] = a256[1] -8u32 b256[1];

        t256[0] &= sixteen_bit_mask;
        t256[1] &= sixteen_bit_mask;
        t256[0] &= qmod;
        t256[1] &= qmod;

        r256[1] = #VPACKUS_8u32(t256[0], t256[1]);


        a256[0] = d256[0] >>8u32 16;
        a256[0] &= f_mask;

        b256[0] = d256[0] >>8u32 20;
        b256[0] &= f_mask;

        a256[1] = d256[1] >>8u32 16;
        a256[1] &= f_mask;

        b256[1] = d256[1] >>8u32 20;
        b256[1] &= f_mask;

        t256[0] = a256[0] -8u32 b256[0];
        t256[1] = a256[1] -8u32 b256[1];

        t256[0] &= sixteen_bit_mask;
        t256[1] &= sixteen_bit_mask;
        t256[0] &= qmod;
        t256[1] &= qmod;

        r256[2] = #VPACKUS_8u32(t256[0], t256[1]);


        a256[0] = d256[0] >>8u32 24;
        a256[0] &= f_mask;

        b256[0] = d256[0] >>8u32 28;

        a256[1] = d256[1] >>8u32 24;
        a256[1] &= f_mask;

        b256[1] = d256[1] >>8u32 28;

        t256[0] = a256[0] -8u32 b256[0];
        t256[1] = a256[1] -8u32 b256[1];

        t256[0] &= sixteen_bit_mask;
        t256[1] &= sixteen_bit_mask;
        t256[0] &= qmod;
        t256[1] &= qmod;

        r256[3] = #VPACKUS_8u32(t256[0], t256[1]);

        t256[0] = #VPUNPCKL_16u16(r256[0], r256[2]);
        t256[1] = #VPUNPCKL_16u16(r256[1], r256[3]);
        t256[0] = #VPERMQ(t256[0], 216);
        t256[1] = #VPERMQ(t256[1], 216);

        ord256[0] = #VPUNPCKL_16u16(t256[0], t256[1]);
        ord256[1] = #VPUNPCKH_16u16(t256[0], t256[1]);

        r[u256 4 * i] = ord256[0];
        r[u256 4 * i + 1] = ord256[1];

        t256[0] = #VPUNPCKH_16u16(r256[0], r256[2]);
        t256[1] = #VPUNPCKH_16u16(r256[1], r256[3]);
        t256[0] = #VPERMQ(t256[0], 216);
        t256[1] = #VPERMQ(t256[1], 216);

        ord256[0] = #VPUNPCKL_16u16(t256[0], t256[1]);
        ord256[1] = #VPUNPCKH_16u16(t256[0], t256[1]);

        r[u256 4 * i + 2] = ord256[0];
        r[u256 4 * i + 3] = ord256[1];
    }

 return r;
}

fn GenSecret(reg ptr u16[SABER_KN] r, reg ptr u8[SABER_COINBYTES] seed) -> reg ptr u16[SABER_KN]
{
 inline int i;

 stack u8[MUNK8] buf;

 stack ptr u16[SABER_KN] sr;

 sr = r;

 buf = shake128_MUNK8_32(buf, seed);

 r = sr;

 for i = 0 to SABER_K {
  r[i * SABER_N:SABER_N] = cbd(r[i * SABER_N:SABER_N], buf[i * SABER_MU * SABER_N / 8:SABER_N]);
 }

 return r;
}







inline fn POLVECq2BS(reg ptr u8[SABER_POLYVECBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u8[SABER_POLYVECBYTES]
{
 reg u16 d1;
 reg u16 d2;

 reg u64 i;
 reg u64 j;
 reg u64 address_bytes;
 reg u64 address_data;

 i = 0;
 address_bytes = 0;
 address_data = 0;
 while (i < SABER_K) {
  j = 0;
  while (j < (SABER_N / 8)) {

   d1 = data[(int) address_data];
   d1 &= 0xff;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 8;
   d1 &= 0x1f;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x07;
   d2 <<= 5;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 3;
   d1 &= 0xff;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 11;
   d1 &= 0x03;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x3f;
   d2 <<= 2;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 6;
   d1 &= 0x7f;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x01;
   d2 <<= 7;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 1;
   d1 &= 0xff;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 9;
   d1 &= 0x0f;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x0f;
   d2 <<= 4;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 4;
   d1 &= 0xff;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 12;
   d1 &= 0x01;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x7f;
   d2 <<= 1;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 7;
   d1 &= 0x3f;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x03;
   d2 <<= 6;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 2;
   d1 &= 0xff;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 10;
   d1 &= 0x07;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x1f;
   d2 <<= 3;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 5;
   d1 &= 0xff;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;

   j += 1;
   address_bytes += 1;
   address_data += 1;
  }
  i += 1;
 }

 return bytes;
}







fn POLVECp2BS(reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES]
{
 reg u16 d1;
 reg u16 d2;

 reg u64 i;
 reg u64 j;
 reg u64 address_bytes;
 reg u64 address_data;

 i = 0;
 address_bytes = 0;
 address_data = 0;
 while (i < SABER_K) {
  j = 0;
  while (j < (SABER_N / 4)) {

   d1 = data[(int) address_data];
   d1 &= 0xff;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 8;
   d1 &= 0x03;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x3f;
   d2 <<= 2;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 6;
   d1 &= 0x0f;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x0f;
   d2 <<= 4;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 4;
   d1 &= 0x3f;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x03;
   d2 <<= 6;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 2;
   d1 &= 0xff;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;

   j += 1;
   address_bytes += 1;
   address_data += 1;
  }
  i += 1;
 }

 return bytes;
}








inline fn dummy_mv_mul(reg ptr u256[SABER_KKN / 16] a_avx, reg ptr u256[SABER_KN / 16] b_avx, reg ptr u256[SABER_KN / 16] res_avx) -> reg ptr u256[SABER_KN / 16]
{
 inline int i j k;

 reg u256 t256;

 for i = 0 to SABER_K {
  for j = 0 to SABER_K {
   for k = 0 to SABER_N / 16 {
    t256 = a_avx[i * SABER_KN / 16 + j * SABER_N / 16 + k];
    t256 ^= b_avx[j * SABER_N / 16 + k];
    t256 ^= res_avx[j * SABER_N / 16 + k];
    res_avx[j * SABER_N / 16 + k] = t256;
   }
  }
 }

 return res_avx;
}

inline fn indcpa_kem_keypair_randominc(stack u8[SABER_INDCPA_PUBLICKEYBYTES] pk, stack u8[SABER_INDCPA_SECRETKEYBYTES] sk, stack u8[SABER_SEEDBYTES] seed, stack u8[SABER_COINBYTES] noiseseed) -> stack u8[SABER_INDCPA_PUBLICKEYBYTES], stack u8[SABER_INDCPA_SECRETKEYBYTES]
{
 inline int i;

 reg u8 t8;

 reg u256 mod;
 reg u256 H1_avx;
 reg u256 t256;

 stack u16[SABER_KKN] a;
 stack u16[SABER_KN] skpv1;

 stack u256[SABER_KKN / 16] a_avx;
 stack u256[SABER_KN / 16] sk_avx;
 stack u256[SABER_KN / 16] res_avx;



 for i = 0 to SABER_KN / 16 {
  t256 = zero_u256;
  res_avx[i] = t256;
 }

 mod = #VPBROADCAST_16u16(modq_u16);
 H1_avx = #VPBROADCAST_16u16(h1_u16);


 seed = shake128_32_32(seed, seed);

 a = GenMatrix(a, seed);

 skpv1 = GenSecret(skpv1, noiseseed);

 for i = 0 to SABER_KN / 16 {
  t256 = skpv1[u256 i];
  sk_avx[i] = t256;
 }

 for i = 0 to SABER_KKN / 16 {
  t256 = a[u256 i];
  a_avx[i] = t256;
 }



 res_avx = dummy_mv_mul(a_avx, sk_avx, res_avx);

 for i = 0 to SABER_KN / 16 {
  t256 = res_avx[i];
  t256 +16u16= H1_avx;
  t256 >>16u16= (SABER_EQ - SABER_EP);
  t256 &16u16= mod;
  res_avx[i] = t256;
 }

 sk = POLVECq2BS(sk, skpv1);

 for i = 0 to SABER_KN / 16 {
  t256 = res_avx[i];
  skpv1[u256 i] = t256;
 }

 pk[0:SABER_POLYVECCOMPRESSEDBYTES] = POLVECp2BS(pk[0:SABER_POLYVECCOMPRESSEDBYTES], skpv1);

 for i = 0 to SABER_SEEDBYTES {
  t8 = seed[i];
  pk[SABER_POLYVECCOMPRESSEDBYTES + i] = t8;
 }

 return pk, sk;
}







fn keccak_absorb_256_single(reg ptr u64[25] s, reg ptr u8[SHA3_256_RATE] m) -> reg ptr u64[25]
{
 inline int j;

 reg u64 t64;

 for j = 0 to SHA3_256_RATE / 8 {
  t64 = m[u64 j];
  s[u64 j] ^= t64;
 }

 s = KeccakF1600_StatePermute(s);

 return s;
}

fn sha3_256_PUBKEYBYTES(reg ptr u8[32] output, reg ptr u8[SABER_INDCPA_PUBLICKEYBYTES] input) -> reg ptr u8[32]
{
 inline int i;
 inline int nblocks;

 reg u64 t64;

 reg u256 t256;

 stack u64[25] s;

 nblocks = 7;

 t256 = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256;
 }
 s[24] = 0;


 for i = 0 to nblocks {
  s = keccak_absorb_256_single(s, input[i * SHA3_256_RATE:SHA3_256_RATE]);
 }

 for i = 0 to 5 {
  t64 = input[u64 119 + i];
  s[u64 i] ^= t64;
 }

 s[u8 40] ^= 0x06;
 s[u8 SHA3_256_RATE - 1] ^= 0x80;

 s = KeccakF1600_StatePermute(s);

 t256 = s[u256 0];
 output[u256 0] = t256;

 return output;
}

inline fn crypto_kem_keypair_randominc(stack u8[SABER_PUBLICKEYBYTES] pk, stack u8[SABER_SECRETKEYBYTES] sk, stack u8[SABER_KEYBYTES] random_bytes_crypto, stack u8[SABER_SEEDBYTES] indcpa_seed, stack u8[SABER_COINBYTES] indcpa_noiseseed) -> stack u8[SABER_PUBLICKEYBYTES], stack u8[SABER_SECRETKEYBYTES]
{
 inline int j;

 reg u8 t8;

 reg u64 i;
 reg u64 address;

 pk, sk[0:SABER_INDCPA_SECRETKEYBYTES] = indcpa_kem_keypair_randominc(pk, sk[0:SABER_INDCPA_SECRETKEYBYTES], indcpa_seed, indcpa_noiseseed);

 i = 0;
 address = SABER_INDCPA_SECRETKEYBYTES;
 while (i < SABER_INDCPA_PUBLICKEYBYTES) {
  t8 = pk[(int) i];
  sk[(int) address] = t8;

  i += 1;
  address += 1;
 }

 sk[SABER_SECRETKEYBYTES - 64:SABER_HASHBYTES] = sha3_256_PUBKEYBYTES(sk[SABER_SECRETKEYBYTES - 64:SABER_HASHBYTES], pk);

 for j = 0 to SABER_KEYBYTES {
  t8 = random_bytes_crypto[j];
  sk[SABER_SECRETKEYBYTES - SABER_KEYBYTES + j] = t8;
 }

 return pk, sk;
}






inline fn sha3_256_32(reg ptr u8[32] output, reg ptr u8[32] input) -> reg ptr u8[32]
{
 inline int i;

 reg u256 t256;
 reg u256 s256;

 stack u64[25] s;

 t256 = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256;
 }
 s[24] = 0;


 t256 = input[u256 0];
 s256 = s[u256 0];
 s256 ^= t256;
 s[u256 0] = s256;

 s[u8 32] ^= 0x06;
 s[u8 SHA3_256_RATE - 1] ^= 0x80;


 s = KeccakF1600_StatePermute(s);

 t256 = s[u256 0];
 output[u256 0] = t256;

 return output;
}
fn sha3_256_64(reg ptr u8[32] output, reg ptr u8[64] input) -> reg ptr u8[32]
{
 inline int i;

 reg u256[2] t256;
 reg u256[2] s256;

 stack u64[25] s;

 t256[0] = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256[0];
 }
 s[24] = 0;


 t256[0] = input[u256 0];
 s256[0] = s[u256 0];
 t256[1] = input[u256 1];
 s256[1] = s[u256 1];

 s256[0] ^= t256[0];
 s256[1] ^= t256[1];

 s[u256 0] = s256[0];
 s[u256 1] = s256[1];

 s[u8 64] ^= 0x06;
 s[u8 SHA3_256_RATE - 1] ^= 0x80;


 s = KeccakF1600_StatePermute(s);

 t256[0] = s[u256 0];
 output[u256 0] = t256[0];

 return output;
}

fn sha3_256_CCADEC(reg ptr u8[32] output, reg ptr u8[SABER_BYTES_CCA_DEC] input) -> reg ptr u8[32]
{
 inline int i;
 inline int nblocks;

 reg u256 t256;

 stack u64[25] s;

 nblocks = 8;

 t256 = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256;
 }
 s[24] = 0;


 for i = 0 to nblocks {
  s = keccak_absorb_256_single(s, input[i * SHA3_256_RATE:SHA3_256_RATE]);
 }

 s[u8 0] ^= 0x06;
 s[u8 SHA3_256_RATE - 1] ^= 0x80;

 s = KeccakF1600_StatePermute(s);

 t256 = s[u256 0];
 output[u256 0] = t256;

 return output;
}
fn sha3_512_64(reg ptr u8[64] output, reg ptr u8[64] input) -> reg ptr u8[64]
{
 inline int i;

 reg u256[2] t256;
 reg u256[2] s256;

 stack u64[25] s;

 t256[0] = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256[0];
 }
 s[24] = 0;

 t256[0] = input[u256 0];
 t256[1] = input[u256 1];

 s256[0] = s[u256 0];
 s256[1] = s[u256 1];

 s256[0] ^= t256[0];
 s256[1] ^= t256[1];

 s[u256 0] = s256[0];
 s[u256 1] = s256[1];

 s[u8 64] ^= 0x06;
 s[u8 SHA3_512_RATE - 1] ^= 0x80;


 s = KeccakF1600_StatePermute(s);

 t256[0] = s[u256 0];
 t256[1] = s[u256 1];

 output[u256 0] = t256[0];
 output[u256 1] = t256[1];

 return output;
}







u256 twobit_mask_glob = 0x0003000300030003000300030003000300030003000300030003000300030003;
u256 fourbit_mask_glob = 0x000f000f000f000f000f000f000f000f000f000f000f000f000f000f000f000f;
u256 sixbit_mask_glob = 0x003f003f003f003f003f003f003f003f003f003f003f003f003f003f003f003f;

fn BS2POLVECp(reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u16[SABER_KN]
{
 reg u16 b1;
 reg u16 b2;

 reg u64 i;
 reg u64 j;
 reg u64 address_bytes;
 reg u64 address_data;

 i = 0;
 address_bytes = 0;
 address_data = 0;
 while (i < SABER_K) {
  j = 0;
  while (j < (SABER_N / 4)) {

   b1 = (16u) bytes[(int) address_bytes];
   b1 &= 0xff;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0x03;
   b2 <<= 8;
   b1 |= b2;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 2;
   b1 &= 0x3f;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0x0f;
   b2 <<= 6;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 4;
   b1 &= 0x0f;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0x3f;
   b2 <<= 4;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 6;
   b1 &= 0x03;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0xff;
   b2 <<= 2;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;

   j += 1;
   address_bytes += 1;
   address_data += 1;
  }
  i += 1;
 }

 return data;
}







u256 fourbit_mask_glob = 0x000f000f000f000f000f000f000f000f000f000f000f000f000f000f000f000f;

inline fn SABER_pack_4bit(reg ptr u8[SABER_SCALEBYTES_KEM] bytes, reg ptr u16[SABER_N] data) -> reg ptr u8[SABER_SCALEBYTES_KEM]
{

 inline int i, j;

 reg u128[4] zero_offset128;
 reg u128[4] one_offset128;

 reg u256[2] zero_offset256;
 reg u256[2] one_offset256;
 reg u256[2] t256;
 reg u256 b256;
 reg u256 fourbit_mask;

 zero_offset128[0] = zero_u128;
 zero_offset128[1] = zero_u128;
 zero_offset128[2] = zero_u128;
 zero_offset128[3] = zero_u128;
 one_offset128[0] = zero_u128;
 one_offset128[1] = zero_u128;
 one_offset128[2] = zero_u128;
 one_offset128[3] = zero_u128;

 zero_offset256[0] = zero_u256;
 zero_offset256[1] = zero_u256;
 one_offset256[0] = zero_u256;
 one_offset256[1] = zero_u256;
 fourbit_mask = fourbit_mask_glob;

 for i = 0 to SABER_N / 64 {
  for j = 0 to 8 {
   zero_offset128[0] = #VPINSR_16u16(zero_offset128[0], data[i * 64 + 2 * j], j);
   zero_offset128[1] = #VPINSR_16u16(zero_offset128[1], data[16 + i * 64 + 2 * j], j);
   zero_offset128[2] = #VPINSR_16u16(zero_offset128[2], data[32 + i * 64 + 2 * j], j);
   zero_offset128[3] = #VPINSR_16u16(zero_offset128[3], data[48 + i * 64 + 2 * j], j);
   one_offset128[0] = #VPINSR_16u16(one_offset128[0], data[1 + i * 64 + 2 * j], j);
   one_offset128[1] = #VPINSR_16u16(one_offset128[1], data[16 + 1 + i * 64 + 2 * j], j);
   one_offset128[2] = #VPINSR_16u16(one_offset128[2], data[32 + 1 + i * 64 + 2 * j], j);
   one_offset128[3] = #VPINSR_16u16(one_offset128[3], data[48 + 1 + i * 64 + 2 * j], j);
  }

  zero_offset256[0] = #VINSERTI128(zero_offset256[0], zero_offset128[0], 0);
  zero_offset256[0] = #VINSERTI128(zero_offset256[0], zero_offset128[1], 1);
  zero_offset256[1] = #VINSERTI128(zero_offset256[1], zero_offset128[2], 0);
  zero_offset256[1] = #VINSERTI128(zero_offset256[1], zero_offset128[3], 1);

  one_offset256[0] = #VINSERTI128(one_offset256[0], one_offset128[0], 0);
  one_offset256[0] = #VINSERTI128(one_offset256[0], one_offset128[1], 1);
  one_offset256[1] = #VINSERTI128(one_offset256[1], one_offset128[2], 0);
  one_offset256[1] = #VINSERTI128(one_offset256[1], one_offset128[3], 1);

  zero_offset256[0] &= fourbit_mask;
  one_offset256[0] &= fourbit_mask;
  zero_offset256[1] &= fourbit_mask;
  one_offset256[1] &= fourbit_mask;

  one_offset256[0] <<16u16= 4;
  one_offset256[1] <<16u16= 4;

  t256[0] = #VPACKUS_16u16(zero_offset256[0], zero_offset256[1]);
  t256[1] = #VPACKUS_16u16(one_offset256[0], one_offset256[1]);

  t256[0] = #VPERMQ(t256[0], 216);
  t256[1] = #VPERMQ(t256[1], 216);

  b256 = t256[0] | t256[1];

  bytes[u256 i] = b256;
 }
 return bytes;
}









inline fn dummy_vv_mul(reg ptr u256[SABER_KN / 16] a_avx, reg ptr u256[SABER_KN / 16] b_avx, reg ptr u256[SABER_N / 16] res_avx) -> reg ptr u256[SABER_N / 16]
{
 inline int i j;

 reg u256 t256;

 for i = 0 to SABER_K {
  for j = 0 to SABER_N / 16 {
   t256 = a_avx[i * SABER_N / 16 + j];
   t256 ^= b_avx[i * SABER_N / 16 + j];
   t256 ^= res_avx[j];
   res_avx[j] = t256;
  }
 }

 return res_avx;
}

inline fn indcpa_kem_enc(stack u8[SABER_KEYBYTES] message_received, stack u8[32] noiseseed, stack u8[SABER_INDCPA_PUBLICKEYBYTES] pk, stack u8[SABER_BYTES_CCA_DEC] ciphertext) -> stack u8[SABER_BYTES_CCA_DEC]
{
 inline int i;
 inline int j;
 inline int k;

 reg u8 t8;

 reg u16 t16;

 reg u256 mod;
 reg u256 modp;
 reg u256 H1_avx;
 reg u256 t256;
 reg u256 tt256;

 stack u8[SABER_SEEDBYTES] seed;
 stack u8[SABER_SCALEBYTES_KEM] msk_c;

 stack u16[SABER_KKN] a;
 stack u16[SABER_KN] pkcl;
 stack u16[SABER_KN] skpv1;
 stack u16[SABER_KN] temp;
 stack u16[SABER_KEYBYTES * 8] message;

 stack u256[SABER_N / 16] temp_avx;
 stack u256[SABER_KKN / 16] a_avx;
 stack u256[SABER_KN / 16] res_avx;
 stack u256[SABER_KN / 16] sk_avx;
 stack u256[SABER_KN / 16] pkcl_avx;
 stack u256[SABER_N / 16] vprime_avx;
 stack u256[SABER_N / 16] message_avx;



 for i = 0 to SABER_KN / 16 {
  t256 = zero_u256;
  res_avx[i] = t256;
 }

 mod = #VPBROADCAST_16u16(modq_u16);
 modp = #VPBROADCAST_16u16(modp_u16);
 H1_avx = #VPBROADCAST_16u16(h1_u16);

 for i = 0 to SABER_SEEDBYTES {
  t8 = pk[SABER_POLYVECCOMPRESSEDBYTES + i];
  seed[i] = t8;
 }

 a = GenMatrix(a, seed);

 skpv1 = GenSecret(skpv1, noiseseed);

 for i = 0 to SABER_K {
  for j = 0 to SABER_N / 16 {
   t256 = skpv1[u256 i * SABER_N / 16 + j];
   sk_avx[i * SABER_N / 16 + j] = t256;
  }
 }

 for i = 0 to SABER_K {
  for j = 0 to SABER_K {
   for k = 0 to SABER_N / 16 {
    t256 = a[u256 i * SABER_KN / 16 + j * SABER_N / 16 + k];
    a_avx[i * SABER_KN / 16 + j * SABER_N / 16 + k] = t256;
   }
  }
 }



 res_avx = dummy_mv_mul(a_avx, sk_avx, res_avx);

 for i = 0 to SABER_KN / 16 {
  t256 = res_avx[i];
  t256 +16u16= H1_avx;
  t256 >>16u16= (SABER_EQ - SABER_EP);
  t256 &16u16= mod;
  res_avx[i] = t256;
 }

 for i = 0 to SABER_K {
  for j = 0 to SABER_N / 16 {
   t256 = res_avx[i * SABER_N / 16 + j];
   temp[u256 i * SABER_N / 16 + j] = t256;
  }
 }

 ciphertext[0:SABER_POLYVECCOMPRESSEDBYTES] = POLVECp2BS(ciphertext[0:SABER_POLYVECCOMPRESSEDBYTES], temp);

 pkcl = BS2POLVECp(pk[0:SABER_POLYVECCOMPRESSEDBYTES], pkcl);

 for i = 0 to SABER_K {
  for j = 0 to SABER_N / 16 {
   t256 = pkcl[u256 i * SABER_N / 16 + j];
   pkcl_avx[i * SABER_N / 16 + j] = t256;
  }
 }

 for i = 0 to SABER_N / 16 {
  t256 = vprime_avx[i];
  t256 ^16u16= t256;
  vprime_avx[i] = t256;
 }



 vprime_avx = dummy_vv_mul(pkcl_avx, sk_avx, vprime_avx);

 for i = 0 to SABER_N / 16 {
  t256 = vprime_avx[i];
  t256 +16u16= H1_avx;
  vprime_avx[i] = t256;
 }

 for j = 0 to SABER_KEYBYTES {
  for i = 0 to 8 {

   t16 = (16u) message_received[j];
   t16 >>= i;
   t16 &= 0x01;
   message[8 * j + i] = t16;
  }
 }

 for i = 0 to SABER_N / 16 {
  t256 = message[u256 i];
  t256 <<16u16= (SABER_EP - 1);
  message_avx[i] = t256;
 }


 for k = 0 to SABER_N / 16 {
  t256 = vprime_avx[k];
  t256 -16u16= message_avx[k];
  t256 &16u16= modp;
  t256 >>16u16= (SABER_EP-SABER_ET);
  vprime_avx[k] = t256;
 }

 for j = 0 to SABER_N / 16 {
  t256 = vprime_avx[j];
  temp[u256 j] = t256;
 }

 msk_c = SABER_pack_4bit(msk_c, temp[0:SABER_N]);

 for j = 0 to SABER_SCALEBYTES_KEM {
  t8 = msk_c[j];
  ciphertext[SABER_POLYVECCOMPRESSEDBYTES + j] = t8;
 }

 return ciphertext;
}

inline fn crypto_kem_enc_randominc(stack u8[SABER_BYTES_CCA_DEC] c, stack u8[SABER_HASHBYTES] k, stack u8[SABER_INDCPA_PUBLICKEYBYTES] pk, stack u8[32] random_bytes_crypto) -> stack u8[SABER_BYTES_CCA_DEC], stack u8[SABER_HASHBYTES]
{
 inline int i;

 reg u8 t8;

 stack u8[64] kr;
 stack u8[64] buf;

 for i = 0 to 32 {
  t8 = random_bytes_crypto[i];
  buf[i] = t8;
 }

 buf[0:32] = sha3_256_32(buf[0:32], buf[0:32]);

 buf[32:32] = sha3_256_PUBKEYBYTES(buf[32:32], pk);

 kr = sha3_512_64(kr, buf);

 c = indcpa_kem_enc(buf[0:32], kr[32:32], pk, c);

 kr[32:32] = sha3_256_CCADEC(kr[32:32], c);

 k = sha3_256_64(k, kr);

 return c, k;
}




















inline fn BS2POLVECq(reg ptr u8[SABER_POLYVECBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u16[SABER_KN]
{
 reg u16 b1;
 reg u16 b2;
 reg u16 b3;

 reg u64 i;
 reg u64 j;
 reg u64 address_bytes;
 reg u64 address_data;

 i = 0;
 address_bytes = 0;
 address_data = 0;
 while (i < SABER_K) {
  j = 0;
  while (j < (SABER_N / 8)) {

   b1 = (16u) bytes[(int) address_bytes];
   b1 &= 0xff;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0x1f;
   b2 <<= 8;
   b1 |= b2;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 5;
   b1 &= 0x07;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0xff;
   b2 <<= 3;
   address_bytes += 1;
   b3 = (16u) bytes[(int) address_bytes];
   b3 &= 0x03;
   b3 <<= 11;
   b2 |= b3;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 2;
   b1 &= 0x3f;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0x7f;
   b2 <<= 6;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 7;
   b1 &= 0x01;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0xff;
   b2 <<= 1;
   address_bytes += 1;
   b3 = (16u) bytes[(int) address_bytes];
   b3 &= 0x0f;
   b3 <<= 9;
   b2 |= b3;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 4;
   b1 &= 0x0f;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0xff;
   b2 <<= 4;
   address_bytes += 1;
   b3 = (16u) bytes[(int) address_bytes];
   b3 &= 0x01;
   b3 <<= 12;
   b2 |= b3;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 1;
   b1 &= 0x7f;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0x3f;
   b2 <<= 7;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 6;
   b1 &= 0x03;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0xff;
   b2 <<= 2;
   address_bytes += 1;
   b3 = (16u) bytes[(int) address_bytes];
   b3 &= 0x07;
   b3 <<= 10;
   b2 |= b3;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 3;
   b1 &= 0x1f;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0xff;
   b2 <<= 5;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;

   j += 1;
   address_bytes += 1;
   address_data += 1;
  }
  i += 1;
 }

 return data;
}







fn SABER_un_pack4bit(reg ptr u8[SABER_SCALEBYTES_KEM] bytes, reg ptr u16[SABER_N] ar) -> reg ptr u16[SABER_N]
{
 reg u16 b1;

 reg u64 j;
 reg u64 address_ar;

 j = 0;
 address_ar = 0;
 while (j < (SABER_N / 2)) {

  b1 = (16u) bytes[(int) j];
  b1 &= 0x0f;
  ar[(int) address_ar] = b1;


  b1 = (16u) bytes[(int) j];
  b1 >>= 4;
  b1 &= 0x0f;
  address_ar += 1;
  ar[(int) address_ar] = b1;

  j += 1;
  address_ar += 1;
 }

 return ar;
}







inline fn POL2MSG(stack u16[SABER_N] message_dec_unpacked, stack u8[SABER_KEYBYTES] message_dec) -> stack u8[SABER_KEYBYTES]
{
 inline int i;
 inline int j;

 reg u16 t16;


 for j = 0 to SABER_KEYBYTES {
  message_dec[j] = 0;

  for i = 0 to 8 {
   t16 = message_dec_unpacked[j * 8 + i];
   t16 <<= i;
   message_dec[j] |= (8u) t16;
  }
 }

 return message_dec;
}




inline fn indcpa_kem_dec(stack u8[SABER_INDCPA_SECRETKEYBYTES] sk, stack u8[SABER_BYTES_CCA_DEC] ciphertext, stack u8[SABER_KEYBYTES] message_dec) -> stack u8[SABER_KEYBYTES]
{
 inline int i;
 inline int j;

 reg u8 t8;

 reg u16 t16;

 reg u256 H2_avx;
 reg u256 t256;

 stack u8[SABER_SCALEBYTES_KEM] scale_ar;

 stack u16[SABER_KN] sksv;
 stack u16[SABER_KN] pksv;
 stack u16[SABER_KEYBYTES*8] message_dec_unpacked;
 stack u16[SABER_N] op;

 stack u256[SABER_N / 16] v_avx;
 stack u256[SABER_KN / 16] sksv_avx;
 stack u256[SABER_KN / 16] pksv_avx;



 sksv = BS2POLVECq(sk, sksv);

 pksv = BS2POLVECp(ciphertext[0:SABER_POLYVECCOMPRESSEDBYTES], pksv);

 for i = 0 to SABER_K {
  for j = 0 to SABER_N / 16 {
   t256 = sksv[u256 i * SABER_N / 16 + j];
   sksv_avx[i * SABER_N / 16 + j] = t256;
   t256 = pksv[u256 i * SABER_N / 16 + j];
   pksv_avx[i * SABER_N / 16 + j] = t256;
  }
 }

 for i = 0 to SABER_N / 16 {
  t256 = v_avx[i];
  t256 ^16u16= t256;
  v_avx[i] = t256;
 }


 v_avx = dummy_vv_mul(pksv_avx, sksv_avx, v_avx);

 for i = 0 to SABER_N / 16 {
  t256 = v_avx[i];
  message_dec_unpacked[u256 i] = t256;
 }


 for i = 0 to SABER_SCALEBYTES_KEM {
  t8 = ciphertext[SABER_CIPHERTEXTBYTES + i];
  scale_ar[i] = t8;
 }

 op = SABER_un_pack4bit(scale_ar, op);

 for i = 0 to SABER_N {

  t16 = op[i];
  t16 <<= (SABER_EP-SABER_ET);
  message_dec_unpacked[i] += h2;
  message_dec_unpacked[i] -= t16;
  message_dec_unpacked[i] &= (SABER_P - 1);
  message_dec_unpacked[i] >>= (SABER_EP - 1);
 }

 message_dec = POL2MSG(message_dec_unpacked, message_dec);

 return message_dec;
}











inline fn cmov(stack u8[SABER_KEYBYTES] r, stack u8[SABER_KEYBYTES] x, reg u8 b) -> stack u8[SABER_KEYBYTES]
{
 inline int i;

 reg u8 t8;

 reg u64 t64;

 reg u128 t128;

 reg u256 b256;
 reg u256 r256;
 reg u256 x256;

 _, _, _, _, _, b = #NEG_8(b);

 t128 = zero_u128;
 t128 = #VPINSR_16u8(t128, b, 0);

 b256 = #VPBROADCAST_32u8(t128);
 r256 = r[u256 0];
 x256 = x[u256 0];

 x256 ^= r256;

 x256 &= b256;

 r256 ^= x256;

 r[u256 0] = r256;

 return r;
}







inline fn verify(stack u8[SABER_BYTES_CCA_DEC] a, stack u8[SABER_BYTES_CCA_DEC] b) -> reg u64
{
 reg u32 t32;
 reg u32 r32;

 reg u64 i;
 reg u64 r;

 r32 = 0;
 i = 0;
 while (i < SABER_BYTES_CCA_DEC / 4) {

  t32 = a[u32 (int) i];
  t32 ^= b[u32 (int) i];
  r32 |= t32;

  i += 1;
 }


 r = (64u) r32;
 r *= -1;
 r >>= 63;

 return r;
}

inline fn crypto_kem_dec(stack u8[SABER_HASHBYTES] k, stack u8[SABER_BYTES_CCA_DEC] c, stack u8[SABER_SECRETKEYBYTES] sk) -> stack u8[SABER_HASHBYTES]
{
 inline int i;

 reg u8 t8;

 reg u64 fail;

 stack u8[SABER_BYTES_CCA_DEC] cmp;
 stack u8[64] buf;
 stack u8[64] kr;

 stack u64 sfail;

 buf[0:SABER_KEYBYTES] = indcpa_kem_dec(sk[0:SABER_INDCPA_SECRETKEYBYTES], c, buf[0:SABER_KEYBYTES]);

 for i = 0 to 32 {
  t8 = sk[SABER_SECRETKEYBYTES - 64 + i];
  buf[32 + i] = t8;
 }

 kr = sha3_512_64(kr, buf);

 cmp = indcpa_kem_enc(buf[0:SABER_KEYBYTES], kr[32:32], sk[SABER_INDCPA_SECRETKEYBYTES:SABER_INDCPA_PUBLICKEYBYTES], cmp);

 fail = verify(c, cmp);

 sfail = fail;

 kr[32:32] = sha3_256_CCADEC(kr[32:32], c);

 fail = sfail;

 t8 = (8u) fail;

 kr[0:SABER_KEYBYTES] = cmov(kr[0:SABER_KEYBYTES], sk[(SABER_SECRETKEYBYTES - SABER_KEYBYTES):SABER_KEYBYTES], t8);

 k = sha3_256_64(k, kr);

 return k;
}


export fn crypto_kem_keypair_randominc_jazz(reg u64 pkp, reg u64 skp, reg u64 random_bytes_cryptop, reg u64 indcpa_seedp, reg u64 indcpa_noiseseedp)
{
 reg u8 t8;

 reg u64 i;

 stack u8[SABER_PUBLICKEYBYTES] pk;
 stack u8[SABER_SECRETKEYBYTES] sk;
 stack u8[SABER_KEYBYTES] random_bytes_crypto;
 stack u8[SABER_SEEDBYTES] indcpa_seed;
 stack u8[SABER_COINBYTES] indcpa_noiseseed;

 stack u64 spkp;
 stack u64 sskp;

 i = 0;
 while (i < SABER_KEYBYTES) {
  t8 = (u8) [random_bytes_cryptop + i];
  random_bytes_crypto[(int) i] = t8;

  i += 1;
 }

 i = 0;
 while (i < SABER_SEEDBYTES) {
  t8 = (u8) [indcpa_seedp + i];
  indcpa_seed[(int) i] = t8;

  i += 1;
 }

 i = 0;
 while (i < SABER_COINBYTES) {
  t8 = (u8) [indcpa_noiseseedp + i];
  indcpa_noiseseed[(int) i] = t8;

  i += 1;
 }

 spkp = pkp;
 sskp = skp;

 pk, sk = crypto_kem_keypair_randominc(pk, sk, random_bytes_crypto, indcpa_seed, indcpa_noiseseed);

 pkp = spkp;
 skp = sskp;

 i = 0;
 while (i < SABER_PUBLICKEYBYTES) {
  t8 = pk[(int) i] ;
  (u8) [pkp + i] = t8;

  i += 1;
 }

 i = 0;
 while (i < SABER_SECRETKEYBYTES) {
  t8 = sk[(int) i];
  (u8) [skp + i] = t8;

  i += 1;
 }
}


export fn crypto_kem_enc_randominc_jazz(reg u64 cp, reg u64 kp, reg u64 pkp, reg u64 random_bytes_cryptop)
{
 reg u8 t8;

 reg u64 i;

 stack u8[SABER_BYTES_CCA_DEC] c;
 stack u8[SABER_HASHBYTES] k;
 stack u8[SABER_INDCPA_PUBLICKEYBYTES] pk;
 stack u8[32] random_bytes_crypto;

 stack u64 scp;
 stack u64 skp;

 i = 0;
 while (i < SABER_INDCPA_PUBLICKEYBYTES) {
  t8 = (u8) [pkp + i];
  pk[(int) i] = t8;

  i += 1;
 }

 i = 0;
 while (i < 32) {
  t8 = (u8) [random_bytes_cryptop + i];
  random_bytes_crypto[(int) i] = t8;

  i += 1;
 }

 scp = cp;
 skp = kp;

 c, k = crypto_kem_enc_randominc(c, k, pk, random_bytes_crypto);

 cp = scp;
 kp = skp;

 i = 0;
 while (i < SABER_BYTES_CCA_DEC) {
  t8 = c[(int) i] ;
  (u8) [cp + i] = t8;

  i += 1;
 }

 i = 0;
 while (i < SABER_HASHBYTES) {
  t8 = k[(int) i];
  (u8) [kp + i] = t8;

  i += 1;
 }
}

export fn crypto_kem_dec_jazz(reg u64 kp, reg u64 cp, reg u64 skp)
{
 reg u8 t8;

 reg u64 i;

 stack u8[SABER_HASHBYTES] k;
 stack u8[SABER_BYTES_CCA_DEC] c;
 stack u8[SABER_SECRETKEYBYTES] sk;

 stack u64 stkp;

 i = 0;
 while (i < SABER_BYTES_CCA_DEC) {
  t8 = (u8) [cp + i];
  c[(int) i] = t8;

  i += 1;
 }

 i = 0;
 while (i < SABER_SECRETKEYBYTES) {
  t8 = (u8) [skp + i];
  sk[(int) i] = t8;

  i += 1;
 }

 stkp = kp;

 k = crypto_kem_dec(k, c, sk);

 kp = stkp;

 i = 0;
 while (i < SABER_HASHBYTES) {
  t8 = k[(int) i];
  (u8) [kp + i] = t8;

  i += 1;
 }
}
