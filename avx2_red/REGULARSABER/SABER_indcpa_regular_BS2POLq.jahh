/*** SABER_indcpa_regular_BS2POLq.jahh: File containing the Jasmin implementation of the BS2POLq function from SABER_indcpa.c, with (regular) SABER parameters ***/

#ifndef BS2POLQ_HH
#define BS2POLQ_HH

#include "SABER_params.jahh"

fn BS2POLq(reg ptr u8[SABER_POLYBYTES] bytes, reg ptr u16[SABER_N] data) -> reg ptr u16[SABER_N]
{
	reg u16 b1;
	reg u16 b2;
	reg u16 b3;

	reg u64 j;
	reg u64 address_byte;
	reg u64 address_data;

	j = 0;
	address_byte = 0;
	address_data = 0;

	while (j < (SABER_N / 8)) {

		// data[offset_data + 0]= ( bytes[ offset_byte + 0 ] & (0xff)) | ((bytes[offset_byte + 1] & 0x1f)<<8);
		b1 = (16u) bytes[(int) address_byte];
		address_byte += 1;
		b2 = (16u) bytes[(int) address_byte];
		b2 &= 0x1f;
		b2 <<= 8;
		b1 |= b2;
		data[(int) address_data] = b1;
		address_data += 1;

		// data[offset_data + 1]= ( bytes[ offset_byte + 1 ]>>5 & (0x07)) | ((bytes[offset_byte + 2] & 0xff)<<3) | ((bytes[offset_byte + 3] & 0x03)<<11);
		b1 = (16u) bytes[(int) address_byte];
		address_byte += 1;
		b2 = (16u) bytes[(int) address_byte];
		address_byte += 1;
		b3 = (16u) bytes[(int) address_byte];
		b1 >>= 5;
		b2 <<= 3;
		b3 &= 0x03;
		b3 <<= 11;
		b1 |= b2;
		b1 |= b3;
		data[(int) address_data] = b1;
		address_data += 1;

		// data[offset_data + 2]= ( bytes[ offset_byte + 3 ]>>2 & (0x3f)) | ((bytes[offset_byte + 4] & 0x7f)<<6);
		b1 = (16u) bytes[(int) address_byte];
		address_byte += 1;
		b2 = (16u) bytes[(int) address_byte];
		b1 >>= 2;
		b2 &= 0x7f;
		b2 <<= 6;
		b1 |= b2;
		data[(int) address_data] = b1;
		address_data += 1;

		// data[offset_data + 3]= ( bytes[ offset_byte + 4 ]>>7 & (0x01)) | ((bytes[offset_byte + 5] & 0xff)<<1) | ((bytes[offset_byte + 6] & 0x0f)<<9);
		b1 = (16u) bytes[(int) address_byte];
		address_byte += 1;
		b2 = (16u) bytes[(int) address_byte];
		address_byte += 1;
		b3 = (16u) bytes[(int) address_byte];
		b1 >>= 7;
		b2 <<= 1; // b2 += b2?
		b3 &= 0x0f;
		b3 <<= 9;
		b1 |= b2;
		b1 |= b3;
		data[(int) address_data] = b1;
		address_data += 1;

		// data[offset_data + 4]= ( bytes[ offset_byte + 6 ]>>4 & (0x0f)) | ((bytes[offset_byte + 7] & 0xff)<<4) | ((bytes[offset_byte + 8] & 0x01)<<12);
		b1 = (16u) bytes[(int) address_byte];
		address_byte += 1;
		b2 = (16u) bytes[(int) address_byte];
		address_byte += 1;
		b3 = (16u) bytes[(int) address_byte];
		b1 >>= 4;
		b2 <<= 4;
		b3 &= 0x01;
		b3 <<= 12;
		b1 |= b2;
		b1 |= b3;
		data[(int) address_data] = b1;
		address_data += 1;

		// data[offset_data + 5]= ( bytes[ offset_byte + 8]>>1 & (0x7f)) | ((bytes[offset_byte + 9] & 0x3f)<<7);
		b1 = (16u) bytes[(int) address_byte];
		address_byte += 1;
		b2 = (16u) bytes[(int) address_byte];
		b1 >>= 1;
		b2 &= 0x3f;
		b2 <<= 7;
		b1 |= b2;
		data[(int) address_data] = b1;
		address_data += 1;

		// data[offset_data + 6]= ( bytes[ offset_byte + 9]>>6 & (0x03)) | ((bytes[offset_byte + 10] & 0xff)<<2) | ((bytes[offset_byte + 11] & 0x07)<<10);
		b1 = (16u) bytes[(int) address_byte];
		address_byte += 1;
		b2 = (16u) bytes[(int) address_byte];
		address_byte += 1;
		b3 = (16u) bytes[(int) address_byte];
		b1 >>= 6;
		b2 <<= 2;
		b3 &= 0x07;
		b3 <<= 10;
		b1 |= b2;
		b1 |= b3;
		data[(int) address_data] = b1;
		address_data += 1;

		// data[offset_data + 7]= ( bytes[ offset_byte + 11]>>3 & (0x1f)) | ((bytes[offset_byte + 12] & 0xff)<<5);
		b1 = (16u) bytes[(int) address_byte];
		address_byte += 1;
		b2 = (16u) bytes[(int) address_byte];
		address_byte += 1;
		b1 >>= 3;
		b2 <<= 5;
		b1 |= b2;
		data[(int) address_data] = b1;
		address_data += 1;

		j += 1;
	}

	return data;
}

#endif