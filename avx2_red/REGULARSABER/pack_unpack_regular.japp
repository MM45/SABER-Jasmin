








param int CRYPTO_SECRETKEYBYTES = 2304;
param int CRYPTO_PUBLICKEYBYTES = (3 * 320 + 32);
param int CRYPTO_BYTES = 32;
param int CRYPTO_CIPHERTEXTBYTES = 1088;
param int Saber_type = 2;

param int SABER_K = 3;
param int SABER_MU = 8;
param int SABER_ET = 4;

param int SABER_EQ = 13;
param int SABER_EP = 10;

param int SABER_N = 256;
param int SABER_Q = 8192;
param int SABER_P = 1024;

param int SABER_SEEDBYTES = 32;
param int SABER_NOISESEEDBYTES = 32;
param int SABER_COINBYTES = 32;
param int SABER_KEYBYTES = 32;

param int SABER_HASHBYTES = 32;

param int SABER_POLYBYTES = 416;

param int SABER_POLYVECBYTES = (SABER_K * SABER_POLYBYTES);

param int SABER_POLYVECCOMPRESSEDBYTES = (SABER_K * 320);

param int SABER_CIPHERTEXTBYTES = (SABER_POLYVECCOMPRESSEDBYTES);



param int SABER_SCALEBYTES_KEM = (SABER_ET * SABER_N / 8);

param int SABER_INDCPA_PUBLICKEYBYTES = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SEEDBYTES);
param int SABER_INDCPA_SECRETKEYBYTES = (SABER_POLYVECBYTES);

param int SABER_PUBLICKEYBYTES = (SABER_INDCPA_PUBLICKEYBYTES);

param int SABER_SECRETKEYBYTES = (SABER_INDCPA_SECRETKEYBYTES + SABER_INDCPA_PUBLICKEYBYTES + SABER_HASHBYTES + SABER_KEYBYTES);

param int SABER_BYTES_CCA_DEC = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SCALEBYTES_KEM);



param int SABER_KN = (SABER_K * SABER_N);
param int SABER_KKN = (SABER_K * SABER_K * SABER_N);
param int N_SB = (SABER_N / 4);
param int N_SB_RES = (2 * N_SB - 1);

param int SHAKE128_RATE = 168;
param int SHAKE256_RATE = 136;
param int SHA3_256_RATE = 136;
param int SHA3_512_RATE = 72;

param int KK13N8 = (SABER_K * SABER_K * (13 * SABER_N / 8));
param int MUNK8 = (SABER_MU * SABER_N * SABER_K / 8);

param int h1 = 4;
param int h2 = 228;




u16 h1_u16 = h1;
u16 h2_u16 = h2;
u16 modp_u16 = SABER_P - 1;
u16 modq_u16 = SABER_Q - 1;

u128 zero_u128 = 0;
u256 zero_u256 = 0;






inline fn SABER_pack_4bit(reg ptr u8[SABER_SCALEBYTES_KEM] bytes, reg ptr u16[SABER_N] data) -> reg ptr u8[SABER_SCALEBYTES_KEM]
{
 reg u16 d1;
 reg u16 d2;

 reg u64 j;
 reg u64 address_data;

 j = 0;
 address_data = 0;
 while (j < (SABER_N / 2)) {

  d1 = data[(int) address_data];
  d1 &= 0x0f;
  address_data += 1;
  d2 = data[(int) address_data];
  d2 &= 0x0f;
  d2 <<= 4;
  d1 |= d2;
  bytes[(int) j] = (8u) d1;

  j += 1;
  address_data += 1;
 }

 return bytes;
}







inline fn SABER_un_pack4bit(reg ptr u8[SABER_SCALEBYTES_KEM] bytes, reg ptr u16[SABER_N] ar) -> reg ptr u16[SABER_N]
{
 reg u16 b1;

 reg u64 j;
 reg u64 address_ar;

 j = 0;
 address_ar = 0;
 while (j < (SABER_N / 2)) {

  b1 = (16u) bytes[(int) j];
  b1 &= 0x0f;
  ar[(int) address_ar] = b1;


  b1 = (16u) bytes[(int) j];
  b1 >>= 4;
  b1 &= 0x0f;
  address_ar += 1;
  ar[(int) address_ar] = b1;

  j += 1;
  address_ar += 1;
 }

 return ar;
}







fn POLVECp2BS(reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES]
{
 reg u16 d1;
 reg u16 d2;

 reg u64 i;
 reg u64 j;
 reg u64 address_bytes;
 reg u64 address_data;

 i = 0;
 address_bytes = 0;
 address_data = 0;
 while (i < SABER_K) {
  j = 0;
  while (j < (SABER_N / 4)) {

   d1 = data[(int) address_data];
   d1 &= 0xff;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 8;
   d1 &= 0x03;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x3f;
   d2 <<= 2;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 6;
   d1 &= 0x0f;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x0f;
   d2 <<= 4;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 4;
   d1 &= 0x3f;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x03;
   d2 <<= 6;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 2;
   d1 &= 0xff;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;

   j += 1;
   address_bytes += 1;
   address_data += 1;
  }
  i += 1;
 }

 return bytes;
}







inline fn POLVECq2BS(reg ptr u8[SABER_POLYVECBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u8[SABER_POLYVECBYTES]
{
 reg u16 d1;
 reg u16 d2;

 reg u64 i;
 reg u64 j;
 reg u64 address_bytes;
 reg u64 address_data;

 i = 0;
 address_bytes = 0;
 address_data = 0;
 while (i < SABER_K) {
  j = 0;
  while (j < (SABER_N / 8)) {

   d1 = data[(int) address_data];
   d1 &= 0xff;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 8;
   d1 &= 0x1f;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x07;
   d2 <<= 5;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 3;
   d1 &= 0xff;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 11;
   d1 &= 0x03;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x3f;
   d2 <<= 2;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 6;
   d1 &= 0x7f;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x01;
   d2 <<= 7;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 1;
   d1 &= 0xff;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 9;
   d1 &= 0x0f;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x0f;
   d2 <<= 4;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 4;
   d1 &= 0xff;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 12;
   d1 &= 0x01;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x7f;
   d2 <<= 1;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 7;
   d1 &= 0x3f;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x03;
   d2 <<= 6;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 2;
   d1 &= 0xff;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 10;
   d1 &= 0x07;
   address_data += 1;
   d2 = data[(int) address_data];
   d2 &= 0x1f;
   d2 <<= 3;
   d1 |= d2;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;


   d1 = data[(int) address_data];
   d1 >>= 5;
   d1 &= 0xff;
   address_bytes += 1;
   bytes[(int) address_bytes] = (8u) d1;

   j += 1;
   address_bytes += 1;
   address_data += 1;
  }
  i += 1;
 }

 return bytes;
}







u256 twobit_mask_glob = 0x0003000300030003000300030003000300030003000300030003000300030003;
u256 fourbit_mask_glob = 0x000f000f000f000f000f000f000f000f000f000f000f000f000f000f000f000f;
u256 sixbit_mask_glob = 0x003f003f003f003f003f003f003f003f003f003f003f003f003f003f003f003f;

fn BS2POLVECp(reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u16[SABER_KN]
{
 reg u16 b1;
 reg u16 b2;

 reg u64 i;
 reg u64 j;
 reg u64 address_bytes;
 reg u64 address_data;

 i = 0;
 address_bytes = 0;
 address_data = 0;
 while (i < SABER_K) {
  j = 0;
  while (j < (SABER_N / 4)) {

   b1 = (16u) bytes[(int) address_bytes];
   b1 &= 0xff;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0x03;
   b2 <<= 8;
   b1 |= b2;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 2;
   b1 &= 0x3f;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0x0f;
   b2 <<= 6;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 4;
   b1 &= 0x0f;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0x3f;
   b2 <<= 4;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 6;
   b1 &= 0x03;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0xff;
   b2 <<= 2;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;

   j += 1;
   address_bytes += 1;
   address_data += 1;
  }
  i += 1;
 }

 return data;
}







inline fn BS2POLVECq(reg ptr u8[SABER_POLYVECBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u16[SABER_KN]
{
 reg u16 b1;
 reg u16 b2;
 reg u16 b3;

 reg u64 i;
 reg u64 j;
 reg u64 address_bytes;
 reg u64 address_data;

 i = 0;
 address_bytes = 0;
 address_data = 0;
 while (i < SABER_K) {
  j = 0;
  while (j < (SABER_N / 8)) {

   b1 = (16u) bytes[(int) address_bytes];
   b1 &= 0xff;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0x1f;
   b2 <<= 8;
   b1 |= b2;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 5;
   b1 &= 0x07;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0xff;
   b2 <<= 3;
   address_bytes += 1;
   b3 = (16u) bytes[(int) address_bytes];
   b3 &= 0x03;
   b3 <<= 11;
   b2 |= b3;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 2;
   b1 &= 0x3f;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0x7f;
   b2 <<= 6;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 7;
   b1 &= 0x01;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0xff;
   b2 <<= 1;
   address_bytes += 1;
   b3 = (16u) bytes[(int) address_bytes];
   b3 &= 0x0f;
   b3 <<= 9;
   b2 |= b3;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 4;
   b1 &= 0x0f;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0xff;
   b2 <<= 4;
   address_bytes += 1;
   b3 = (16u) bytes[(int) address_bytes];
   b3 &= 0x01;
   b3 <<= 12;
   b2 |= b3;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 1;
   b1 &= 0x7f;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0x3f;
   b2 <<= 7;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 6;
   b1 &= 0x03;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0xff;
   b2 <<= 2;
   address_bytes += 1;
   b3 = (16u) bytes[(int) address_bytes];
   b3 &= 0x07;
   b3 <<= 10;
   b2 |= b3;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;


   b1 = (16u) bytes[(int) address_bytes];
   b1 >>= 3;
   b1 &= 0x1f;
   address_bytes += 1;
   b2 = (16u) bytes[(int) address_bytes];
   b2 &= 0xff;
   b2 <<= 5;
   b1 |= b2;
   address_data += 1;
   data[(int) address_data] = b1;

   j += 1;
   address_bytes += 1;
   address_data += 1;
  }
  i += 1;
 }

 return data;
}

export fn SABER_pack_4bit_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_SCALEBYTES_KEM] bytes;
 stack u16[SABER_N] data;

 for i = 0 to SABER_N {
  td = (u16) [datap + 2 * i];
  data[i] = td;
 }

 bytes = SABER_pack_4bit(bytes, data);

 for i = 0 to SABER_SCALEBYTES_KEM {
  tb = bytes[i];
  (u8) [bytesp + i] = tb;
 }
}

export fn SABER_un_pack4bit_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_SCALEBYTES_KEM] bytes;
 stack u16[SABER_N] data;

 for i = 0 to SABER_SCALEBYTES_KEM {
  tb = (u8) [bytesp + i];
  bytes[i] = tb;
 }

 data = SABER_un_pack4bit(bytes, data);

 for i = 0 to SABER_N {
  td = data[i];
  (u16) [datap + 2 * i] = td;
 }
}

export fn POLVECp2BS_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_POLYVECCOMPRESSEDBYTES] bytes;
 stack u16[SABER_KN] data;

 for i = 0 to SABER_KN {
  td = (u16) [datap + 2 * i];
  data[i] = td;
 }

 bytes = POLVECp2BS(bytes, data);

 for i = 0 to SABER_POLYVECCOMPRESSEDBYTES {
  tb = bytes[i];
  (u8) [bytesp + i] = tb;
 }
}

export fn POLVECq2BS_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_POLYVECBYTES] bytes;
 stack u16[SABER_KN] data;

 for i = 0 to SABER_KN {
  td = (u16) [datap + 2 * i];
  data[i] = td;
 }

 bytes = POLVECq2BS(bytes, data);

 for i = 0 to SABER_POLYVECBYTES {
  tb = bytes[i];
  (u8) [bytesp + i] = tb;
 }
}

export fn BS2POLVECp_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_POLYVECCOMPRESSEDBYTES] bytes;
 stack u16[SABER_KN] data;


 for i = 0 to SABER_POLYVECCOMPRESSEDBYTES {
  tb = (u8) [bytesp + i];
  bytes[i] = tb;
 }

 data = BS2POLVECp(bytes, data);

 for i = 0 to SABER_KN {
  td = data[i];
  (u16) [datap + 2 * i] = td;
 }
}

export fn BS2POLVECq_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_POLYVECBYTES] bytes;
 stack u16[SABER_KN] data;


 for i = 0 to SABER_POLYVECBYTES {
  tb = (u8) [bytesp + i];
  bytes[i] = tb;
 }

 data = BS2POLVECq(bytes, data);

 for i = 0 to SABER_KN {
  td = data[i];
  (u16) [datap + 2 * i] = td;
 }
}
