








param int CRYPTO_SECRETKEYBYTES = 2304;
param int CRYPTO_PUBLICKEYBYTES = (3 * 320 + 32);
param int CRYPTO_BYTES = 32;
param int CRYPTO_CIPHERTEXTBYTES = 1088;
param int Saber_type = 2;

param int SABER_K = 3;
param int SABER_MU = 8;
param int SABER_ET = 4;

param int SABER_EQ = 13;
param int SABER_EP = 10;

param int SABER_N = 256;
param int SABER_Q = 8192;
param int SABER_P = 1024;

param int SABER_SEEDBYTES = 32;
param int SABER_NOISESEEDBYTES = 32;
param int SABER_COINBYTES = 32;
param int SABER_KEYBYTES = 32;

param int SABER_HASHBYTES = 32;

param int SABER_POLYBYTES = 416;

param int SABER_POLYVECBYTES = (SABER_K * SABER_POLYBYTES);

param int SABER_POLYVECCOMPRESSEDBYTES = (SABER_K * 320);

param int SABER_CIPHERTEXTBYTES = (SABER_POLYVECCOMPRESSEDBYTES);



param int SABER_SCALEBYTES_KEM = (SABER_ET * SABER_N / 8);

param int SABER_INDCPA_PUBLICKEYBYTES = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SEEDBYTES);
param int SABER_INDCPA_SECRETKEYBYTES = (SABER_POLYVECBYTES);

param int SABER_PUBLICKEYBYTES = (SABER_INDCPA_PUBLICKEYBYTES);

param int SABER_SECRETKEYBYTES = (SABER_INDCPA_SECRETKEYBYTES + SABER_INDCPA_PUBLICKEYBYTES + SABER_HASHBYTES + SABER_KEYBYTES);

param int SABER_BYTES_CCA_DEC = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SCALEBYTES_KEM);



param int SABER_KN = (SABER_K * SABER_N);
param int SABER_KKN = (SABER_K * SABER_K * SABER_N);
param int N_SB = (SABER_N / 4);
param int N_SB_RES = (2 * N_SB - 1);

param int SHAKE128_RATE = 168;
param int SHAKE256_RATE = 136;
param int SHA3_256_RATE = 136;
param int SHA3_512_RATE = 72;

param int KK13N8 = (SABER_K * SABER_K * (13 * SABER_N / 8));
param int MUNK8 = (SABER_MU * SABER_N * SABER_K / 8);

param int h1 = 4;
param int h2 = 228;




u16 h1_u16 = h1;
u16 h2_u16 = h2;
u16 modp_u16 = SABER_P - 1;
u16 modq_u16 = SABER_Q - 1;

u128 zero_u128 = 0;
u256 zero_u256 = 0;






u256 fourbit_mask_glob = 0x000f000f000f000f000f000f000f000f000f000f000f000f000f000f000f000f;

inline fn SABER_pack_4bit(reg ptr u8[SABER_SCALEBYTES_KEM] bytes, reg ptr u16[SABER_N] data) -> reg ptr u8[SABER_SCALEBYTES_KEM]
{

 inline int i, j;

 reg u128[4] zero_offset128;
 reg u128[4] one_offset128;

 reg u256[2] zero_offset256;
 reg u256[2] one_offset256;
 reg u256[2] t256;
 reg u256 b256;
 reg u256 fourbit_mask;

 zero_offset128[0] = zero_u128;
 zero_offset128[1] = zero_u128;
 zero_offset128[2] = zero_u128;
 zero_offset128[3] = zero_u128;
 one_offset128[0] = zero_u128;
 one_offset128[1] = zero_u128;
 one_offset128[2] = zero_u128;
 one_offset128[3] = zero_u128;

 zero_offset256[0] = zero_u256;
 zero_offset256[1] = zero_u256;
 one_offset256[0] = zero_u256;
 one_offset256[1] = zero_u256;
 fourbit_mask = fourbit_mask_glob;

 for i = 0 to SABER_N / 64 {
  for j = 0 to 8 {
   zero_offset128[0] = #VPINSR_16u16(zero_offset128[0], data[i * 64 + 2 * j], j);
   zero_offset128[1] = #VPINSR_16u16(zero_offset128[1], data[16 + i * 64 + 2 * j], j);
   zero_offset128[2] = #VPINSR_16u16(zero_offset128[2], data[32 + i * 64 + 2 * j], j);
   zero_offset128[3] = #VPINSR_16u16(zero_offset128[3], data[48 + i * 64 + 2 * j], j);
   one_offset128[0] = #VPINSR_16u16(one_offset128[0], data[1 + i * 64 + 2 * j], j);
   one_offset128[1] = #VPINSR_16u16(one_offset128[1], data[16 + 1 + i * 64 + 2 * j], j);
   one_offset128[2] = #VPINSR_16u16(one_offset128[2], data[32 + 1 + i * 64 + 2 * j], j);
   one_offset128[3] = #VPINSR_16u16(one_offset128[3], data[48 + 1 + i * 64 + 2 * j], j);
  }

  zero_offset256[0] = #VINSERTI128(zero_offset256[0], zero_offset128[0], 0);
  one_offset256[0] = #VINSERTI128(one_offset256[0], one_offset128[0], 0);
  zero_offset256[1] = #VINSERTI128(zero_offset256[1], zero_offset128[2], 0);
  one_offset256[1] = #VINSERTI128(one_offset256[1], one_offset128[2], 0);
  zero_offset256[0] = #VINSERTI128(zero_offset256[0], zero_offset128[1], 1);
  one_offset256[0] = #VINSERTI128(one_offset256[0], one_offset128[1], 1);
  zero_offset256[1] = #VINSERTI128(zero_offset256[1], zero_offset128[3], 1);
  one_offset256[1] = #VINSERTI128(one_offset256[1], one_offset128[3], 1);

  one_offset256[0] &= fourbit_mask;
  one_offset256[1] &= fourbit_mask;

  zero_offset256[0] &= fourbit_mask;
  zero_offset256[1] &= fourbit_mask;

  one_offset256[0] <<16u16= 4;
  one_offset256[1] <<16u16= 4;

  t256[0] = #VPACKUS_16u16(zero_offset256[0], zero_offset256[1]);
  t256[1] = #VPACKUS_16u16(one_offset256[0], one_offset256[1]);

  t256[0] = #VPERMQ(t256[0], 216);
  t256[1] = #VPERMQ(t256[1], 216);

  b256 = t256[0] | t256[1];

  bytes[u256 i] = b256;
 }

 return bytes;
}







inline fn SABER_un_pack4bit(reg ptr u8[SABER_SCALEBYTES_KEM] bytes, reg ptr u16[SABER_N] ar) -> reg ptr u16[SABER_N]
{
 reg u32 b1;

 reg u64 address_bytes;
 reg u64[2] address_ar;

 address_bytes = 0;

 address_ar[0] = 0;
 address_ar[1] = 1;

 while (address_ar[0] < SABER_N) {

  b1 = (32u) bytes[(int) address_bytes];
  b1 &= 0x0f;
  ar[(int) address_ar[0]] = (16u) b1;


  b1 = (32u) bytes[(int) address_bytes];
  b1 >>= 4;
  ar[(int) address_ar[1]] = (16u) b1;

  address_bytes += 1;
  address_ar[0] += 2;
  address_ar[1] += 2;
 }

 return ar;
}







fn POLVECp2BS(reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES]
{
 reg u32 d1;
 reg u32 d2;

 reg u64 address_bytes;
 reg u64[2] address_data;

 address_bytes = 0;

 address_data[0] = 0;
 address_data[1] = 1;

 while (address_data[0] < SABER_KN) {


  d1 = (32u) data[(int) address_data[0]];
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d2 = (32u) data[(int) address_data[1]];
  address_data[0] += 2;
  d1 >>= 8;
  d2 <<= 2;
  d1 &= 0x03;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  d2 = (32u) data[(int) address_data[0]];
  address_data[1] += 2;
  d1 >>= 6;
  d2 <<= 4;
  d1 &= 0x0f;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d2 = (32u) data[(int) address_data[1]];
  d1 >>= 4;
  d2 <<= 6;
  d1 &= 0x3f;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  address_data[0] += 2;
  address_data[1] += 2;
  d1 >>= 2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;



  d1 = (32u) data[(int) address_data[0]];
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d2 = (32u) data[(int) address_data[1]];
  address_data[0] += 2;
  d1 >>= 8;
  d2 <<= 2;
  d1 &= 0x03;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  d2 = (32u) data[(int) address_data[0]];
  address_data[1] += 2;
  d1 >>= 6;
  d2 <<= 4;
  d1 &= 0x0f;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d2 = (32u) data[(int) address_data[1]];
  d1 >>= 4;
  d2 <<= 6;
  d1 &= 0x3f;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  address_data[0] += 2;
  address_data[1] += 2;
  d1 >>= 2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;
 }

 return bytes;
}







inline fn POLVECq2BS(reg ptr u8[SABER_POLYVECBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u8[SABER_POLYVECBYTES]
{
 reg u32 d1;
 reg u32 d2;

 reg u64 address_bytes;
 reg u64[2] address_data;

 address_bytes = 0;

 address_data[0] = 0;
 address_data[1] = 1;

 while (address_data[0] < SABER_KN) {


  d1 = (32u) data[(int) address_data[0]];
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d2 = (32u) data[(int) address_data[1]];
  address_data[0] += 2;
  d1 >>= 8;
  d2 <<= 5;
  d1 &= 0x1f;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  d1 >>= 3;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  d2 = (32u) data[(int) address_data[0]];
  address_data[1] += 2;
  d1 >>= 11;
  d2 <<= 2;
  d1 &= 0x03;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d2 = (32u) data[(int) address_data[1]];
  address_data[0] += 2;
  d1 >>= 6;
  d2 <<= 7;
  d1 &= 0x7f;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  d1 >>= 1;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  d2 = (32u) data[(int) address_data[0]];
  address_data[1] += 2;
  d1 >>= 9;
  d2 <<= 4;
  d1 &= 0x0f;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d1 >>= 4;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d2 = (32u) data[(int) address_data[1]];
  address_data[0] += 2;
  d1 >>= 12;
  d2 <<= 1;
  d1 &= 0x01;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  d2 = (32u) data[(int) address_data[0]];
  address_data[1] += 2;
  d1 >>= 7;
  d2 <<= 6;
  d1 &= 0x3f;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d1 >>= 2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d2 = (32u) data[(int) address_data[1]];
  d1 >>= 10;
  d2 <<= 3;
  d1 &= 0x07;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  address_data[0] += 2;
  address_data[1] += 2;
  d1 >>= 5;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;



  d1 = (32u) data[(int) address_data[0]];
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d2 = (32u) data[(int) address_data[1]];
  address_data[0] += 2;
  d1 >>= 8;
  d2 <<= 5;
  d1 &= 0x1f;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  d1 >>= 3;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  d2 = (32u) data[(int) address_data[0]];
  address_data[1] += 2;
  d1 >>= 11;
  d2 <<= 2;
  d1 &= 0x03;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d2 = (32u) data[(int) address_data[1]];
  address_data[0] += 2;
  d1 >>= 6;
  d2 <<= 7;
  d1 &= 0x7f;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  d1 >>= 1;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  d2 = (32u) data[(int) address_data[0]];
  address_data[1] += 2;
  d1 >>= 9;
  d2 <<= 4;
  d1 &= 0x0f;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d1 >>= 4;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d2 = (32u) data[(int) address_data[1]];
  address_data[0] += 2;
  d1 >>= 12;
  d2 <<= 1;
  d1 &= 0x01;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  d2 = (32u) data[(int) address_data[0]];
  address_data[1] += 2;
  d1 >>= 7;
  d2 <<= 6;
  d1 &= 0x3f;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d1 >>= 2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[0]];
  d2 = (32u) data[(int) address_data[1]];
  d1 >>= 10;
  d2 <<= 3;
  d1 &= 0x07;
  d1 |= d2;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;


  d1 = (32u) data[(int) address_data[1]];
  address_data[0] += 2;
  address_data[1] += 2;
  d1 >>= 5;
  bytes[(int) address_bytes] = (8u) d1;
  address_bytes += 1;
 }

 return bytes;
}







u256 twobit_mask_glob = 0x0003000300030003000300030003000300030003000300030003000300030003;
u256 fourbit_mask_glob = 0x000f000f000f000f000f000f000f000f000f000f000f000f000f000f000f000f;
u256 sixbit_mask_glob = 0x003f003f003f003f003f003f003f003f003f003f003f003f003f003f003f003f;

fn BS2POLVECp(reg ptr u8[SABER_POLYVECCOMPRESSEDBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u16[SABER_KN]
{
 reg u32 b1;
 reg u32 b2;

 reg u64[2] address_bytes;
 reg u64 address_data;

 address_bytes[0] = 0;
 address_bytes[1] = 1;

 address_data = 0;

 while (address_data < SABER_KN) {

  b2 = (32u) bytes[(int) address_bytes[1]];
  b1 = (32u) bytes[(int) address_bytes[0]];
  address_bytes[0] += 2;
  b2 &= 0x03;
  b2 <<= 8;
  b1 |= b2;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b2 = (32u) bytes[(int) address_bytes[0]];
  b1 = (32u) bytes[(int) address_bytes[1]];
  address_bytes[1] += 2;
  b2 &= 0x0f;
  b1 >>= 2;
  b2 <<= 6;
  b1 |= b2;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b2 = (32u) bytes[(int) address_bytes[1]];
  b1 = (32u) bytes[(int) address_bytes[0]];
  address_bytes[0] += 2;
  b2 &= 0x3f;
  b1 >>= 4;
  b2 <<= 4;
  b1 |= b2;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b2 = (32u) bytes[(int) address_bytes[0]];
  b1 = (32u) bytes[(int) address_bytes[1]];
  address_bytes[0] += 1;
  address_bytes[1] += 3;
  b2 <<= 2;
  b1 >>= 6;
  b1 |= b2;
  data[(int) address_data] = (16u) b1;
  address_data += 1;
 }

 return data;
}







fn BS2POLVECq(reg ptr u8[SABER_POLYVECBYTES] bytes, reg ptr u16[SABER_KN] data) -> reg ptr u16[SABER_KN]
{
 reg u32 b1;
 reg u32 b2;
 reg u32 b3;

 reg u64[3] address_bytes;
 reg u64 address_data;

 address_bytes[0] = 0;
 address_bytes[1] = 1;
 address_bytes[2] = 2;

 address_data = 0;

 while (address_data < SABER_KN) {

  b2 = (32u) bytes[(int) address_bytes[1]];
  b1 = (32u) bytes[(int) address_bytes[0]];
  address_bytes[0] += 3;
  b2 <<= 8;
  b2 &= 0x1f00;
  b1 |= b2;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b1 = (32u) bytes[(int) address_bytes[1]];
  b2 = (32u) bytes[(int) address_bytes[2]];
  address_bytes[1] += 3;
  address_bytes[2] += 3;
  b1 >>= 5;
  b2 <<= 3;
  b1 |= b2;
  b3 = (32u) bytes[(int) address_bytes[0]];
  b3 <<= 11;
  b3 &= 0x1800;
  b1 |= b3;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b2 = (32u) bytes[(int) address_bytes[1]];
  b1 = (32u) bytes[(int) address_bytes[0]];
  address_bytes[0] += 3;
  b2 <<= 6;
  b1 >>= 2;
  b2 &= 0x1fc0;
  b1 |= b2;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b1 = (32u) bytes[(int) address_bytes[1]];
  b2 = (32u) bytes[(int) address_bytes[2]];
  address_bytes[1] += 3;
  address_bytes[2] += 3;
  b1 >>= 7;
  b2 += b2;
  b1 |= b2;
  b3 = (32u) bytes[(int) address_bytes[0]];
  b3 <<= 9;
  b3 &= 0x1e00;
  b1 |= b3;
  data[(int) address_data] = b1;
  address_data += 1;


  b1 = (32u) bytes[(int) address_bytes[0]];
  b2 = (32u) bytes[(int) address_bytes[1]];
  address_bytes[0] += 3;
  address_bytes[1] += 3;
  b1 >>= 4;
  b2 <<= 4;
  b1 |= b2;
  b3 = (32u) bytes[(int) address_bytes[2]];
  b3 <<= 12;
  b3 &= 0x1000;
  b1 |= b3;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b2 = (32u) bytes[(int) address_bytes[0]];
  b1 = (32u) bytes[(int) address_bytes[2]];
  address_bytes[2] += 3;
  b2 <<= 7;
  b1 >>= 1;
  b2 &= 0x1f80;
  b1 |= b2;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b1 = (32u) bytes[(int) address_bytes[0]];
  b2 = (32u) bytes[(int) address_bytes[1]];
  address_bytes[0] += 3;
  b1 >>= 6;
  b2 <<= 2;
  b1 |= b2;
  b3 = (32u) bytes[(int) address_bytes[2]];
  b3 <<= 10;
  b3 &= 0x1c00;
  b1 |= b3;
  data[(int) address_data] = (16u) b1;
  address_data += 1;


  b1 = (32u) bytes[(int) address_bytes[2]];
  b2 = (32u) bytes[(int) address_bytes[0]];
  address_bytes[0] += 1;
  address_bytes[1] += 4;
  address_bytes[2] += 4;
  b1 >>= 3;
  b2 <<= 5;
  b1 |= b2;
  data[(int) address_data] = (16u) b1;
  address_data += 1;
 }

 return data;
}

export fn SABER_pack_4bit_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_SCALEBYTES_KEM] bytes;
 stack u16[SABER_N] data;

 for i = 0 to SABER_N {
  td = (u16) [datap + 2 * i];
  data[i] = td;
 }

 bytes = SABER_pack_4bit(bytes, data);

 for i = 0 to SABER_SCALEBYTES_KEM {
  tb = bytes[i];
  (u8) [bytesp + i] = tb;
 }

}


export fn SABER_un_pack4bit_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_SCALEBYTES_KEM] bytes;
 stack u16[SABER_N] data;

 for i = 0 to SABER_SCALEBYTES_KEM {
  tb = (u8) [bytesp + i];
  bytes[i] = tb;
 }

 data = SABER_un_pack4bit(bytes, data);

 for i = 0 to SABER_N {
  td = data[i];
  (u16) [datap + 2 * i] = td;
 }

}

export fn POLVECp2BS_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_POLYVECCOMPRESSEDBYTES] bytes;
 stack u16[SABER_KN] data;

 for i = 0 to SABER_KN {
  td = (u16) [datap + 2 * i];
  data[i] = td;
 }

 bytes = POLVECp2BS(bytes, data);

 for i = 0 to SABER_POLYVECCOMPRESSEDBYTES {
  tb = bytes[i];
  (u8) [bytesp + i] = tb;
 }

}

export fn POLVECq2BS_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_POLYVECBYTES] bytes;
 stack u16[SABER_KN] data;

 for i = 0 to SABER_KN {
  td = (u16) [datap + 2 * i];
  data[i] = td;
 }

 bytes = POLVECq2BS(bytes, data);

 for i = 0 to SABER_POLYVECBYTES {
  tb = bytes[i];
  (u8) [bytesp + i] = tb;
 }
}

export fn BS2POLVECp_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_POLYVECCOMPRESSEDBYTES] bytes;
 stack u16[SABER_KN] data;


 for i = 0 to SABER_POLYVECCOMPRESSEDBYTES {
  tb = (u8) [bytesp + i];
  bytes[i] = tb;
 }

 data = BS2POLVECp(bytes, data);

 for i = 0 to SABER_KN {
  td = data[i];
  (u16) [datap + 2 * i] = td;
 }
}

export fn BS2POLVECq_jazz(reg u64 bytesp, reg u64 datap)
{
 inline int i;

 reg u8 tb;
 reg u16 td;

 stack u8[SABER_POLYVECBYTES] bytes;
 stack u16[SABER_KN] data;

 for i = 0 to SABER_POLYVECBYTES {
  tb = (u8) [bytesp + i];
  bytes[i] = tb;
 }

 data = BS2POLVECq(bytes, data);

 for i = 0 to SABER_KN {
  td = data[i];
  (u16) [datap + 2 * i] = td;
 }
}
