








param int CRYPTO_SECRETKEYBYTES = 2304;
param int CRYPTO_PUBLICKEYBYTES = (3 * 320 + 32);
param int CRYPTO_BYTES = 32;
param int CRYPTO_CIPHERTEXTBYTES = 1088;
param int Saber_type = 2;

param int SABER_K = 3;
param int SABER_MU = 8;
param int SABER_ET = 4;

param int SABER_EQ = 13;
param int SABER_EP = 10;

param int SABER_N = 256;
param int SABER_Q = 8192;
param int SABER_P = 1024;

param int SABER_SEEDBYTES = 32;
param int SABER_NOISESEEDBYTES = 32;
param int SABER_COINBYTES = 32;
param int SABER_KEYBYTES = 32;

param int SABER_HASHBYTES = 32;

param int SABER_POLYBYTES = 416;

param int SABER_POLYVECBYTES = (SABER_K * SABER_POLYBYTES);

param int SABER_POLYVECCOMPRESSEDBYTES = (SABER_K * 320);

param int SABER_CIPHERTEXTBYTES = (SABER_POLYVECCOMPRESSEDBYTES);



param int SABER_SCALEBYTES_KEM = (SABER_ET * SABER_N / 8);

param int SABER_INDCPA_PUBLICKEYBYTES = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SEEDBYTES);
param int SABER_INDCPA_SECRETKEYBYTES = (SABER_POLYVECBYTES);

param int SABER_PUBLICKEYBYTES = (SABER_INDCPA_PUBLICKEYBYTES);

param int SABER_SECRETKEYBYTES = (SABER_INDCPA_SECRETKEYBYTES + SABER_INDCPA_PUBLICKEYBYTES + SABER_HASHBYTES + SABER_KEYBYTES);

param int SABER_BYTES_CCA_DEC = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SCALEBYTES_KEM);



param int SABER_KN = (SABER_K * SABER_N);
param int SABER_KKN = (SABER_K * SABER_K * SABER_N);
param int N_SB = (SABER_N / 4);
param int N_SB_RES = (2 * N_SB - 1);

param int SHAKE128_RATE = 168;
param int SHAKE256_RATE = 136;
param int SHA3_256_RATE = 136;
param int SHA3_512_RATE = 72;

param int KK13N8 = (SABER_K * SABER_K * (13 * SABER_N / 8));
param int MUNK8 = (SABER_MU * SABER_N * SABER_K / 8);

param int h1 = 4;
param int h2 = 228;




u16 h1_u16 = h1;
u16 h2_u16 = h2;
u16 modp_u16 = SABER_P - 1;
u16 modq_u16 = SABER_Q - 1;

u128 zero_u128 = 0;
u256 zero_u256 = 0;
u64[24] KeccakF_RoundConstants = {0x0000000000000001, 0x0000000000008082, 0x800000000000808a, 0x8000000080008000,
                                    0x000000000000808b, 0x0000000080000001, 0x8000000080008081, 0x8000000000008009,
                                    0x000000000000008a, 0x0000000000000088, 0x0000000080008009, 0x000000008000000a,
                                    0x000000008000808b, 0x800000000000008b, 0x8000000000008089, 0x8000000000008003,
                                    0x8000000000008002, 0x8000000000000080, 0x000000000000800a, 0x800000008000000a,
                                    0x8000000080008081, 0x8000000000008080, 0x0000000080000001, 0x8000000080008008};

fn KeccakF1600_StatePermute(reg ptr u64[25] state) -> reg ptr u64[25]
{

  inline int round;

  reg u64 Da, De, Di;

  reg u64[5] C;
  reg u64[5] T;

  stack u64 Do, Du;

  stack u64[25] E;

  for round = 0 to 12 {


    C[0] = state[0];
    C[1] = state[1];
    C[2] = state[2];
    C[3] = state[3];
    C[4] = state[4];

    C[0] ^= state[5];
    C[1] ^= state[6];
    C[2] ^= state[7];
    C[3] ^= state[8];
    C[4] ^= state[9];

    C[0] ^= state[10];
    C[1] ^= state[11];
    C[2] ^= state[12];
    C[3] ^= state[13];
    C[4] ^= state[14];

    C[0] ^= state[15];
    C[1] ^= state[16];
    C[2] ^= state[17];
    C[3] ^= state[18];
    C[4] ^= state[19];

    C[0] ^= state[20];
    C[1] ^= state[21];
    C[2] ^= state[22];
    C[3] ^= state[23];
    C[4] ^= state[24];

    Da = C[1];
    De = C[2];
    Di = C[3];
    Do = C[4];
    Du = C[0];

    _, _, Da = #ROL_64(Da, 1);
    _, _, De = #ROL_64(De, 1);
    _, _, Di = #ROL_64(Di, 1);
    _, _, Do = #ROL_64(Do, 1);
    _, _, Du = #ROL_64(Du, 1);

    Da ^= C[4];
    De ^= C[0];
    Di ^= C[1];
    Do ^= C[2];
    Du ^= C[3];


    C[0] = state[0];
    C[1] = state[6];
    C[2] = state[12];
    C[3] = state[18];
    C[4] = state[24];

    C[0] ^= Da;
    C[1] ^= De;
    C[2] ^= Di;
    C[3] ^= Do;
    C[4] ^= Du;

    _, _, C[1] = #ROL_64(C[1], 44);
    _, _, C[2] = #ROL_64(C[2], 43);
    _, _, C[3] = #ROL_64(C[3], 21);
    _, _, C[4] = #ROL_64(C[4], 14);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    T[0] ^= KeccakF_RoundConstants[2 * round];
    E[0] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    E[1] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    E[2] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    E[3] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    E[4] = T[4];


    C[0] = state[3];
    C[1] = state[9];
    C[2] = state[10];
    C[3] = state[16];
    C[4] = state[22];

    C[0] ^= Do;
    C[1] ^= Du;
    C[2] ^= Da;
    C[3] ^= De;
    C[4] ^= Di;

    _, _, C[0] = #ROL_64(C[0], 28);
    _, _, C[1] = #ROL_64(C[1], 20);
    _, _, C[2] = #ROL_64(C[2], 3);
    _, _, C[3] = #ROL_64(C[3], 45);
    _, _, C[4] = #ROL_64(C[4], 61);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    E[5] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    E[6] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    E[7] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    E[8] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    E[9] = T[4];


    C[0] = state[1];
    C[1] = state[7];
    C[2] = state[13];
    C[3] = state[19];
    C[4] = state[20];

    C[0] ^= De;
    C[1] ^= Di;
    C[2] ^= Do;
    C[3] ^= Du;
    C[4] ^= Da;

    _, _, C[0] = #ROL_64(C[0], 1);
    _, _, C[1] = #ROL_64(C[1], 6);
    _, _, C[2] = #ROL_64(C[2], 25);
    _, _, C[3] = #ROL_64(C[3], 8);
    _, _, C[4] = #ROL_64(C[4], 18);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    E[10] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    E[11] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    E[12] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    E[13] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    E[14] = T[4];


    C[0] = state[4];
    C[1] = state[5];
    C[2] = state[11];
    C[3] = state[17];
    C[4] = state[23];

    C[0] ^= Du;
    C[1] ^= Da;
    C[2] ^= De;
    C[3] ^= Di;
    C[4] ^= Do;

    _, _, C[0] = #ROL_64(C[0], 27);
    _, _, C[1] = #ROL_64(C[1], 36);
    _, _, C[2] = #ROL_64(C[2], 10);
    _, _, C[3] = #ROL_64(C[3], 15);
    _, _, C[4] = #ROL_64(C[4], 56);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    E[15] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    E[16] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    E[17] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    E[18] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    E[19] = T[4];


    C[0] = state[2];
    C[1] = state[8];
    C[2] = state[14];
    C[3] = state[15];
    C[4] = state[21];

    C[0] ^= Di;
    C[1] ^= Do;
    C[2] ^= Du;
    C[3] ^= Da;
    C[4] ^= De;

    _, _, C[0] = #ROL_64(C[0], 62);
    _, _, C[1] = #ROL_64(C[1], 55);
    _, _, C[2] = #ROL_64(C[2], 39);
    _, _, C[3] = #ROL_64(C[3], 41);
    _, _, C[4] = #ROL_64(C[4], 2);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    E[20] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    E[21] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    E[22] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    E[23] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    E[24] = T[4];




    C[0] = E[0];
    C[1] = E[1];
    C[2] = E[2];
    C[3] = E[3];
    C[4] = E[4];

    C[0] ^= E[5];
    C[1] ^= E[6];
    C[2] ^= E[7];
    C[3] ^= E[8];
    C[4] ^= E[9];

    C[0] ^= E[10];
    C[1] ^= E[11];
    C[2] ^= E[12];
    C[3] ^= E[13];
    C[4] ^= E[14];

    C[0] ^= E[15];
    C[1] ^= E[16];
    C[2] ^= E[17];
    C[3] ^= E[18];
    C[4] ^= E[19];

    C[0] ^= E[20];
    C[1] ^= E[21];
    C[2] ^= E[22];
    C[3] ^= E[23];
    C[4] ^= E[24];

    Da = C[1];
    De = C[2];
    Di = C[3];
    Do = C[4];
    Du = C[0];

    _, _, Da = #ROL_64(Da, 1);
    _, _, De = #ROL_64(De, 1);
    _, _, Di = #ROL_64(Di, 1);
    _, _, Do = #ROL_64(Do, 1);
    _, _, Du = #ROL_64(Du, 1);

    Da ^= C[4];
    De ^= C[0];
    Di ^= C[1];
    Do ^= C[2];
    Du ^= C[3];


    C[0] = E[0];
    C[1] = E[6];
    C[2] = E[12];
    C[3] = E[18];
    C[4] = E[24];

    C[0] ^= Da;
    C[1] ^= De;
    C[2] ^= Di;
    C[3] ^= Do;
    C[4] ^= Du;

    _, _, C[1] = #ROL_64(C[1], 44);
    _, _, C[2] = #ROL_64(C[2], 43);
    _, _, C[3] = #ROL_64(C[3], 21);
    _, _, C[4] = #ROL_64(C[4], 14);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    T[0] ^= KeccakF_RoundConstants[2 * round + 1];
    state[0] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    state[1] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    state[2] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    state[3] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    state[4] = T[4];


    C[0] = E[3];
    C[1] = E[9];
    C[2] = E[10];
    C[3] = E[16];
    C[4] = E[22];

    C[0] ^= Do;
    C[1] ^= Du;
    C[2] ^= Da;
    C[3] ^= De;
    C[4] ^= Di;

    _, _, C[0] = #ROL_64(C[0], 28);
    _, _, C[1] = #ROL_64(C[1], 20);
    _, _, C[2] = #ROL_64(C[2], 3);
    _, _, C[3] = #ROL_64(C[3], 45);
    _, _, C[4] = #ROL_64(C[4], 61);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    state[5] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    state[6] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    state[7] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    state[8] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    state[9] = T[4];


    C[0] = E[1];
    C[1] = E[7];
    C[2] = E[13];
    C[3] = E[19];
    C[4] = E[20];

    C[0] ^= De;
    C[1] ^= Di;
    C[2] ^= Do;
    C[3] ^= Du;
    C[4] ^= Da;

    _, _, C[0] = #ROL_64(C[0], 1);
    _, _, C[1] = #ROL_64(C[1], 6);
    _, _, C[2] = #ROL_64(C[2], 25);
    _, _, C[3] = #ROL_64(C[3], 8);
    _, _, C[4] = #ROL_64(C[4], 18);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    state[10] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    state[11] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    state[12] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    state[13] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    state[14] = T[4];


    C[0] = E[4];
    C[1] = E[5];
    C[2] = E[11];
    C[3] = E[17];
    C[4] = E[23];

    C[0] ^= Du;
    C[1] ^= Da;
    C[2] ^= De;
    C[3] ^= Di;
    C[4] ^= Do;

    _, _, C[0] = #ROL_64(C[0], 27);
    _, _, C[1] = #ROL_64(C[1], 36);
    _, _, C[2] = #ROL_64(C[2], 10);
    _, _, C[3] = #ROL_64(C[3], 15);
    _, _, C[4] = #ROL_64(C[4], 56);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    state[15] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    state[16] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    state[17] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    state[18] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    state[19] = T[4];


    C[0] = E[2];
    C[1] = E[8];
    C[2] = E[14];
    C[3] = E[15];
    C[4] = E[21];

    C[0] ^= Di;
    C[1] ^= Do;
    C[2] ^= Du;
    C[3] ^= Da;
    C[4] ^= De;

    _, _, C[0] = #ROL_64(C[0], 62);
    _, _, C[1] = #ROL_64(C[1], 55);
    _, _, C[2] = #ROL_64(C[2], 39);
    _, _, C[3] = #ROL_64(C[3], 41);
    _, _, C[4] = #ROL_64(C[4], 2);

    T[0] = C[1];
    T[0] = #NOT_64(T[0]);
    T[0] &= C[2];
    T[0] ^= C[0];
    state[20] = T[0];

    T[1] = C[2];
    T[1] = #NOT_64(T[1]);
    T[1] &= C[3];
    T[1] ^= C[1];
    state[21] = T[1];

    T[2] = C[3];
    T[2] = #NOT_64(T[2]);
    T[2] &= C[4];
    T[2] ^= C[2];
    state[22] = T[2];

    T[3] = C[4];
    T[3] = #NOT_64(T[3]);
    T[3] &= C[0];
    T[3] ^= C[3];
    state[23] = T[3];

    T[4] = C[0];
    T[4] = #NOT_64(T[4]);
    T[4] &= C[1];
    T[4] ^= C[4];
    state[24] = T[4];
  }

  return state;
}






fn keccak_absorb_128_32(reg ptr u64[25] s, reg ptr u8[32] m) -> reg ptr u64[25]
{
 inline int i;

 reg u256 m256;
 reg u256 s256;

 s256 = s[u256 0];
 m256 = m[u256 0];
 s256 ^= m256;
 s[u256 0] = s256;

 s[u8 32] ^= 0x1F;
 s[u8 SHAKE128_RATE - 1] ^= 0x80;

 return s;
}







fn keccak_squeezeblocks_128_128(reg ptr u8[SHAKE128_RATE] h, reg ptr u64[25] s) -> reg ptr u8[SHAKE128_RATE], reg ptr u64[25]
{
 inline int i;

 reg u64 t64;

 reg u128 t128;

 s = KeccakF1600_StatePermute(s);

 for i = 0 to SHAKE128_RATE / 8 {
  t64 = s[u64 i];
  h[u64 i] = t64;
 }

 return h, s;
}








inline fn shake128_32_32(reg ptr u8[32] output, reg ptr u8[32] input) -> reg ptr u8[32]
{
 inline int i;

 reg u8 t8;

 reg u256 t256;

 stack u64[25] s;

 t256 = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256;
 }
 s[24] = 0;

 s = keccak_absorb_128_32(s, input);

 s = KeccakF1600_StatePermute(s);

 t256 = s[u256 0];
 output[u256 0] = t256;

 return output;
}

inline fn shake128_KK13N8_32(reg ptr u8[KK13N8] output, reg ptr u8[32] input) -> reg ptr u8[KK13N8]
{
 inline int i;
 inline int nblocks;

 reg u128[3] t128;
 reg u256 t256;

 stack u64[25] s;

 nblocks = 22;

 t256 = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256;
 }
 s[24] = 0;

 s = keccak_absorb_128_32(s, input);


 for i = 0 to nblocks {
  output[i * SHAKE128_RATE:SHAKE128_RATE], s = keccak_squeezeblocks_128_128(output[i * SHAKE128_RATE:SHAKE128_RATE], s);
 }

 s = KeccakF1600_StatePermute(s);

 t128[0] = s[u128 0];
 t128[1] = s[u128 1];
 t128[2] = s[u128 2];

 output[u128 231] = t128[0];
 output[u128 232] = t128[1];
 output[u128 233] = t128[2];

 return output;
}
inline fn shake128_MUNK8_32(reg ptr u8[MUNK8] output, reg ptr u8[32] input) -> reg ptr u8[MUNK8]
{
 inline int i;
 inline int nblocks;

 reg u256[3] t256;

 stack u64[25] s;

 nblocks = 4;

 t256[0] = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256[0];
 }
 s[24] = 0;

 s = keccak_absorb_128_32(s, input);


 for i = 0 to nblocks {
  output[i * SHAKE128_RATE:SHAKE128_RATE], s = keccak_squeezeblocks_128_128(output[i * SHAKE128_RATE:SHAKE128_RATE], s);
 }

 s = KeccakF1600_StatePermute(s);

 t256[0] = s[u256 0];
 t256[1] = s[u256 1];
 t256[2] = s[u256 2];

 output[u256 21] = t256[0];
 output[u256 22] = t256[1];
 output[u256 23] = t256[2];

 return output;
}
inline fn sha3_256_32(reg ptr u8[32] output, reg ptr u8[32] input) -> reg ptr u8[32]
{
 inline int i;

 reg u256 t256;
 reg u256 s256;

 stack u64[25] s;

 t256 = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256;
 }
 s[24] = 0;


 t256 = input[u256 0];
 s256 = s[u256 0];
 s256 ^= t256;
 s[u256 0] = s256;

 s[u8 32] ^= 0x06;
 s[u8 SHA3_256_RATE - 1] ^= 0x80;


 s = KeccakF1600_StatePermute(s);

 t256 = s[u256 0];
 output[u256 0] = t256;

 return output;
}
fn sha3_256_64(reg ptr u8[32] output, reg ptr u8[64] input) -> reg ptr u8[32]
{
 inline int i;

 reg u256[2] t256;
 reg u256[2] s256;

 stack u64[25] s;

 t256[0] = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256[0];
 }
 s[24] = 0;


 t256[0] = input[u256 0];
 s256[0] = s[u256 0];
 t256[1] = input[u256 1];
 s256[1] = s[u256 1];

 s256[0] ^= t256[0];
 s256[1] ^= t256[1];

 s[u256 0] = s256[0];
 s[u256 1] = s256[1];

 s[u8 64] ^= 0x06;
 s[u8 SHA3_256_RATE - 1] ^= 0x80;


 s = KeccakF1600_StatePermute(s);

 t256[0] = s[u256 0];
 output[u256 0] = t256[0];

 return output;
}







fn keccak_absorb_256_single(reg ptr u64[25] s, reg ptr u8[SHA3_256_RATE] m) -> reg ptr u64[25]
{
 inline int j;

 reg u64 t64;

 for j = 0 to SHA3_256_RATE / 8 {
  t64 = m[u64 j];
  s[u64 j] ^= t64;
 }

 s = KeccakF1600_StatePermute(s);

 return s;
}

fn sha3_256_PUBKEYBYTES(reg ptr u8[32] output, reg ptr u8[SABER_INDCPA_PUBLICKEYBYTES] input) -> reg ptr u8[32]
{
 inline int i;
 inline int nblocks;

 reg u64 t64;

 reg u256 t256;

 stack u64[25] s;

 nblocks = 7;

 t256 = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256;
 }
 s[24] = 0;


 for i = 0 to nblocks {
  s = keccak_absorb_256_single(s, input[i * SHA3_256_RATE:SHA3_256_RATE]);
 }

 for i = 0 to 5 {
  t64 = input[u64 119 + i];
  s[u64 i] ^= t64;
 }

 s[u8 40] ^= 0x06;
 s[u8 SHA3_256_RATE - 1] ^= 0x80;

 s = KeccakF1600_StatePermute(s);

 t256 = s[u256 0];
 output[u256 0] = t256;

 return output;
}
fn sha3_256_CCADEC(reg ptr u8[32] output, reg ptr u8[SABER_BYTES_CCA_DEC] input) -> reg ptr u8[32]
{
 inline int i;
 inline int nblocks;

 reg u256 t256;

 stack u64[25] s;

 nblocks = 8;

 t256 = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256;
 }
 s[24] = 0;


 for i = 0 to nblocks {
  s = keccak_absorb_256_single(s, input[i * SHA3_256_RATE:SHA3_256_RATE]);
 }

 s[u8 0] ^= 0x06;
 s[u8 SHA3_256_RATE - 1] ^= 0x80;

 s = KeccakF1600_StatePermute(s);

 t256 = s[u256 0];
 output[u256 0] = t256;

 return output;
}
fn sha3_512_64(reg ptr u8[64] output, reg ptr u8[64] input) -> reg ptr u8[64]
{
 inline int i;

 reg u256[2] t256;
 reg u256[2] s256;

 stack u64[25] s;

 t256[0] = zero_u256;

 for i = 0 to 6 {
  s[u256 i] = t256[0];
 }
 s[24] = 0;

 t256[0] = input[u256 0];
 t256[1] = input[u256 1];

 s256[0] = s[u256 0];
 s256[1] = s[u256 1];

 s256[0] ^= t256[0];
 s256[1] ^= t256[1];

 s[u256 0] = s256[0];
 s[u256 1] = s256[1];

 s[u8 64] ^= 0x06;
 s[u8 SHA3_512_RATE - 1] ^= 0x80;


 s = KeccakF1600_StatePermute(s);

 t256[0] = s[u256 0];
 t256[1] = s[u256 1];

 output[u256 0] = t256[0];
 output[u256 1] = t256[1];

 return output;
}


export fn KeccakF1600_StatePermute_jazz(reg u64 statep)
{
 inline int i;

 reg u64 t;

 stack u64[25] state;

 stack u64 sstatep;

 for i = 0 to 25 {
  t = (u64) [statep + 8 * i];
  state[i] = t;
 }

 sstatep = statep;

 state = KeccakF1600_StatePermute(state);

 statep = sstatep;

 for i = 0 to 25 {
  t = state[i];
  (u64) [statep + 8 * i] = t;
 }
}



export fn sha3_256_CCADEC_jazz(reg u64 outputp, reg u64 inputp)
{
 inline int i;

 reg u8 t;

 stack u8[32] output;
 stack u8[SABER_BYTES_CCA_DEC] input;

 stack u64 soutputp;

 for i = 0 to SABER_BYTES_CCA_DEC {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = sha3_256_CCADEC(output, input);

 outputp = soutputp;

 for i = 0 to 32 {
  t = output[i];
  (u8) [outputp + i] = t;
 }
}


export fn sha3_256_PUBKEYBYTES_jazz(reg u64 outputp, reg u64 inputp)
{
 inline int i;

 reg u8 t;

 stack u8[32] output;
 stack u8[SABER_INDCPA_PUBLICKEYBYTES] input;

 stack u64 soutputp;

 for i = 0 to SABER_INDCPA_PUBLICKEYBYTES {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = sha3_256_PUBKEYBYTES(output, input);

 outputp = soutputp;

 for i = 0 to 32 {
  t = output[i];
  (u8) [outputp + i] = t;
 }
}


export fn sha3_256_64_jazz(reg u64 outputp, reg u64 inputp)
{
 inline int i;

 reg u8 t;

 stack u8[32] output;
 stack u8[64] input;

 stack u64 soutputp;

 for i = 0 to 64 {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = sha3_256_64(output, input);

 outputp = soutputp;

 for i = 0 to 32 {
  t = output[i];
  (u8) [outputp + i] = t;
 }
}


export fn shake128_KK13N8_32_jazz(reg u64 outputp, reg u64 inputp)
{
 inline int i;

 reg u8 t;

 stack u8[KK13N8] output;
 stack u8[32] input;

 stack u64 soutputp;

 for i = 0 to 32 {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = shake128_KK13N8_32(output, input);

 outputp = soutputp;

 for i = 0 to KK13N8 {
  t = output[i];
  (u8) [outputp + i] = t;
 }
}


export fn shake128_32_32_jazz(reg u64 outputp, reg u64 inputp)
{
 inline int i;

 reg u8 t;

 stack u8[32] output;
 stack u8[32] input;

 stack u64 soutputp;

 for i = 0 to 32 {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = shake128_32_32(output, input);

 outputp = soutputp;

 for i = 0 to 32 {
  t = output[i];
  (u8) [outputp + i] = t;
 }
}


export fn keccak_squeezeblocks_128_128_jazz(reg u64 hp, reg u64 sp)
{
 inline int i;

 reg u8 th;

 reg u64 ts;

 stack u8[SHAKE128_RATE] h;

 stack u64[25] s;

 stack u64 shp;
 stack u64 ssp;

 for i = 0 to 25 {
  ts = (u64) [sp + 8 * i];
  s[i] = ts;
 }

 shp = hp;
 ssp = sp;

 h, s = keccak_squeezeblocks_128_128(h, s);

 hp = shp;
 sp = ssp;

 for i = 0 to SHAKE128_RATE {
  th = h[i];
  (u8) [hp + i] = th;
 }

 for i = 0 to 25 {
  ts = s[i];
  (u64) [sp + 8 * i] = ts;
 }
}


export fn shake128_MUNK8_32_jazz(reg u64 outputp, reg u64 inputp)
{
 inline int i;

 reg u8 t;

 stack u8[MUNK8] output;
 stack u8[32] input;

 stack u64 soutputp;

 for i = 0 to 32 {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = shake128_MUNK8_32(output, input);

 outputp = soutputp;

 for i = 0 to MUNK8 {
  t = output[i];
  (u8) [outputp + i] = t;
 }
}


export fn keccak_absorb_128_32_jazz(reg u64 sp, reg u64 mp)
{
 inline int i;

 reg u8 tm;

 reg u64 ts;

 stack u8[32] m;

 stack u64[25] s;

 for i = 0 to 25 {
  ts = (u64) [sp + 8 * i];
  s[i] = ts;
 }

 for i = 0 to 32 {
  tm = (u8) [mp + i];
  m[i] = tm;
 }

 s = keccak_absorb_128_32(s, m);

 for i = 0 to 25 {
  ts = s[i];
  (u64) [sp + 8 * i] = ts;
 }
}


export fn sha3_256_32_jazz(reg u64 outputp, reg u64 inputp)
{
 inline int i;

 reg u8 t;

 stack u8[32] output;
 stack u8[32] input;

 stack u64 soutputp;

 for i = 0 to 32 {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = sha3_256_32(output, input);

 outputp = soutputp;

 for i = 0 to 32 {
  t = output[i];
  (u8) [outputp + i] = t;
 }

}

export fn sha3_512_64_jazz(reg u64 outputp, reg u64 inputp)
{

 inline int i;

 reg u8 t;

 stack u8[64] output;
 stack u8[64] input;

 stack u64 soutputp;

 for i = 0 to 64 {
  t = (u8) [inputp + i];
  input[i] = t;
 }

 soutputp = outputp;

 output = sha3_512_64(output, input);

 outputp = soutputp;

 for i = 0 to 64 {
  t = output[i];
  (u8) [outputp + i] = t;
 }
}
