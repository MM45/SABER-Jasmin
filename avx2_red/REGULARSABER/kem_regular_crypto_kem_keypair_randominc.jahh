/*** kem_regular_crypto_kem_keypair_randominc.jahh: File containing the Jasmin implementation of the crypto_kem_keypair_randominc function from kem.c, with (regular) SABER parameters ***/

#ifndef CRYPTO_KEM_KEYPAIR_RANDOMINC_HH
#define CRYPTO_KEM_KEYPAIR_RANDOMINC_HH

#include "SABER_params.jahh"
#include "SABER_indcpa_regular_indcpa_kem_keypair_randominc.jahh"
#include "fips202_regular_sha3_256_PUBKEYBYTES.jahh"

inline fn crypto_kem_keypair_randominc(stack u8[SABER_PUBLICKEYBYTES] pk, stack u8[SABER_SECRETKEYBYTES] sk, stack u8[SABER_KEYBYTES] random_bytes_crypto, stack u8[SABER_SEEDBYTES] indcpa_seed, stack u8[SABER_COINBYTES] indcpa_noiseseed) -> stack u8[SABER_PUBLICKEYBYTES], stack u8[SABER_SECRETKEYBYTES]
{
	inline int j;

	reg u8 t8;

	reg u64 i;
	reg u64 address;

	pk, sk[0:SABER_INDCPA_SECRETKEYBYTES] = indcpa_kem_keypair_randominc(pk, sk[0:SABER_INDCPA_SECRETKEYBYTES], indcpa_seed, indcpa_noiseseed);

	i = 0;
	address = SABER_INDCPA_SECRETKEYBYTES;
	while (i < SABER_INDCPA_PUBLICKEYBYTES) {
		t8 = pk[(int) i];
		sk[(int) address] = t8;

		i += 1;
		address += 1;
	}

	sk[SABER_SECRETKEYBYTES - 64:SABER_HASHBYTES] = sha3_256_PUBKEYBYTES(sk[SABER_SECRETKEYBYTES - 64:SABER_HASHBYTES], pk);

	for j = 0 to SABER_KEYBYTES {
		t8 = random_bytes_crypto[j];
		sk[SABER_SECRETKEYBYTES - SABER_KEYBYTES + j] = t8;
	}

	return pk, sk;
}

#endif