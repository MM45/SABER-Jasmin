/*** pack_unpack_light.jazz: File containing the Jasmin wrappers of the functions in the pack_unpack_light_*.jahh files, only used for unit testing ***/

#include "SABER_params.jahh"
#include "pack_unpack_light_SABER_pack_3bit.jahh"
#include "pack_unpack_light_SABER_un_pack3bit.jahh"


export fn SABER_pack_3bit_jazz(reg u64 bytesp, reg u64 datap)
{
	inline int i;

	reg u8 tb;
	reg u16 td;

	stack u8[SABER_SCALEBYTES_KEM] bytes;
	stack u16[SABER_N] data;

	// TODO: Technically not necessary to copy, as bytes contains no relevant content on input, is only used as a result array
	for i = 0 to SABER_SCALEBYTES_KEM {
		tb = (u8) [bytesp + i];
		bytes[i] = tb;
	}

	for i = 0 to SABER_N {
		td = (u16) [datap + 2 * i];
		data[i] = td;
	}

	bytes = SABER_pack_3bit(bytes, data);

	for i = 0 to SABER_SCALEBYTES_KEM {
		tb = bytes[i];
		(u8) [bytesp + i] = tb;
	}
}

export fn SABER_un_pack3bit_jazz(reg u64 bytesp, reg u64 datap)
{
	inline int i;

	reg u8 tb;
	reg u16 td;

	stack u8[SABER_SCALEBYTES_KEM] bytes;
	stack u16[SABER_N] data;

	for i = 0 to SABER_SCALEBYTES_KEM {
		tb = (u8) [bytesp + i];
		bytes[i] = tb;
	}

	// TODO: Technically not necessary to copy, as data contains no relevant content on input, is only used as a result array
	for i = 0 to SABER_N {
		td = (u16) [datap + 2 * i];
		data[i] = td;
	}

	data = SABER_un_pack3bit(bytes, data);

	for i = 0 to SABER_N {
		td = data[i];
		(u16) [datap + 2 * i] = td;
	}
}
