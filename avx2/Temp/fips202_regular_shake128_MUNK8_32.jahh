/*** fips202_regular_shake128_MUNK8_32.jahh: File containing the Jasmin implementation of shake128 function from fips202.c, where outlen == MUNK8, inlen == 32 and with (regular) SABER parameters ***/

#ifndef SHAKE128_MUNK8_32_HH
#define SHAKE128_MUNK8_32_HH

#include "SABER_params.jahh"
#include "fips202_regular_KeccakF1600_StatePermute.jahh"

inline fn shake128_MUNK8_32(reg ptr u8[MUNK8] output, reg ptr u8[32] input) -> reg ptr u8[MUNK8]
{
	inline int i;
	inline int nblocks;
	inline int handled;
	inline int remainder;

	reg u8 t8;

	reg u64 j;
	reg u64 address;

	stack u64[25] s;

	nblocks = MUNK8 / SHAKE128_RATE;
	handled = nblocks * SHAKE128_RATE;
	remainder = MUNK8 - handled;

	for i = 0 to 25 {
		s[i] = 0;
	}

	//s = keccak_absorb_128_32(s, input);
	for i = 0 to 32 {
		t8 = input[i];
		s[u8 i] ^= t8; 
	}

	s[u8 32] ^= 0x1F;
	s[u8 SHAKE128_RATE - 1] ^= 0x80;

	// output, s = keccak_squeezeblocks_128_MUNK8(output, s);
	address = 0;
	for i = 0 to nblocks {
		s = KeccakF1600_StatePermute(s);

		j = 0;
		while (j < SHAKE128_RATE) {
			t8 = s[u8 (int) j];
			output[(int) address] = t8; //store64(h[j * SHAKE128_RATE + 8 * i:8], u);

			j += 1;
			address += 1;
		}
	}

	// t, s = keccak_squeezeblocks_128_128(t, s);
	s = KeccakF1600_StatePermute(s);

	for i = 0 to remainder {
		t8 = s[u8 i];
		output[handled + i] = t8;
	}

	return output;
}

#endif