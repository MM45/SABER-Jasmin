/*** auxilliary.jazz: File containing the Jasmin wrappers of the functions in the auxilliary_*.jahh files, only used for unit testing ***/

#include "auxilliary_load_16u16.jahh"
#include "auxilliary_load_4u64.jahh"
#include "auxilliary_store_16u16.jahh"
#include "auxilliary_andnot_256.jahh"
#include "auxilliary_rol_4u64.jahh"
#include "auxilliary_rol_4u64_rho8.jahh"
#include "auxilliary_rol_4u64_rho56.jahh"

export fn load_16u16_jazz(reg u64 bufp) -> reg u256
{
	inline int i;

	reg u16 t16;

	reg u256 r;

	stack u16[16] buf;

	for i = 0 to 16 {
		t16 = (u16) [bufp + 2 * i];
		buf[i] = t16;
	}

	r = load_16u16(buf);

	return r;
}

export fn store_16u16_jazz(reg u64 rp, reg u64 bufp)
{
	inline int i;

	reg u16 t16;

	reg u256 r;

	stack u16[16] buf;
	
	r = (u256) [rp]; 

	buf = store_16u16(r, buf);

	for i = 0 to 16 {
		t16 = buf[i];
		(u16) [bufp + 2 * i] = t16;
	}
}

export fn andnot_256_jazz(reg u64 ap, reg u64 bp) -> reg u256
{
	inline int i;

	reg u16 t16;

	reg u256 a;
	reg u256 b;
	reg u256 r;

	a = (u256) [ap];
	b = (u256) [bp];

	r = andnot_256(a, b);

	return r;
}

export fn load_4u64_jazz(reg u64 bufp) -> reg u256
{
	inline int i;

	reg u64 t64;

	reg u256 r;

	stack u64[4] buf;

	for i = 0 to 4 {
		t64 = (u64) [bufp + 8 * i];
		buf[i] = t64;
	}

	r = load_4u64(buf);

	return r;
}

export fn rol_4u64_jazz(reg u64 ap) -> reg u256
{
	inline int o;

	reg u256 a;
	reg u256 r;

	a = (u256) [ap];
	
	o = 31;

	r = rol_4u64(a, o);

	return r;
}

export fn rol_4u64_rho8_jazz(reg u64 ap) -> reg u256
{
	reg u256 a;
	reg u256 r;

	a = (u256) [ap];

	r = rol_4u64_rho8(a);

	return r;
}

export fn rol_4u64_rho56_jazz(reg u64 ap) -> reg u256
{
	reg u256 a;
	reg u256 r;

	a = (u256) [ap];

	r = rol_4u64_rho56(a);

	return r;
}