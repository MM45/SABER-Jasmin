








param int CRYPTO_SECRETKEYBYTES = 2304;
param int CRYPTO_PUBLICKEYBYTES = (3 * 320 + 32);
param int CRYPTO_BYTES = 32;
param int CRYPTO_CIPHERTEXTBYTES = 1088;
param int Saber_type = 2;

param int SABER_K = 3;
param int SABER_MU = 8;
param int SABER_ET = 4;

param int SABER_EQ = 13;
param int SABER_EP = 10;

param int SABER_N = 256;
param int SABER_Q = 8192;
param int SABER_P = 1024;

param int SABER_SEEDBYTES = 32;
param int SABER_NOISESEEDBYTES = 32;
param int SABER_COINBYTES = 32;
param int SABER_KEYBYTES = 32;

param int SABER_HASHBYTES = 32;

param int SABER_POLYBYTES = 416;

param int SABER_POLYVECBYTES = (SABER_K * SABER_POLYBYTES);

param int SABER_POLYVECCOMPRESSEDBYTES = (SABER_K * 320);

param int SABER_CIPHERTEXTBYTES = (SABER_POLYVECCOMPRESSEDBYTES);



param int SABER_SCALEBYTES_KEM = (SABER_ET * SABER_N / 8);

param int SABER_INDCPA_PUBLICKEYBYTES = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SEEDBYTES);
param int SABER_INDCPA_SECRETKEYBYTES = (SABER_POLYVECBYTES);

param int SABER_PUBLICKEYBYTES = (SABER_INDCPA_PUBLICKEYBYTES);

param int SABER_SECRETKEYBYTES = (SABER_INDCPA_SECRETKEYBYTES + SABER_INDCPA_PUBLICKEYBYTES + SABER_HASHBYTES + SABER_KEYBYTES);

param int SABER_BYTES_CCA_DEC = (SABER_POLYVECCOMPRESSEDBYTES + SABER_SCALEBYTES_KEM);



param int SABER_KN = (SABER_K * SABER_N);
param int SABER_KKN = (SABER_K * SABER_K * SABER_N);
param int N_SB = (SABER_N / 4);
param int N_SB_RES = (2 * N_SB - 1);

param int SHAKE128_RATE = 168;
param int SHAKE256_RATE = 136;
param int SHA3_256_RATE = 136;
param int SHA3_512_RATE = 72;

param int KK13N8 = (SABER_K * SABER_K * (13 * SABER_N / 8));
param int MUNK8 = (SABER_MU * SABER_N * SABER_K / 8);

param int h1 = 4;
param int h2 = 228;




u128 zero_u128 = 0;

u256 zero_u256 = 0;

u256 h1_16u16 = 0x0004000400040004000400040004000400040004000400040004000400040004;
u256 h2_16u16 = 0x00e400e400e400e400e400e400e400e400e400e400e400e400e400e400e400e4;
u256 modp_16u16 = 0x03ff03ff03ff03ff03ff03ff03ff03ff03ff03ff03ff03ff03ff03ff03ff03ff;
u256 modq_16u16 = 0x1fff1fff1fff1fff1fff1fff1fff1fff1fff1fff1fff1fff1fff1fff1fff1fff;

u256 twobit_mask_16u16 = 0x0003000300030003000300030003000300030003000300030003000300030003;
u256 fourbit_mask_16u16 = 0x000f000f000f000f000f000f000f000f000f000f000f000f000f000f000f000f;
u256 sixbit_mask_16u16 = 0x003f003f003f003f003f003f003f003f003f003f003f003f003f003f003f003f;

u256 modq_8u32 = 0x00001fff00001fff00001fff00001fff00001fff00001fff00001fff00001fff;

u256 fourbit_mask_8u32 = 0x0000000f0000000f0000000f0000000f0000000f0000000f0000000f0000000f;
u256 sixteenbit_mask_8u32 = 0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff;

u256 onebit_mask_64u4 = 0x1111111111111111111111111111111111111111111111111111111111111111;

u256 five_mask_64u4 = 0x5555555555555555555555555555555555555555555555555555555555555555;
u256 three_mask_64u4 = 0x3333333333333333333333333333333333333333333333333333333333333333;
u256 fourbit_mask_32u8 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;






inline fn verify(stack u8[SABER_BYTES_CCA_DEC] a, stack u8[SABER_BYTES_CCA_DEC] b) -> reg u64
{
 reg u32 t32;
 reg u32 r32;

 reg u64 i;
 reg u64 r;

 r32 = 0;
 i = 0;
 while (i < SABER_BYTES_CCA_DEC / 4) {

  t32 = a[u32 (int) i];
  t32 ^= b[u32 (int) i];
  r32 |= t32;

  i += 1;
 }


 r = (64u) r32;
 r *= -1;
 r >>= 63;

 return r;
}







inline fn cmov(stack u8[SABER_KEYBYTES] r, stack u8[SABER_KEYBYTES] x, reg u8 b) -> stack u8[SABER_KEYBYTES]
{
 inline int i;

 reg u128 t128;

 reg u256 b256;
 reg u256 r256;
 reg u256 x256;

 _, _, _, _, _, b = #NEG_8(b);

 t128 = zero_u128;
 t128 = #VPINSR_16u8(t128, b, 0);

 b256 = #VPBROADCAST_32u8(t128);
 r256 = r[u256 0];
 x256 = x[u256 0];

 x256 ^= r256;

 x256 &= b256;

 r256 ^= x256;

 r[u256 0] = r256;

 return r;
}

export fn verify_jazz(reg u64 ap, reg u64 bp) -> reg u64
{
 inline int i;

 reg u64 r;

 reg u256 t256;

 stack u8[SABER_BYTES_CCA_DEC] a;
 stack u8[SABER_BYTES_CCA_DEC] b;

 for i = 0 to SABER_BYTES_CCA_DEC / 32 {
  t256 = (u256) [ap + 32 * i];
  a[u256 i] = t256;
 }

 for i = 0 to SABER_BYTES_CCA_DEC / 32 {
  t256 = (u256) [bp + 32 * i];
  b[u256 i] = t256;
 }

 r = verify(a, b);

 return r;
}

export fn cmov_jazz(reg u64 rp, reg u64 xp, reg u8 b)
{
 inline int i;

 reg u256 t256;

 stack u8[SABER_KEYBYTES] r;
 stack u8[SABER_KEYBYTES] x;

 for i = 0 to SABER_KEYBYTES / 32 {
  t256 = (u256) [rp + 32 * i];
  r[u256 i] = t256;
 }

 for i = 0 to SABER_KEYBYTES / 32 {
  t256 = (u256) [xp + 32 * i];
  x[u256 i] = t256;
 }

 r = cmov(r, x, b);

 for i = 0 to SABER_KEYBYTES / 32 {
  t256 = r[u256 i];
  (u256) [rp + 32 * i] = t256;
 }
}
