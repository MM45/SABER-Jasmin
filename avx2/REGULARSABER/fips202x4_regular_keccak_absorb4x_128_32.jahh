/*** fips202x4_regular_keccak_absorb4x_128_32.jahh: File containing the Jasmin implementation of keccak_absorb4x function from fips202x4.c, where rate == SHAKE128RATE, mlen == 32 and with (regular) SABER parameters ***/

#ifndef KECCAK_ABSORB4X_128_32_HH
#define KECCAK_ABSORB4X_128_32_HH

#include "SABER_params.jahh"
#include "fips202x4_regular_load64.jahh"

fn keccak_absorb4x_128_32(reg ptr u256[25] s, reg ptr u8[32] m0, reg ptr u8[32] m1, reg ptr u8[32] m2, reg ptr u8[32] m3) -> reg ptr u256[25]
{
	inline int i;

	reg u8 t8;

	reg u64 t64;

	stack u8[200] t0;
	stack u8[200] t1;
	stack u8[200] t2;
	stack u8[200] t3;

	for i = 0 to SHAKE128_RATE {
		t0[i] = 0;
		t1[i] = 0;
		t2[i] = 0;
		t3[i] = 0;
	}

	for i = 0 to 32 {
		t8 = m0[i];
		t0[i] = t8;
		
		t8 = m1[i];
		t1[i] = t8;
		
		t8 = m2[i];
		t2[i] = t8;
		
		t8 = m3[i];
		t3[i] = t8;
	}

	t0[32] = 0x1F;
	t1[32] = 0x1F;
	t2[32] = 0x1F;
	t3[32] = 0x1F;

	t0[SHAKE128_RATE - 1] |= 128;
	t1[SHAKE128_RATE - 1] |= 128;
	t2[SHAKE128_RATE - 1] |= 128;
	t3[SHAKE128_RATE - 1] |= 128;

	for i = 0 to (SHAKE128_RATE / 8) {
		t64 = load64(t0[8 * i:8]);
		s[u64 4 * i] ^= t64;
		t64 = load64(t1[8 * i:8]);
		s[u64 4 * i + 1] ^= t64;
		t64 = load64(t2[8 * i:8]);
		s[u64 4 * i + 2] ^= t64;
		t64 = load64(t3[8 * i:8]);
		s[u64 4 * i + 3] ^= t64;
	}

	return s;
}

#endif